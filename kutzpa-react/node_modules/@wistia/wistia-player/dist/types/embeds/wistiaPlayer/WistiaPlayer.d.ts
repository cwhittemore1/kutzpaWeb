import type { Authorization, FullscreenState } from './types.ts';
import type { WistiaPlayerEvents } from '../../types/events.ts';
import type { AllowedQualities, EmbedOptions, Localization, MediaData, MediaDataServerErrorResponse, OverlayOptions, Players, PlayerState, PopoverAnimation, PopoverContentSettings, PublicApi, ReplaceWithMediaOptions } from '../../types/player-api-types.ts';
import type { PluginConfigs, PluginInstances } from '../../types/plugins.ts';
import { AFTER_REPLACE_EVENT, API_READY_EVENT, BEFORE_REPLACE_EVENT, INPUT_CONTEXT_CHANGE_EVENT, LOADED_MEDIA_DATA_EVENT, MUTE_CHANGE_EVENT } from '../../utilities/eventConstants.ts';
import { GetInitialMediaDataOptions } from './utilities/getInitialMediaData.ts';
import { ControlInstances } from '../../types/controls.ts';
import { Gradient } from '../../types/gradient.ts';
export declare class WistiaPlayer extends HTMLElement {
    #private;
    plugin: PluginInstances | null;
    /**
     * Represents one embedded Wistia media player.
     * @constructor
     */
    constructor();
    /**
     * Return an array of the attributes that we want to observe for changes.
     * If one of these attributes changes, the attributeChangedCallback will be called.
     * @returns {string[]}
     */
    static get observedAttributes(): string[];
    /**
     * @returns {FullscreenState} private fullscreenState of the video.
     */
    get _fullscreenState(): FullscreenState;
    /**
     * @param {FullscreenState} state private fullscreenState of the video.
     */
    set _fullscreenState(state: FullscreenState);
    /**
     * @deprecated The method should not be used
     * @returns {object | null |undefined }  private - old engine being transferred.
     */
    get _oldEngine(): object | null | undefined;
    /**
     * @deprecated The method should not be used
     * @param {object | null | undefined} engine private old engine to be transferred of the video.
     */
    set _oldEngine(engine: object | null | undefined);
    /**
     * Returns the aspect ratio (width / height) of the originally uploaded video or given aspect ratio.
     * @returns {number}
     */
    get aspect(): number;
    /**
     * Sets the aspect ratio (width / height) of the video.
     * @param {number} newAspect
     * @returns {void}
     */
    set aspect(newAspect: number);
    /**
     * Returns whether the Audio Description control in the control bar is enabled.
     * @returns {boolean}
     */
    get audioDescriptionControl(): boolean;
    /**
     * Enable or disable the Audio Description control in the control bar. Note: Even if set to `true`, this control will
     * only appear if the video has an Audio Description track.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set audioDescriptionControl(shouldDisplay: boolean);
    /**
     * sets the authorization property to be used for authorized asset delivery
     * @param {Authorization}
     * @returns {void}
     */
    set authorization(auth: Authorization);
    /**
     * Returns if the player should attempt to autoplay as soon as it's ready.
     * @returns {boolean}
     */
    get autoplay(): boolean;
    /**
     * Sets the attribute to enable/disable autoplay.
     * @param {boolean} shouldSetAutoplay
     * @returns {void}
     */
    set autoplay(shouldSetAutoplay: boolean);
    /**
     * Returns if the big play button control will appear in the center of the video before play.
     * @returns {boolean}
     */
    get bigPlayButton(): boolean;
    /**
     * Sets if the big play button control will appear in the center of the video before play.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set bigPlayButton(shouldDisplay: boolean);
    /**
     * Returns the border radius of the big play button.
     * @returns {number}
     */
    get bigPlayButtonBorderRadius(): number;
    /**
     * Sets the border radius of the big play button.
     * @param {number} radius
     * @returns {void}
     */
    set bigPlayButtonBorderRadius(radius: number);
    get branding(): boolean;
    /**
     * This can only be used to enable the wistia logo for players
     * that might not otherwise require it. We don't want to introduce
     * the ability to easily hide the wistia logo for players where it's required.
     */
    set branding(value: unknown);
    /**
     * Returns a new static normalized TimeRanges object that represents the ranges of the media resource,
     * if any, that the user agent has buffered at the moment the buffered property is accessed.
     * @returns {TimeRanges}
     */
    get buffered(): TimeRanges;
    /**
     * Returns the border radius of the control bar.
     * @returns {number}
     */
    get controlBarBorderRadius(): number;
    /**
     * Sets the border radius of the control bar.
     * @param {number} radius
     * @returns {void}
     */
    set controlBarBorderRadius(radius: number);
    /**
     * Getter. Returns all defined controls.
     * @returns {ControlInstances} returns object of defined controls. Please note this may return an
     * empty object if not controls have yet been defined.
     */
    get controls(): ControlInstances;
    /**
     * Returns whether or not to hide the controls on load.
     * @returns {boolean}
     */
    get controlsVisibleOnLoad(): boolean;
    /**
     * Sets whether or not to hide the controls on load.
     * @param {boolean} shouldHide
     * @returns {void}
     */
    set controlsVisibleOnLoad(shouldHide: boolean);
    /**
     * Returns whether or the copy link and thumbnail option from the context menu
     * is available.
     * @returns {boolean}
     */
    get copyLinkAndThumbnail(): boolean;
    /**
     * Enable or disable the copy link and thumbnail option from the context menu.
     * @param {boolean} enabled
     * @returns {void}
     */
    set copyLinkAndThumbnail(enabled: boolean);
    /**
     * Returns the current time of the video as a decimal in seconds.
     * @returns {number}
     */
    get currentTime(): number;
    /**
     * Sets the current time of the video as a decimal in seconds.
     * @param {number} newTime
     * @returns {void}
     */
    set currentTime(newTime: number);
    /**
     * @returns {object} helpful object for debugging
     */
    get debug(): object;
    /**
     * Returns the public api instance.
     * @deprecated this is a deprecated method and should not be used.
     * @returns {PublicApi | null}
     */
    get deprecatedApiDoNotUse(): PublicApi | null;
    /**
     * Returns the status of the do not track embed option that controls whether the player
     * sends tracking pings.
     * @returns {boolean}
     */
    get doNotTrack(): boolean;
    /**
     * When present the player will not send tracking events for stats.
     * Note that this must be set at the time of embed to have any impact.
     * @param {boolean} dontTrack
     * @returns {void}
     */
    set doNotTrack(dontTrack: boolean);
    /**
     * Returns the duration of the video in seconds.
     * @returns {number}
     */
    get duration(): number;
    /**
     * Returns the email associated with this viewing session.
     * If no email is associated, it will return undefined.
     * NOTE: This attribute will impact the entire page and is not scoped to the player.
     * @returns {string | undefined}
     */
    get email(): string | undefined;
    /**
     * Associates the view of this media with the given email value.
     * This email will appear in stats for the video.
     * NOTE: This attribute will impact the entire page and is not scoped to the player.
     * @param {string} newEmail
     * @returns {void}
     */
    set email(newEmail: string);
    /**
     * Returns the overridding embed host for the player.
     * Internal use only.
     * @returns {string | null | undefined}
     */
    get embedHost(): string | null | undefined;
    /**
     * Sets the overridding embed host for the player.
     * Internal use only.
     * @param {string} newEmbedHost
     * @returns {void}
     */
    set embedHost(newEmbedHost: string);
    /**
     * Returns all the embed options being set on the WistiaPlayer from attributes and mediaData json
     * @returns {EmbedOptions }
     */
    get embedOptions(): EmbedOptions;
    /**
     * Returns whether the video has ended playback.
     * @returns {boolean}
     */
    get ended(): boolean;
    /**
     * Returns the current end video behavior value
     * @returns {string}
     */
    get endVideoBehavior(): string;
    /**
     * Sets the behavior for what the video should do when it ends.
     * @param {'default' | 'loop' | 'reset'} behavior
     * @returns {void}
     */
    set endVideoBehavior(behavior: 'default' | 'loop' | 'reset');
    /**
     * Returns the embed's event key if it exists.
     * @returns {string | undefined}
     */
    get eventKey(): string | undefined;
    /**
     * Returns if the fullscreen button control will appear in the control bar.
     * @returns {boolean}
     */
    get fullscreenControl(): boolean;
    /**
     * Sets if the fullscreen button control is enabled in the control bar.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set fullscreenControl(shouldDisplay: boolean);
    /**
     * Returns if the video should use HLS playback.
     * Internal only.
     * @returns {boolean}
     */
    get hls(): boolean;
    /**
     * Sets if the video should use HLS playback.
     * Internal only.
     * @param {boolean} shouldUseHls
     * @returns {void}
     */
    set hls(shouldUseHls: boolean);
    /**
     * Returns whether the video is currently in fullscreen
     * @returns {boolean}
     */
    get inFullscreen(): boolean;
    get inputContext(): string | undefined;
    /**
     * Returns whether instantHLS is enabled for the video.
     * @returns {boolean}
     */
    get instantHls(): boolean;
    get language(): Localization | undefined;
    set language(language: string | undefined);
    get languages(): Localization[];
    /**
     * Returns all the mediaData set on the WistiaPlayer
     * @returns {MediaData }
     */
    get mediaData(): MediaData;
    /**
     * Returns the hashed id of the media.
     * @returns {string}
     */
    get mediaId(): string;
    /**
     * Replaces the content of the current video with the video identified by the given mediaId.
     * @param {string} newMediaId
     * @returns {void}
     */
    set mediaId(newMediaId: string);
    /**
     * Returns if player is currently muted
     * @returns {boolean}
     */
    get muted(): boolean;
    /**
     * Change player muted state
     * @param {boolean} shouldMute
     */
    set muted(shouldMute: boolean);
    /**
     * Returns the name of the media as it is in the Wistia application.
     * Returns undefined until media data is loaded.
     * @returns {string | undefined}
     */
    get name(): string | undefined;
    get paddingTop(): string;
    set paddingTop(paddingTop: string);
    /**
     * Returns a boolean that indicates whether the video is paused.
     * @returns {boolean}
     */
    get paused(): boolean;
    /**
     * Returns the percent of the video that has been watched as a decimal between 0 and 1.
     * @returns {number}
     */
    get percentWatched(): number;
    /**
     * Returns the playback rate of the video.
     * @returns {number}
     */
    get playbackRate(): number;
    /**
     * Set the playback rate of the video.
     * @param {number} rate
     * @returns {void}
     */
    set playbackRate(rate: number);
    /**
     * If set to true, the playback rate control will appear in the setting control.
     * @returns {boolean}
     */
    get playbackRateControl(): boolean;
    /**
     * enable or disable the playback rate control in the settings control.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set playbackRateControl(shouldDisplay: boolean);
    /**
     * Returns if the playbar - which includes the playhead, current time, and scrubbing functionality - will be available.
     * @returns {boolean}
     */
    get playBarControl(): boolean;
    /**
     * Sets if the playbar - which includes the playhead, current time, and scrubbing functionality - will be available.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set playBarControl(shouldDisplay: boolean);
    /**
     * Returns the border radius of the player.
     * @returns {number}
     */
    get playerBorderRadius(): number;
    /**
     * Sets the border radius of the player.
     * @param {number} radius
     * @returns {void}
     */
    set playerBorderRadius(radius: number);
    /**
     * Returns the base color of the player.
     * @returns {string}
     */
    get playerColor(): string;
    /**
     * Changes the base color of the player.
     * Expects a hexadecimal rgb string like "ff0000" (red), "000000" (black), "ffffff" (white), or "0000ff" (blue).
     * @param {string} newColor
     * @returns {void}
     */
    set playerColor(newColor: string);
    /**
     * Returns the player color gradient object.
     * @returns {Gradient | undefined}
     */
    get playerColorGradient(): Gradient | undefined;
    /**
     * Sets the player color gradient object.
     * @param {Gradient} gradient
     * @returns {void}
     */
    set playerColorGradient(gradient: Gradient);
    /**
     * Returns the overridding player.
     * Internal use only.
     * @returns {Players | undefined}
     */
    get playerForce(): Players | undefined;
    /**
     * Sets the overridding player.
     * Internal use only.
     * @param {string} newPlayer
     * @returns {void}
     */
    set playerForce(newPlayer: Players);
    /**
     * Returns the strategy for associating specially crafted links on a page with a video, turning them into a playlist.
     * auto: For each video on the page, look for links after the video, until we come to another Wistia video.
     * manual: Given each link element, look at its 'container' option to determine which video it should connect to.
     * "container": For all embed links in a container whose id matches this given string, connect them to this specific video.
     * @returns {'auto' | 'manual' | string}
     */
    get playlistLinks(): string;
    /**
     * Sets the strategy for associating specially crafted links on a page with a video, turning them into a playlist.
     * @param {'auto' | 'manual' | string} newStrategy
     * @returns {void}
     */
    set playlistLinks(newStrategy: string);
    /**
     * When present or set to true and this video has a playlist, it will loop back to
     * the first video and replay it once the last video has finished.
     * @returns {boolean}
     */
    get playlistLoop(): boolean;
    /**
     * When present or set to true and this video has a playlist, it will loop back to
     * the first video and replay it once the last video has finished.
     * @param {boolean} shouldLoop
     * @returns {void}
     */
    set playlistLoop(shouldLoop: boolean);
    /**
     * If set to true, the small play button control will be available.
     * @returns {boolean}
     */
    get playPauseControl(): boolean;
    /**
     * If set to true, the small play button control will be available.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set playPauseControl(shouldDisplay: boolean);
    /**
     * By default, pausing a video will display a brief animation of the pause symbol
     * and resuming the video will display an animation of the play symbol.
     * Setting this embed option to false will remove those animations.
     * @returns {boolean}
     */
    get playPauseNotifier(): boolean;
    /**
     * By default, pausing a video will display a brief animation of the pause symbol
     * and resuming the video will display an animation of the play symbol.
     * Setting this embed option to false will remove those animations.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set playPauseNotifier(shouldDisplay: boolean);
    /**
     * Getter. Returns all defined plugins.
     * @returns {PluginInstances} returns object of defined plugins. Please note this may return an
     * empty object if not plugins have yet been defined.
     */
    get plugins(): PluginInstances;
    /**
     * Returns if the play button will expand to cover the thumbnail on hover,
     * while also displaying the duration of the video.
     * @returns {boolean}
     */
    get popoverAnimateThumbnail(): boolean;
    /**
     * Sets if the play button will expand to cover the thumbnail on hover,
     * while also displaying the duration of the video.
     * @param {boolean} shouldAnimate
     * @returns {void}
     */
    set popoverAnimateThumbnail(shouldAnimate: boolean);
    /**
     * Returns the current state of the video.
     * @returns {PopoverAnimation}
     */
    get popoverAnimation(): PopoverAnimation;
    /**
     * Sets if the play button will expand to cover the thumbnail on hover,
     * while also displaying the duration of the video.
     * @param {PopoverAnimation} newAnimation
     * @returns {void}
     */
    set popoverAnimation(newAnimation: PopoverAnimation);
    /**
     * Returns the border color of the popover.
     * @returns {string}
     */
    get popoverBorderColor(): string;
    /**
     * Sets the border color of the popover.
     * @param {string} newColor
     * @returns {void}
     */
    set popoverBorderColor(newColor: string);
    /**
     * Returns the border radius of the popover.
     * @returns {number}
     */
    get popoverBorderRadius(): number;
    /**
     * Sets the border radius of the popover.
     * @param {number} newRadius
     * @returns {void}
     */
    set popoverBorderRadius(newRadius: number);
    /**
     * Returns the border width of the popover.
     * @returns {number}
     */
    get popoverBorderWidth(): number;
    /**
     * Sets the border width of the popover.
     * @param {number} newWidth
     * @returns {void}
     */
    set popoverBorderWidth(newWidth: number);
    /**
     * Returns if the popover should be displayed with a box shadow.
     * @returns {boolean}
     */
    get popoverBoxShadow(): boolean;
    /**
     * Sets if the popover should be displayed with a box shadow.
     * @param {boolean} shouldDisplayBoxShadow
     * @returns {void}
     */
    set popoverBoxShadow(shouldDisplayBoxShadow: boolean);
    /**
     * Returns text set to be displayed directly below the popover.
     * @returns {string}
     */
    get popoverCaption(): string;
    /**
     * Sets text set to be displayed directly below the popover.
     * @param {string} newCaption
     * @returns {void}
     */
    set popoverCaption(newCaption: string);
    /**
     * Returns the id of the dom element which will be moved beneath the popover.
     * @returns {string}
     */
    get popoverCaptionContainer(): string;
    /**
     * Sets the id of the dom element which will be moved beneath the popover.
     * @param {string} newCaptionContainer
     * @returns {void}
     */
    set popoverCaptionContainer(newCaptionContainer: string);
    /**
     * Returns how the popover content will render.
     * @returns {PopoverContentSettings | string | undefined}
     */
    get popoverContent(): string | undefined;
    /**
     * Sets how the popover content will render.
     * @param {PopoverContentSettings} newContentType
     * @returns {void}
     */
    set popoverContent(newContentType: PopoverContentSettings);
    /**
     * Returns if embed should override the behavior for the autoplay option in Customize for
     * a popover specifically, so that launching the popover doesn't also play the video.
     * @returns {boolean}
     */
    get popoverDisableAutoplay(): boolean;
    /**
     * Sets if embed should override the behavior for the autoplay option in Customize for
     * a popover specifically, so that launching the popover doesn't also play the video.
     * @param {boolean} shouldDisable
     * @returns {void}
     */
    set popoverDisableAutoplay(shouldDisable: boolean);
    /**
     * Returns the overlay's background color in RGB hexadecimal.
     * @returns {string}
     */
    get popoverOverlayColor(): string;
    /**
     * Sets the overlay's background color in RGB hexadecimal.
     * @param {string} newColor
     * @returns {void}
     */
    set popoverOverlayColor(newColor: string);
    /**
     * Returns the overlay's opacity. Expects a decimal value between 0 and 1.
     * @returns {number}
     */
    get popoverOverlayOpacity(): number;
    /**
     * Sets the overlay's opacity. Expects a decimal value between 0 and 1.
     * @param {number} newOpacity
     * @returns {void}
     */
    set popoverOverlayOpacity(newOpacity: number);
    /**
     * Returns if scrolling should be prevented when the popover is open.
     * @returns {boolean}
     */
    get popoverPreventScroll(): boolean;
    /**
     * Sets if scrolling should be prevented when the popover is open.
     * @param {boolean} shouldPreventScroll
     * @returns {void}
     */
    set popoverPreventScroll(shouldPreventScroll: boolean);
    /**
     * Returns if popover should immediately open as if it was clicked.
     * @returns {boolean}
     */
    get popoverShowOnLoad(): boolean;
    /**
     * Sets if popover should immediately open as if it was clicked.
     * @param {boolean} shouldShow
     * @returns {void}
     */
    set popoverShowOnLoad(shouldShow: boolean);
    /**
     * Overrides the thumbnail image that appears before the video plays.
     * Expects an absolute URL to an image.
     * @returns {string}
     */
    get poster(): string;
    /**
     * Overrides the thumbnail image that appears before the video plays.
     * Expects an absolute URL to an image.
     * @param {string} newUrl
     * @returns {void}
     */
    set poster(newUrl: string);
    /**
     * Returns the preload setting for the player.
     * @returns {string | undefined}
     * undefined is allowed as a return type because there may be situations
     * where the player and/or engine has not loaded and we don't know what
     * preload setting will be used
     */
    get preload(): string | undefined;
    /**
     * sets the preload value for the player. Note that changing this option
     * after player initialization has no impact.
     * @param {'auto'| 'metadata' | 'none'} preloadValue
     * @returns {void}
     */
    set preload(preloadValue: 'auto' | 'metadata' | 'none');
    /**
     * If set to true, the quality control will appear in the setting control.
     * @returns {boolean}
     */
    get qualityControl(): boolean;
    /**
     * enable or disable the quality control in the settings control.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set qualityControl(shouldDisplay: boolean);
    /**
     * Return the max quality allowed for the 'Auto' asset in HLS playback
     * @returns {number | undefined}
     */
    get qualityMax(): number | undefined;
    /**
     * Set the max quality to be used for "Auto" in the HLS stream.
     * @param {number} quality
     * @returns {void}
     */
    set qualityMax(quality: AllowedQualities);
    /**
     * Return the min quality allowed for the 'Auto' asset in HLS playback
     * @returns {number}
     */
    get qualityMin(): number | undefined;
    /**
     * Set the min quality to be used for "Auto" in the HLS stream.
     * @param {number} quality
     * @returns {void}
     */
    set qualityMin(quality: AllowedQualities);
    /**
     * Returns the readyState of the inner video HTML element.
     * @returns {number}
     */
    get readyState(): number;
    /**
     * Returns the current resumable status of the video.
     * @returns {'auto' | boolean}
     */
    get resumable(): boolean | string;
    /**
     * set the resumable state of the video to 'auto' | true | false.
     * note that this can be changed 'beforeplay', however changing the
     * value after play will have no effect
     * @param {'auto' | boolean} resumableState
     * @returns {void}
     */
    set resumable(resumableState: boolean | 'auto');
    /**
     * Returns a value which controls all rounded corners of the player.
     * @returns {number}
     */
    get roundedPlayer(): number;
    /**
     * Returns the value which controls all rounded corners of the player.
     * @param {number} radius
     * @returns {void}
     */
    set roundedPlayer(radius: number);
    /**
     * Returns the number of unique seconds that have been watched for the video.
     * This does not include seconds that have been skipped by seeking.
     * @returns {number}
     */
    get secondsWatched(): number;
    /**
     * Returns an array where each index represents the number of times the viewer has watched each second of the video.
     * @returns {number[]}
     */
    get secondsWatchedVector(): number[];
    /**
     * Returns whether JSON+LD seo data will be injected.
     * @returns {boolean}
     */
    get seo(): boolean;
    /**
     * Set whether JSON+LD seo data will be injected.
     * Note that changing this value after embed has no impact as JSON+LD needs
     * to be injected as soon as possible.
     * @param {boolean} val
     * @returns {void}
     */
    set seo(val: boolean);
    /**
     * If set to true, the settings control will appear in the control bar.
     * @returns {boolean}
     */
    get settingsControl(): boolean;
    /**
     * enable or disable the settings control in the control bar.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set settingsControl(shouldDisplay: boolean);
    /**
     * This option allows videos to autoplay in a muted state in contexts where normal autoplay
     * is blocked or not supported (e.g. iOS, Safari 11+, Chrome 66+).
     * allow: The video will default to normal autoplay, with silent autoplay as a fallback if needed.
     * false: The video will not autoplay silently.
     * true: The video will default to autoplaying silently.
     * @returns {boolean | 'allow'}
     */
    get silentAutoplay(): boolean | 'allow';
    /**
     * This option allows videos to autoplay in a muted state in contexts where normal autoplay
     * is blocked or not supported (e.g. iOS, Safari 11+, Chrome 66+).
     * @param {boolean | 'allow'} silentAutoplayValue
     * @returns {void}
     */
    set silentAutoplay(silentAutoplayValue: boolean | 'allow');
    get sourceLanguage(): Localization | undefined;
    /**
     * Returns the source media id for the player. If a player has different localized versions,
     * each will have a different mediaId, but the same sourceMediaId.
     * @returns {string}
     */
    get sourceMediaId(): string;
    /**
     * Returns the current state of the video.
     * @returns {PlayerState}
     */
    get state(): PlayerState;
    /**
     * Returns the stats url for the player.
     * @returns {string | null}
     */
    get statsUrl(): string | null;
    /**
     * Sets the stats url for the player.
     * @param {string} url
     * @returns {void}
     */
    set statsUrl(url: string);
    /**
     * Returns if a swatch should be shown before the player renders.
     * Internal use only.
     * @returns {boolean | undefined}
     */
    get swatch(): boolean | undefined;
    /**
     * Sets if a swatch should be shown before the player renders.
     * Internal use only.
     * @param {boolean} shouldShowSwatch
     * @returns {void}
     */
    set swatch(shouldShowSwatch: boolean);
    /**
     * If present, the background behind the video player will be transparent
     * allowing the page color to show through instead of black.
     * @returns {boolean}
     */
    get transparentLetterbox(): boolean;
    /**
     * Sets the letterbox to be transparent or not.
     * @param {boolean} shouldSetTransparentLetterbox
     * @returns {void}
     */
    set transparentLetterbox(shouldSetTransparentLetterbox: boolean);
    /**
     * Returns the unique id of this embed
     * Expected format is `wistia-mediaId-index`
     * @returns {string}
     */
    get uniqueId(): string;
    /**
     * Sets the unique id of this embed.
     * Expected format is `wistia-mediaId-index`
     * @returns {string}
     */
    set uniqueId(id: string);
    /**
     * Returns if this custom element was created from a legacy translated embed.
     * Internal use only.
     * @returns {boolean}
     */
    get useWebComponent(): boolean;
    /**
     * Set if this custom element was created from a legacy translated embed.
     * Internal use only.
     * @param {boolean} val
     * @returns {void}
     */
    set useWebComponent(val: boolean);
    /**
     * Returns the current video quality.
     * @returns {number | 'auto'}
     */
    get videoQuality(): number | 'auto';
    /**
     * Sets the video quality.
     * @param {number | 'auto'} quality
     * @returns {void}
     */
    set videoQuality(quality: number | 'auto');
    /**
     * Returns the visitor_key of the viewer of this player.
     * @returns {string | null | undefined}
     */
    get visitorKey(): string | null | undefined;
    /**
     * Returns the current volume set on the player
     * @returns {number}
     */
    get volume(): number;
    /**
     * Set the current volume set on the player
     * @param {number} level - a Number from 0 - 1
     * @returns {void}
     */
    set volume(level: number);
    /**
     * If set to true, the volume control will appear in the control bar.
     * Note that on mobile, we never show a volume control, as the device
     * volume is used.
     * @returns {boolean}
     */
    get volumeControl(): boolean;
    /**
     * enable or disable the volume control in the control bar.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */
    set volumeControl(shouldDisplay: boolean);
    /**
     * Returns if the player embed is a popover.
     * @returns {boolean}
     */
    get wistiaPopover(): boolean;
    /**
     * Sets if the player embed is a popover.
     * @param {boolean} shouldBePopover
     * @returns {void}
     */
    set wistiaPopover(shouldBePopover: boolean);
    /**
     * Adds an event listener to the player.
     * @param {string} eventName - The name of the event to listen for.
     * @param {EventListenerOrEventListenerObject} listener - The function to call when the event occurs.
     * @param {AddEventListenerOptions | boolean} options - Additional options for the event listener.
     */
    addEventListener(eventName: string, listener: EventListenerOrEventListenerObject, options?: AddEventListenerOptions | boolean): void;
    /**
     * Attempt to enter fullscreen mode.
     * @returns {Promise<void>}
     */
    cancelFullscreen(): Promise<void>;
    /**
     * Creates an overlay with the specified name and options.
     * @param {string} name - The name of the overlay.
     * @param {OverlayOptions} options - The options for the overlay.
     * @returns A promise that resolves when the overlay is created successfully, or rejects with an error if the overlay cannot be defined at this time.
     */
    createOverlay(name: string, options: OverlayOptions): Promise<void>;
    /**
     * Defines a plugin on the player.
     * @param {T extends keyof PluginConfigs} name name of the plugin to define
     * @param {PluginConfigs[T]} options object of plugin options related to the specific plugin
     * @returns {Promise<PluginInstances<T>>} returns a Promise that resolves with the defined plugin
     */
    definePlugin<T extends keyof PluginConfigs>(name: T, options: PluginConfigs[T]): Promise<PluginInstances[T]>;
    /**
     * Deletes an overlay with the specified name.
     * @param {string} name - The name of the overlay to delete.
     * @returns A promise that resolves when the overlay is successfully deleted, or rejects with an error if the overlay cannot be deleted at this time.
     */
    deleteOverlay(name: string): Promise<void>;
    /**
     *
     * @param {string} name the handle name of the control to be disabled
     * @returns {Promise<void>} Promise that resolves when operation is complete
     */
    disableControl(name: string): Promise<void>;
    /**
     *
     * @param {string} name the handle name of the control to be enabled
     * @returns {Promise<void>} Promise that resolves when operation is complete
     */
    enableControl(name: string): Promise<void>;
    enterInputContext(context: string): Promise<void>;
    exitInputContext(context: string): Promise<void>;
    /**
     * Gets initial media data for the video. This method exists purely to make
     * mocking easier in tests and mirrors the import from getInitialMediaData.ts.
     * @param {string} mediaId - The hashed ID of the media
     * @param {GetInitialMediaDataOptions} options - Options for fetching media data
     * @returns {Promise<MediaData | MediaDataServerErrorResponse>} The media data or error response
     */
    getInitialMediaData(mediaId: string, options: GetInitialMediaDataOptions): Promise<MediaData | MediaDataServerErrorResponse>;
    /**
     * Gets a plugin from the player.
     * @param {T extends keyof PluginInstances} name name of the plugin to retrieve
     * @returns {Promise<PluginInstances[T]>} returns a Promise that resolves with the request plugin
     */
    getPlugin<T extends keyof PluginInstances>(name: T): Promise<PluginInstances[T]>;
    /**
     * Returns a function that remaps the time of the video from one language to another.
     * @returns {Function} A function that remaps the time of the video from one
     * language to another with signature
     * (fromLanguage: string, toLanguage: string, fromTime: number) => number
     */
    getRemapTime(): Promise<(fromLanguage: string, toLanguage: string, fromTime: number) => number>;
    /**
     * Hides the specified overlay.
     * @param {string} name - The name of the overlay to hide.
     * @returns A promise that resolves when the overlay is hidden, or rejects with an error if the overlay cannot be cancelled at this time.
     */
    hideOverlay(name: string): Promise<void>;
    /**
     * Hides the popover if this is a popover embed.
     * @returns {Promise<void>}
     */
    hidePopover(): Promise<void>;
    /**
     * Pauses the video.
     * If this is called and the video's state is "playing,"
     * it's expected that it will change to "paused."
     * @returns {Promise<void>}
     */
    pause(): Promise<void>;
    /**
     * Plays the video.
     * If this is called, it is expected that the state will change to "playing."
     * @returns {Promise<void>}
     */
    play(): Promise<void>;
    /**
     * @param {string} name name of the controls
     * @returns {Promise<void?>}
     */
    releaseControls(name: string): Promise<void>;
    /**
     * Removes all event listeners from the player
     * @returns {void}
     */
    removeAllEventListeners(): void;
    /**
     * Removes an event listener from the player.
     * @param {string} type - The type of event to remove.
     * @param {EventListenerOrEventListenerObject} listener - The function to remove.
     * @param {EventListenerOptions | boolean} options
     * @returns {void}
     */
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: EventListenerOptions | boolean): void;
    /**
     * Replaces the media and then resolves when the new media is ready to play
     * @param {string} mediaId
     * @param {EmbedOptions} options
     * @returns {Promise<void>}
     */
    replaceWithMedia(mediaId: string, options?: ReplaceWithMediaOptions): Promise<void>;
    /**
     * @param {string} name name of the controls
     * @returns {Promise<void?>}
     */
    requestControls(name: string): Promise<void>;
    /**
     * Attempt to enter fullscreen mode.
     * @returns {Promise<void>}
     */
    requestFullscreen(): Promise<void>;
    /**
     * Shows an overlay with the specified name.
     * @param {string} name - The name of the overlay to show.
     * @returns A promise that resolves when the overlay is shown, or rejects with an error if the overlay cannot be requested at this time.
     */
    showOverlay(name: string): Promise<void>;
    /**
     * Shows the popover if this is a popover embed.
     * @returns {Promise<void>}
     */
    showPopover(): Promise<void>;
    whenApiReady(): Promise<void>;
    whenControlMounted<T extends keyof ControlInstances>(handle: T): Promise<ControlInstances[T]>;
    /**
     * Called when an observed attribute has been added, removed, updated, or replaced.
     * Also called for initial values when an element is created by the parser, or upgraded.
     * Note: only attributes listed in the observedAttributes property will receive this callback.
     * @param {string} name - The name of the attribute that changed.
     * @param {string} oldValue - The previous value of the attribute, or null if it was added for the first time.
     * @param {string} newValue - The new value of the attribute, or null if it was removed.
     * @returns {void}
     */
    protected attributeChangedCallback(name: string, oldValue: string, newValue: string): void;
    protected connectedCallback(): void;
    protected disconnectedCallback(): void;
}
/**
 * Takes a media id and returns a swatch style element once we
 * have the swatch image metadata to calculate the aspect ratio
 * @param {string} mediaId
 * @returns {Promise<HTMLStyleElement>}
 */
export declare const wistiaSwatchElement: (mediaId: string, embedHost?: string) => Promise<HTMLStyleElement>;
declare global {
    interface HTMLElementTagNameMap {
        'wistia-player': WistiaPlayer;
    }
    interface GlobalEventHandlersEventMap {
        [AFTER_REPLACE_EVENT]: WistiaPlayerEvents[typeof AFTER_REPLACE_EVENT];
        [API_READY_EVENT]: WistiaPlayerEvents[typeof API_READY_EVENT];
        [BEFORE_REPLACE_EVENT]: WistiaPlayerEvents[typeof BEFORE_REPLACE_EVENT];
        [INPUT_CONTEXT_CHANGE_EVENT]: WistiaPlayerEvents[typeof INPUT_CONTEXT_CHANGE_EVENT];
        [LOADED_MEDIA_DATA_EVENT]: WistiaPlayerEvents[typeof LOADED_MEDIA_DATA_EVENT];
        [MUTE_CHANGE_EVENT]: WistiaPlayerEvents[typeof MUTE_CHANGE_EVENT];
    }
}
//# sourceMappingURL=WistiaPlayer.d.ts.map