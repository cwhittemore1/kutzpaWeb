import { ContainerNode } from 'preact';
import { Gradient } from './gradient.ts';
import { PlaylistMethods } from '../embeds/shared/playlists/playlist-methods.ts';
import { CarouselData, CarouselHardWallData } from './carousel.ts';
import { ControlInstances } from './controls.ts';
import type { BasePluginInstance, Chapter, PluginConfigs, PluginInstances } from './plugins.ts';
import { SentryScope } from './sentry.ts';
import { EventShepherd } from '../utilities/eventShepherd.ts';
export type AllowedQualities = 224 | 360 | 540 | 720 | 1080 | 2160;
export type heightOrWidthOptions = {
    constrain?: boolean;
    fullscreen?: boolean;
    trigger?: boolean;
};
export type AnnotationOverlayOptions = {
    duration?: number;
    position?: 'left' | 'right';
    text: string;
    theme?: 'dark' | 'light';
    time?: number;
    transition?: 'fade' | 'pop';
    transitionTime?: number;
    type: 'annotation';
    url?: string;
};
export type EventListenerEntry = {
    listener: EventListenerOrEventListenerObject;
    options?: AddEventListenerOptions | boolean;
};
export type EventListenerMap = Record<string, EventListenerEntry[]>;
export type ModalOverlayOptions = {
    mount: (rootElem?: ContainerNode) => Promise<void> | void;
    transition?: 'fade' | 'slide';
    transitionDirection?: 'ltor';
    transitionTime?: number;
    type: 'modal';
};
export type OverlayOptions = AnnotationOverlayOptions | ModalOverlayOptions;
export type Language = {
    code: string;
    text: string;
};
export interface ControlBarDialog {
    close: () => Promise<void>;
    hasOpened: () => boolean;
    isOpen: () => boolean;
    open: () => Promise<void>;
    resize: () => void;
}
export type MediaDataServerResponse = {
    error?: boolean | string;
    iframe?: boolean | string;
    media?: MediaData;
    options?: EmbedOptions;
};
export type MediaDataServerErrorResponse = Pick<MediaDataServerResponse, 'error' | 'iframe'>;
export interface Media {
    hashedId: string;
    options: {
        channel: string;
        channelPreferences: {
            lastVideoPlayed: string;
            playbackRate: number;
        };
        hideAudioContextMenu: boolean;
        playerColor: string;
        plugin: {
            watchNext: {
                on: boolean;
                playerColor: string;
            };
        };
        podcastingIsEnabled: boolean;
        resumable: boolean;
        seo: boolean;
        shouldShowDescription: boolean;
        silentAutoPlay: boolean;
        transition: string;
        transitionTime: string;
        turnstileStorageKey: [string];
        videoContainerId: string;
        wmod: string;
    };
}
export type TimeMapping = [number, number];
export interface Localization {
    alpha3Bibliographic: string;
    alpha3Terminologic: string;
    duration: number;
    hashedId: string;
    ietfLanguageTag: string;
    iso6392LanguageCode: string;
    name: string;
    nativeName: string;
    sourceLanguage?: boolean;
    timeMappings?: TimeMapping[];
}
export interface MediaData {
    accountId?: number;
    accountKey?: string;
    analyticsHost?: string;
    aspectRatio?: number | null;
    assets?: unknown[];
    branding?: boolean;
    carouselHardWall?: boolean;
    channelArtUrl?: string | null;
    channelHashedId?: string;
    channelPodcastLinks?: string;
    channelTitle?: string;
    createdAt?: number;
    distilleryUrl?: string;
    duration?: number;
    embedOptions?: EmbedOptions;
    enableCustomerLogo?: boolean;
    error?: never;
    firstEmbedForAccount?: boolean;
    firstShareForAccount?: boolean;
    hashedId?: string;
    ietfLanguageTag?: string;
    iframe?: never;
    integrations?: Record<string, unknown>;
    liveStreamEventDetails?: {
        id: number;
        m3u8RenditionProgramTime?: Date;
        manifestUrl?: string;
        scheduledFor?: Date;
        startedAt?: Date;
    };
    localizations?: Localization[];
    mediaId?: number;
    mediaKey?: string;
    mediaType?: 'ab-test' | 'Audio' | 'LiveStream' | 'Video';
    name?: string;
    originalFileStillAsset?: string;
    originalIsEligibleForDirectPlayback?: boolean;
    preloadPreference?: string | null;
    progress?: number;
    projectId?: number | null;
    protected?: boolean;
    seoDescription?: string;
    showAbout?: boolean;
    sourceHashedId?: string;
    sourceMediaId?: number;
    sourceMediaKey?: string;
    stats?: Record<string, unknown>;
    status?: number;
    trackingTransmitInterval?: number;
    type?: 'ab-test' | 'Audio' | 'LiveStream' | 'Video';
}
export interface WistiaContainerHTMLElement extends HTMLElement {
    api?: PublicApi | 'removed' | null | undefined;
    deprecatedApiDoNotUse?: PublicApi | 'removed' | null | undefined;
    wistiaApi?: PublicApi | 'removed' | null | undefined;
}
export interface Attributes {
    aspect?: number;
    aspectRatio?: number | null;
    autoplay?: boolean;
    bigPlayButton?: boolean;
    bigPlayButtonBorderRadius?: number;
    controlBarBorderRadius?: number;
    controlsVisibleOnLoad?: boolean;
    copyLinkAndThumbnail?: boolean;
    currentTime?: number;
    doNotTrack?: boolean;
    email?: string;
    endVideoBehavior?: 'default' | 'loop' | 'reset';
    floatingControlBar?: boolean;
    fullscreenControl?: boolean;
    muted?: boolean;
    playbackRate?: number;
    playbackRateControl?: boolean;
    playBarControl?: boolean;
    playerBorderRadius?: number;
    playerColor?: string;
    playlistLinks?: string;
    playlistLoop?: boolean;
    playPauseControl?: boolean;
    playPauseNotifier?: boolean;
    popoverContent?: boolean;
    poster?: string;
    preload?: 'auto' | 'metadata' | 'none';
    qualityControl?: boolean;
    qualityMax?: AllowedQualities;
    qualityMin?: AllowedQualities;
    resumable?: boolean | 'auto';
    roundedPlayer?: number;
    seo?: boolean;
    settingsControl?: boolean;
    silentAutoplay?: boolean | 'allow';
    statsUrl?: string;
    transparentLetterbox?: boolean;
    videoQuality?: number | 'auto';
    volume?: number;
    volumeControl?: boolean;
}
export interface EmbedOptions extends Attributes {
    _inIframe?: boolean;
    autoPlay?: boolean;
    bpbTime?: boolean | string;
    branding?: boolean;
    channelId?: number | null;
    channelPassword?: string;
    chapterList?: Chapter[] | null;
    chaptersOn?: boolean | 'false' | 'true';
    container?: HTMLElement | string;
    controlBarDistance?: number;
    controlsVisibleOnLoad?: boolean;
    customerLogoImageUrl?: string;
    customerLogoPlacement?: CustomerLogoPlacementOption;
    customerLogoSizePercent?: number;
    customerLogoTargetUrl?: string;
    embedHost?: string | null;
    episodeId?: number | null;
    floatingControlBar?: boolean;
    floatingControlBarDistance?: number;
    fullscreenButton?: boolean;
    keyMoments?: boolean;
    language?: string;
    mux?: boolean;
    noMixBlendMode?: boolean;
    pageTitle?: string;
    playButton?: boolean;
    playerColor?: string;
    playerColorGradient?: Gradient & {
        on: boolean;
    };
    playerLanguage?: Language | string;
    playsinline?: boolean;
    plugin?: PluginConfigs;
    private?: {
        show_comments?: boolean;
    };
    roundedPlayer?: number;
    showCustomerLogo?: boolean | 'false' | 'true';
    stillUrl?: string;
    thumbnailAltText?: string;
    time?: number;
    videoFoam?: boolean;
    volumeControl?: boolean;
    vulcan?: boolean;
}
export type CustomerLogoPlacementOption = 'bottom-left' | 'bottom-right' | 'top-left' | 'top-right';
export declare const PlayerTransitionOptions: {
    crossfade: string;
    fade: string;
    slide: string;
    slideleft: string;
    slideright: string;
};
export type PlayerTransitionType = keyof typeof PlayerTransitionOptions;
export interface ReplaceWithMediaOptions extends EmbedOptions {
    transition?: PlayerTransitionType;
}
export interface Impl {
    _attrs: Attributes;
    _oldEngine: object | null | undefined;
    addLoopBehavior: () => void;
    aspect: () => number;
    audioDescriptionControlEnabled: (shouldDisplay?: boolean) => Impl;
    bigPlayButtonEnabled: (shouldDisplay?: boolean) => Impl;
    cancelFullscreen: () => Promise<void>;
    cancelOverlay: (name: string) => void;
    controls: ControlInstances;
    defineOverlay: (name: string, overlay: object) => void;
    duration: () => number;
    engine: object | null | undefined;
    enterInputContext: (context: string) => void;
    eventKey: () => string | undefined;
    exitInputContext: (context: string) => void;
    fullscreenControlEnabled: (shouldDisplay?: boolean) => Impl;
    getControl: (name: string) => object | undefined;
    getInputContext: () => string | undefined;
    getReadyState: () => number | undefined;
    getStandardBuffered: () => TimeRanges | undefined;
    getVideoQuality: () => number | 'auto';
    height: (val?: number, options?: heightOrWidthOptions) => number | undefined;
    inFullscreen: () => boolean;
    isInstantHls: () => boolean;
    isMuted: () => boolean;
    mute: () => Promise<void>;
    pause: () => Promise<void>;
    percentWatched: () => number;
    play: () => Promise<void>;
    playbackRate: (rate?: number) => number;
    playbackRateControlEnabled: (shouldDisplay?: boolean) => boolean | undefined;
    playbarControlEnabled: (shouldDisplay?: boolean) => Impl;
    playerColor: (newColor?: string) => Impl | string;
    playerColorGradient: (gradient: Gradient) => Impl;
    playPauseControlEnabled: (shouldDisplay?: boolean) => Impl;
    playPauseNotifierEnabled: (shouldDisplay?: boolean) => Impl;
    plugin: PluginInstances;
    preloadValue: () => string | undefined;
    qualityControlEnabled: (shouldDisplay?: boolean) => boolean | undefined;
    qualityMax: (quality: AllowedQualities) => void;
    qualityMin: (quality: AllowedQualities) => void;
    releaseControls: (name: string) => Promise<void>;
    removeLoopBehavior: () => void;
    renderUI: () => void;
    requestControls: (name: string) => Promise<void>;
    requestFullscreen: () => Promise<void>;
    requestOverlay: (name: string) => void;
    secondsWatched: () => number;
    secondsWatchedVector: () => number[];
    setBigPlayButtonBorderRadius: (radius?: number) => number | undefined;
    setControlBarBorderRadius: (radius?: number) => number | undefined;
    setControlEnabled: (handle: string, enabled: boolean) => void;
    setPlayerBorderRadius: (radius?: number) => number | undefined;
    setResumable: (val: boolean | string) => void;
    setRoundedPlayer: (radius?: number) => number | undefined;
    settingsControlEnabled: (shouldDisplay?: boolean) => Impl;
    setVideoQuality: (qual: number | 'auto') => void;
    sourceHashedId: () => string | undefined;
    state: () => PlayerState;
    time: (newTime?: number, options?: {
        lazy: boolean;
    }) => Promise<void> | number;
    undefineOverlay: (name: string) => void;
    unmute: () => Promise<void>;
    updateHardWallData?: (data: CarouselHardWallData) => void;
    videoHeight: (val?: number, options?: Omit<heightOrWidthOptions, 'trigger'>) => number | undefined;
    videoWidth: (val?: number, options?: Omit<heightOrWidthOptions, 'trigger'>) => number | undefined;
    volume: (vol?: number) => Impl;
    volumeControlEnabled: (shouldDisplay?: boolean) => Impl;
    width: (val?: number, options?: heightOrWidthOptions) => number | undefined;
}
export interface PublicApi {
    _attrs: Attributes;
    _bindings?: Record<string, []> | null | undefined;
    _impl: Impl | undefined;
    _mediaData: MediaData | undefined;
    _opts: EmbedOptions | undefined;
    addPlugin: <T extends keyof PluginConfigs>(name: T, options: PluginConfigs[T]) => Promise<PluginInstances[T]>;
    addToPlaylist: (hashedId: string, options: object, position: object) => Record<string, object | string>[];
    aspect: () => number;
    bind: (eventName: string, param1: number | ((args: unknown) => void), param2?: number | (() => void), param3?: () => void) => () => void;
    cancelFullscreen: () => void;
    chrome: HTMLElement | undefined;
    container: WistiaContainerHTMLElement | undefined;
    email: (newEmail?: string) => string | null;
    embedded: (callback?: () => void) => PublicApi | boolean;
    embedNext: () => void;
    embedOptions: () => EmbedOptions | undefined;
    embedPrevious: () => void;
    getRemapTime: () => Promise<(fromLanguage: string, toLanguage: string, time: number) => number>;
    hasData: (callback?: () => void) => PublicApi | boolean;
    hashedId: () => string | undefined;
    height: (newHeight: number, opts?: {
        constrain?: boolean;
    }) => PublicApi | number;
    iframe: HTMLElement | undefined;
    language: (language?: string) => Localization | undefined;
    languages: () => Localization[];
    mute: () => void;
    mux: Mux | undefined;
    nextVideo: () => Media | undefined;
    on: (eventName: string, callback: () => void) => void;
    pause: () => void;
    percentWatched: () => number;
    play: () => void;
    playbackRate: () => number | undefined;
    playerColor: (newColor?: string) => string;
    playerLanguage: () => Language | string;
    plugin: <T extends keyof PluginInstances>(name: T) => Promise<PluginInstances[T]>;
    popover: Popover | undefined;
    preload: (val?: string) => string;
    previousVideo: () => Media | undefined;
    remove: (opts?: object) => void;
    replaceWith: (hashedId: string, options: ReplaceWithMediaOptions) => void;
    requestFullscreen: () => void;
    setEmbedHost: (embedHost: string) => void;
    sourceHashedId: () => string | undefined;
    state: () => PlayerState;
    unbind: (eventName: string, param1: number | ((...args: unknown[]) => void), param2?: number | ((...args: unknown[]) => void), param3?: () => void) => () => void;
    up: StopGoType;
    videoQuality: (qual?: number | string) => Impl | number | string;
    whenControlMounted: (controlName: keyof ControlInstances) => Promise<ControlInstances>;
    width: (newWidth: number | null, options?: object) => number;
    ready(callback?: () => void): PublicApi;
    ready(): boolean;
    time(): number;
    time(newTime: number, options?: {
        lazy: boolean;
    }): PublicApi;
}
export interface LoggerType {
    getPrefixedFunctions: (prefix: string) => object;
    info: (...args: string[]) => void;
}
export type StopGoType = {
    (x?: boolean | (() => void)): void;
    synchronize: (y: (z: () => void) => void) => void;
    new (): StopGoType;
};
export interface PublicApiOptions {
    container: HTMLElement | string;
    mediaData?: MediaData | MediaDataServerErrorResponse;
}
export interface FreshUrl {
    originalUrl: string;
}
export interface Mux {
    destroy: () => void;
    init: (video: PublicApi, options?: {
        embedType?: string;
    }) => void;
}
export interface Popover {
    height: (newHeight?: number, options?: {
        constrain?: boolean;
    }) => number;
    hide: () => void;
    isVisible: () => boolean;
    show: () => void;
    width: (newWidth?: number, options?: {
        constrain?: boolean;
    }) => number;
}
export interface DeprecatedEmbedListener extends Array<PublicApi> {
    each: (callback: (api: PublicApi) => void) => void;
    on: (eventName: string, callback: () => void) => () => void;
}
export type PlayerState = 'beforeplay' | 'ended' | 'paused' | 'playing';
export type Players = 'carouselHardWall' | 'external' | 'html5' | 'notplayable' | 'passwordprotected' | 'simplehtml5' | 'vulcan-v2';
export type PopoverAnimation = 'fade' | 'none' | 'slide';
export type PopoverContentSettings = 'html' | 'link' | 'poster' | 'thumbnail';
export type WistiaLocalStorage = Record<string, Record<string, number | object | string> | undefined>;
export type PlayerLifecycleCallback = (player: PublicApi) => void;
export interface JudyContext {
    detect: object;
    inIframe: boolean;
    location: object;
    logger: LoggerType;
    pageUrl: string;
    silenceGlobalWarnings?: boolean;
    userAgent: string;
}
export interface WQConfigEntry {
    id: string;
    onEmbedded?: PlayerLifecycleCallback;
    onFind?: PlayerLifecycleCallback;
    onHasData?: PlayerLifecycleCallback;
    onReady?: PlayerLifecycleCallback;
    options?: EmbedOptions;
}
export interface WQRevokeEntry {
    revoke: WQConfigEntry;
}
export type WQCallback = (W: WistiaGlobal) => void;
export type WQEntry = WQCallback | WQConfigEntry | WQRevokeEntry;
export interface WistiaGlobal {
    _destructors: Record<string, () => void> | null;
    _initializers: {
        initVisitorKey?: () => void;
    } | null;
    _inlineMediaData?: Record<string, MediaData>;
    _isListeningForGlobalErrors?: boolean;
    _isListeningForGlobalUnhandledRejections?: boolean;
    _liveStreamPollingPromises: Record<string, Promise<MediaData>>;
    _mediaDataPromises: Record<string, Promise<MediaData | Pick<MediaDataServerResponse, 'error' | 'iframe'>>>;
    _remoteData: Map<string, CarouselData | MediaData>;
    _sentryScope: SentryScope;
    api: (matcher?: number | string) => PublicApi | null;
    defineControl: (control: unknown) => void;
    EventShepherdManager: Record<string, EventShepherd | undefined>;
    flushInitQueue?: () => void;
    isSentryInitialized?: boolean;
    Metrics: {
        videoCount: (video: Impl, key: string, val?: number, extraData?: Record<string, unknown>) => void;
    };
    mixin: ((klass: object, obj: object) => void) | null;
    playlistMethods?: Map<string, PlaylistMethods>;
    plugin: (name: string, definition: (video: PublicApi, options: Record<string, unknown>) => unknown) => void;
    Plugin: {
        Base: new (video: PublicApi, options: Record<string, unknown>) => BasePluginInstance<Record<string, unknown>>;
    };
    PublicApi: ((hashedId: number | string, options: EmbedOptions | PublicApiOptions | undefined) => void) | null;
    uncacheCaptions?: (hashedId: string) => void;
    uncacheMedia: (hashedId: string) => void;
    VisitorKey: {
        generate: () => string;
    } | null;
    visitorKey: {
        value: () => string;
    } | null;
    wistia: number | undefined;
}
export type WindowWistia = WistiaGlobal | null | undefined;
export type WindowWQ = WQEntry[] | undefined;
//# sourceMappingURL=player-api-types.d.ts.map