/******/ var __webpack_modules__ = ({

/***/ 159:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rb: () => (/* binding */ findScriptInDomBySrc)
/* harmony export */ });
/* unused harmony exports removeScriptsBySrc, runScript, runScripts, scriptInputsToHash */
/* harmony import */ var utilities_wlog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6637);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(731);
/* harmony import */ var utilities_runScript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1248);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var findScriptInDomBySrc = function findScriptInDomBySrc(targetSrc) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var scriptTags = document.getElementsByTagName('script');
  for (var i = 0; i < scriptTags.length; i++) {
    var s = scriptTags[i];
    var src = s.getAttribute('src') || '';
    if (options.ignoreQueryParams) {
      var matches = src.split('?');
      var urlWithoutParams = matches[0];
      src = urlWithoutParams;
    }
    if (!options.scriptRegex && options.ignoreProtocol) {
      src = src.replace(/^https?:/, '');
      targetSrc = targetSrc.replace(/^https?:/, '');
    }
    if (options.scriptRegex && options.scriptRegex.test(src)) {
      return s;
    }
    if (options.testStartsWith && src.indexOf(targetSrc) === 0) {
      return s;
    }
    if (src === targetSrc) {
      return s;
    }
  }
  return null;
};
var removeScriptsBySrc = function removeScriptsBySrc(targetSrc) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var s;
  var _loop = function _loop() {
    if (s) {
      s.onload = s.onreadystatechange = s.onerror = null;
      if (s.parentNode && typeof s.parentNode.removeChild) {
        try {
          s.parentNode.removeChild(s);
        } catch (e) {
          setTimeout(function () {
            throw e;
          }, 0);
        }
      }
    }
  };
  while (s = findScriptInDomBySrc(targetSrc, options)) {
    _loop();
  }
};

// fire and forget.
// run a script and immediately remove it from the DOM.
var runScript = function runScript(src) {
  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8000;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (timeout == null) {
    timeout = 8000;
  }
  if (options == null) {
    options = {};
  }
  var s;
  var alreadyExists;
  return new Promise(function (resolve) {
    if (options.once === true && (s = findScriptInDomBySrc(src))) {
      alreadyExists = true;
    }
    if (options.once && alreadyExists) {
      if (!s.readyState || /loaded|complete/.test(s.readyState)) {
        setTimeout(function () {
          resolve();
        }, 1);
      }
    } else {
      runScriptWithPromise(src, timeout).then(resolve).catch(function (msg) {
        resolve(msg);
        setTimeout(function () {
          console.error(msg);
        }, 1);
      });
    }
  });
};
var runScripts = function runScripts() {
  // support either an array of scripts or a single script as a string
  var scripts;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args[0] instanceof Array) {
    scripts = args[0];
  } else {
    scripts = args;
  }
  scripts = scriptInputsToHash(scripts);
  var asyncScripts = [];
  var syncScripts = [];
  var scriptPromises = [];
  scripts.forEach(function (s) {
    var script = _objectSpread({}, s);
    var p = new Promise(function (resolve) {
      script.resolve = resolve;
    });
    script.promise = p;
    scriptPromises.push(script.promise);
    if (s.async) {
      asyncScripts.push(script);
    } else {
      syncScripts.push(script);
    }
  });
  syncScripts.reduce(function (prev, script) {
    if (script.fn) {
      try {
        script.fn();
      } catch (e) {
        wlog.error(e);
      } finally {
        script.resolve();
      }
    } else if (script.src) {
      runScript(script.src, null, script).then(script.resolve);
    }
    return prev.then(script.promise);
  }, Promise.resolve());
  setTimeout(function () {
    asyncScripts.forEach(function (script) {
      if (script.fn) {
        try {
          script.fn();
        } catch (e) {
          wlog.error(e);
        } finally {
          script.resolve();
        }
      } else if (script.src) {
        runScript(script.src, null, script).then(script.resolve);
      }
    });
  }, 1);
  return Promise.all(scriptPromises);
};
var scriptInputsToHash = function scriptInputsToHash(scripts) {
  var result = [];
  for (var i = 0; i < scripts.length; i++) {
    var script = scripts[i];
    if (typeof script === 'string') {
      result.push({
        src: script,
        async: false
      });
    } else if (isObject(script)) {
      result.push(script);
    } else {
      result.push({
        fn: script,
        async: false
      });
    }
  }
  return result;
};

/***/ }),

/***/ 267:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   O: () => (/* binding */ hasPerformanceMeasureSupport)
/* harmony export */ });
var hasPerformanceMeasureSupport = function hasPerformanceMeasureSupport() {
  var _window = window,
    performance = _window.performance;
  // eslint-disable-next-line @typescript-eslint/unbound-method
  return Boolean(performance) && Boolean(performance.measure);
};

/***/ }),

/***/ 438:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $F: () => (/* binding */ choosePlayer),
/* harmony export */   gC: () => (/* binding */ buildContext)
/* harmony export */ });
/* unused harmony exports PLUGIN_CONFIGS, bestPlayer, bestUsableEngine, bestUsableEngineClass, canPlayInline, canUsePlayer, determinePlayerPreferenceFromInput, doesBrowserSupportHlsTools, enginesToLoad, getDefaultContext, hasAssetsForPlayer, hasEnoughReadyMp4Assets, hasSupportedHlsAssets, isBrowserInNativeAndroid, isBrowserOldChrome, isHlsEnabled, isMobile, isNotPlayable, isPasswordProtected, isSupportedPlayer, isValidPlayer, logWarnings, playerPlugins, report, shouldServeHls, supportedPlayers, usablePlayers, urlHasBeenTamperedWith, xhrHasBeenTamperedWith */
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_detect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7231);
/* harmony import */ var utilities_metrics_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(655);
/* harmony import */ var utilities_legacyLocalstorage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3695);
/* harmony import */ var utilities_root_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8176);
/* harmony import */ var utilities_wlog_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6637);
/* harmony import */ var _assets_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7209);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5509);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }








var wlog = utilities_wlog_js__WEBPACK_IMPORTED_MODULE_5__/* .wlog */ .ct.getPrefixedFunctions('judy');
var AUTO = 'auto';
var CAROUSEL_HARD_WALL = 'carouselHardWall';
var EXTERNAL = 'external';
var HLS_VIDEO = 'hlsVideo';
var HTML5 = 'html5';
var MANUAL_QUALITY_VIDEO = 'manualQualityVideo';
var NATIVE_HLS_VIDEO = 'nativeHlsVideo';
var NOT_PLAYABLE = 'notplayable';
var PASSWORD_PROTECTED = 'passwordprotected';
var SIMPLE_HTML5 = 'simplehtml5';
var VULCAN_V2 = 'vulcan-v2';
var SPHERICAL_VIDEO = 'sphericalVideo';
var PLAYERS = [VULCAN_V2, HTML5, SIMPLE_HTML5, EXTERNAL, NOT_PLAYABLE, PASSWORD_PROTECTED];
var PLUGIN_CONFIGS = {
  notPlayableVideo: {
    on: true,
    initBeforeHasData: true,
    async: false,
    loadWeight: -1
  },
  vulcanV2Player: {
    on: true,
    initBeforeHasData: false,
    async: false,
    loadWeight: -1
  },
  hlsVideo: {
    on: true,
    initBeforeHasData: false,
    async: false,
    loadWeight: 0
  },
  nativeHlsVideo: {
    on: true,
    initBeforeHasData: false,
    async: false,
    loadWeight: 0
  },
  passwordProtectedVideo: {
    on: true,
    initBeforeHasData: true,
    async: false,
    loadWeight: -1
  },
  externalPlayer: {
    on: true,
    initBeforeHasData: false,
    async: false,
    loadWeight: -1
  },
  html5Player: {
    on: true,
    initBeforeHasData: false,
    async: false,
    loadWeight: -1
  },
  playlist: {
    on: true,
    initBeforeHasData: false,
    async: false,
    loadWeight: -1
  }
};
var bestPlayer = function bestPlayer(context, mediaData, embedOptions) {
  var detect = context.detect,
    logger = context.logger;
  var isSpherical = isSphericalVideo({
    mediaData: mediaData,
    options: embedOptions
  }, detect);
  if (detect.oldandroid) {
    logger.info('external on old android');
    return EXTERNAL;
  }
  if (canUsePlayer(context, VULCAN_V2, mediaData)) {
    logger.info('default, ret', VULCAN_V2);
    return VULCAN_V2;
  }
  if (mediaData.mediaType === 'Audio' || mediaData.mediaType === 'LiveStream') {
    // audio and lives are only supported with vulcan_v2
    return VULCAN_V2;
  }
  if (canUsePlayer(context, HTML5, mediaData)) {
    logger.info('default, ret', HTML5);
    return HTML5;
  }
  logger.info('nothing left, use', EXTERNAL);
  // Everything supports external, but nobody likes it. It's just an image
  // and a link to an mp4 file.
  return EXTERNAL;
};
var bestUsableEngine = function bestUsableEngine(context, mediaData) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var detect = context.detect,
    logger = context.logger;
  logger.info('bestUsableEngineClass');
  var allowHls = shouldServeHls(context, mediaData, options);
  var isSpherical = isSphericalVideo({
    mediaData: mediaData,
    options: options
  }, detect);
  if (options.engine) {
    return options.engine;
  }
  if (isSpherical) {
    logger.info(SPHERICAL_VIDEO);
    return 'engines/spherical_video.js';
  }
  if (mediaData.mediaType === 'Audio') {
    return 'engines/simple_audio.js';
  }
  if (allowHls && detect.nativeHls) {
    logger.info(NATIVE_HLS_VIDEO);
    return 'engines/native_hls_video.js';
  }
  if (allowHls) {
    logger.info(HLS_VIDEO);
    return 'engines/hls_video.js';
  }
  logger.info(MANUAL_QUALITY_VIDEO);
  return 'engines/manual_quality_video.js';
};

// Given a media data blob and options--and assuming all engine scripts have
// been loaded--return the engine class that we should initialize.
var bestUsableEngineClass = function bestUsableEngineClass(context, mediaData) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var detect = context.detect,
    logger = context.logger;
  logger.info('bestUsableEngineClass');
  var allowHls = shouldServeHls(context, mediaData, options);
  var engines = Wistia.engines || {};
  if (mediaData.mediaType === 'Audio') {
    return engines.SimpleAudio;
  }
  if (allowHls && detect.nativeHls && engines.NativeHlsVideo) {
    logger.info(NATIVE_HLS_VIDEO);
    return engines.NativeHlsVideo;
  }
  if (allowHls && engines.HlsVideo) {
    logger.info(HLS_VIDEO);
    return engines.HlsVideo;
  }
  logger.info(MANUAL_QUALITY_VIDEO);
  return engines.ManualQualityVideo;
};
var buildContext = function buildContext() {
  var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var pageUrl = contextUrl(overrides);
  return _objectSpread(_objectSpread(_objectSpread({}, getDefaultContext()), overrides), {}, {
    pageUrl: pageUrl
  });
};
var canPlayInline = function canPlayInline(context) {
  var detect = context.detect;
  return detect.android || detect.ios.version >= 10;
};
var canUsePlayer = function canUsePlayer(context, player, mediaData) {
  return isSupportedPlayer(context, player) && hasAssetsForPlayer(context, player, mediaData);
};
var choosePlayer = function choosePlayer(context, mediaData, embedOptions) {
  var detect = context.detect;
  var logger = context.logger;
  var playerForce = embedOptions.playerForce;
  logger.info('choosePlayer input', mediaData.hashedId);

  // This can be falsey if there is no specific player preference. Users may
  // also pass in "auto" to be explicit, which means there should be no
  // preference.
  var playerPreference = determinePlayerPreferenceFromInput(context, mediaData, embedOptions);

  // Loudly error but don't die if given invalid input.
  if (playerForce && !isValidPlayer(context, playerForce)) {
    logger.error("Invalid playerForce option: \"".concat(playerForce, "\", ignoring"));
    playerForce = null;
  }
  if (playerPreference && playerPreference !== AUTO && !isValidPlayer(context, playerPreference)) {
    logger.error("Invalid playerPreference option: \"".concat(playerPreference, "\", ignoring"));
    playerPreference = AUTO;
  }
  logger.info('playerPreference is', playerPreference);
  if (playerForce) {
    // This is really only used when testing.
    logger.info('"playerForce" used, return', playerForce);
    return playerForce;
  }
  // A carousel can contain a password-protected media which should be unlocked
  // when the carousel is unlocked, so this check should always
  // come before the check to see if a media is password-protected
  if (mediaData.carouselHardWall) {
    logger.info('return', CAROUSEL_HARD_WALL);
    return CAROUSEL_HARD_WALL;
  }
  if (isPasswordProtected(context, embedOptions)) {
    // the video is marked as being password protected. it's expected that the
    // password protected player, upon a successful password entry, changes an
    // option and is replaced such that isPasswordProtected() returns false.
    logger.info('return', PASSWORD_PROTECTED);
    return PASSWORD_PROTECTED;
  }
  if (isNotPlayable(context, mediaData, embedOptions)) {
    // 1. We can generate embed codes before a video can actually be played. If we
    //    can't field any kind of player, we want to embed NOT_PLAYABLE instead,
    //    which shows upload and encoding progress, then re-embeds as a "real"
    //    player once it reaches 100%.
    // 2. DRM-lite customers must include their `authorization` credentials as embedOptions. If we know
    //    a media is "protected", but there are no authorization credentials for the embed, we can build
    //    directly into the NotPlayablePlayer state.
    // 3. DRM-lite customers that either do not have HLS enabled or cannot use HLS
    //    will reach a NOT_PLAYABLE state.
    logger.info('return', NOT_PLAYABLE);
    return NOT_PLAYABLE;
  }

  // DRM-lite medias are marked as "protected". And those medias must be played back using our
  // VULCAN_V2 player.
  if (mediaData.protected) {
    return VULCAN_V2;
  }
  if (playerPreference !== AUTO && canUsePlayer(context, playerPreference, mediaData)) {
    var isSpherical = isSphericalVideo({
      mediaData: mediaData,
      options: embedOptions
    }, detect);
    if (playerPreference !== VULCAN_V2 && isSpherical) {
      logger.info("this player doesn't support spherical, return", VULCAN_V2);
      return VULCAN_V2;
    }
    // Hooray! The customer has chosen a preference that we can actually use.
    // Let's use it.
    logger.info('"playerPreference" used, return', playerPreference);
    return playerPreference;
  }
  // Okay, we are not being compelled to use any particular player. Choose
  // the best one that we can support.
  logger.info('choosing player with no preference');
  return bestPlayer(context, mediaData, embedOptions);
};

// return the url to use for building up the Judy context.
var contextUrl = function contextUrl() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (opts.pageUrl) {
    return opts.pageUrl;
  }
  if (Object(window.FreshUrl).originalUrl) {
    return window.FreshUrl.originalUrl;
  }
  if (window.top === window.self) {
    return location.href || '';
  }
  return document.referrer || '';
};
var determinePlayerPreferenceFromInput = function determinePlayerPreferenceFromInput(context, mediaData, embedOptions) {
  // platformPreference is a legacy option. It used to have difference
  // semantics as playerPreference, but let's treat it the same now.
  var playerPreference = embedOptions.playerPreference || embedOptions.platformPreference;
  if (playerPreference && playerPreference !== AUTO) {
    if (playerPreference === HTML5) {
      if (isMobile(context)) {
        return HTML5;
      }
      return VULCAN_V2;
    }
    if (playerPreference === SIMPLE_HTML5) {
      // Because "html5" is an overloaded term on desktop, we add this other one
      // so we can more easily test the simple/mobile html5 player.
      return HTML5;
    }
    return playerPreference;
  }
  // no preference was specified
  return AUTO;
};

// the browser can support hlsjs or native HLS
var doesBrowserSupportHlsTools = function doesBrowserSupportHlsTools(detect) {
  var hasPromise = Boolean(window.Promise);
  return (detect.mediaSource || detect.nativeHls) && hasPromise;
};

// Given a media data blob and options, return _all_ engines and sub-engines
// that will need to be loaded. This is how we determine which scripts to load.
var enginesToLoad = function enginesToLoad(context, mediaData) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var detect = context.detect,
    logger = context.logger;
  var engineNames = [];
  logger.info('enginesToLoad');
  var allowHls = shouldServeHls(context, mediaData, options);
  if (allowHls && detect.nativeHls) {
    logger.info(NATIVE_HLS_VIDEO);
    engineNames.push(NATIVE_HLS_VIDEO);
  } else if (allowHls) {
    logger.info(HLS_VIDEO);
    engineNames.push(HLS_VIDEO);
  } else {
    logger.info(MANUAL_QUALITY_VIDEO);
    engineNames.push(MANUAL_QUALITY_VIDEO);
  }
  var isSpherical = isSphericalVideo({
    mediaData: mediaData,
    options: options
  }, detect);
  if (isSpherical) {
    engineNames.push(SPHERICAL_VIDEO);
    logger.info(SPHERICAL_VIDEO);
  }

  // Make sure engine names are unique in this array.
  var tmpHash = {};
  engineNames.forEach(function (engineName) {
    tmpHash[engineName] = true;
  });
  var result = [];
  for (var engineName in tmpHash) {
    result.push(engineName);
  }
  return result;
};
var cachedDefaultContext;
var getDefaultContext = function getDefaultContext() {
  if (cachedDefaultContext) {
    return cachedDefaultContext;
  }
  cachedDefaultContext = {
    detect: (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)((0,utilities_detect_js__WEBPACK_IMPORTED_MODULE_1__/* .cachedDetect */ .o1)()),
    inIframe: top !== self,
    location: window.location,
    logger: wlog,
    pageUrl: location.href,
    silenceGlobalWarnings: utilities_root_js__WEBPACK_IMPORTED_MODULE_4__/* .root */ .z.wistiaSilenceGlobalWarnings,
    userAgent: navigator.userAgent
  };
  return cachedDefaultContext;
};
var getPluginConfig = function getPluginConfig(context, pluginName) {
  var result = {};
  result[pluginName] = PLUGIN_CONFIGS[pluginName];
  return result;
};
var canUseInstantHls = function canUseInstantHls(context, mediaData) {
  var embedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return embedOptions.instantHls !== false && mediaData.instantHlsAssetsReady && shouldServeHls(context, mediaData, embedOptions);
};
var canUseOriginalFilePlayback = function canUseOriginalFilePlayback(context, mediaData) {
  var embedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return mediaData.originalIsEligibleForDirectPlayback && shouldServeHls(context, mediaData, embedOptions);
};
var hasAssetsForPlayer = function hasAssetsForPlayer(context, player, mediaData) {
  if (!isValidPlayer(context, player)) {
    return false;
  }
  if (player === NOT_PLAYABLE || player === PASSWORD_PROTECTED || player === CAROUSEL_HARD_WALL) {
    // No special asset requirements for these.
    return true;
  }
  var assets = mediaData.assets;
  if (player === VULCAN_V2) {
    return canUseInstantHls(context, mediaData) || canUseOriginalFilePlayback(context, mediaData) || hasReadyVideoAssets(assets) || hasReadyAudioAssets(assets);
  }
  if (player === HTML5) {
    return (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicMp4s */ .Fi)(assets).length > 0;
  }
  if (player === EXTERNAL) {
    return (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicMp4s */ .Fi)(assets).length > 0;
  }
  throw new Error("Unhandled player type '".concat(player, "'"));
};
var hasReadyVideoAssets = function hasReadyVideoAssets(assets) {
  return (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicMp4s */ .Fi)(assets).length > 0 || (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicM3u8s */ .x4)(assets).length > 0;
};
var hasReadyAudioAssets = function hasReadyAudioAssets(assets) {
  return (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicMp3s */ .o2)(assets).length > 0;
};
var hasEnoughReadyMp4Assets = function hasEnoughReadyMp4Assets(assets) {
  var mp4Assets = (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .filter */ .pb)(assets, {
    container: 'mp4',
    metadata: function metadata(m) {
      return m && m.max_bitrate;
    },
    public: true,
    sortBy: 'width desc',
    status: _assets_js__WEBPACK_IMPORTED_MODULE_6__/* .READY */ .yE,
    type: /\b(?!captioned_video)\S+/ // no burned in captions
  });

  // ensure that we have at least one asset at or above 400 width. This prevents
  // using HLS from using too low quality an asset, say in the scenario where
  // the other assets are still being processed.
  var hasAssetWithBitRateAndSize = Boolean(mp4Assets[0] && mp4Assets[0].width >= 400);
  return hasAssetWithBitRateAndSize;
};
var hasSupportedHlsAssets = function hasSupportedHlsAssets(mediaData) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (options.instantHls !== false && mediaData.instantHlsAssetsReady) {
    return true;
  }
  if (mediaData.originalIsEligibleForDirectPlayback) {
    return true;
  }
  var hasAssets = hasEnoughReadyMp4Assets(mediaData.assets);
  if (!hasAssets) {
    (0,utilities_metrics_js__WEBPACK_IMPORTED_MODULE_2__/* .count */ .U9)('player/originV2/media-has-no-metadata', 1, {
      hashedId: mediaData.hashedId
    });
  }
  return hasAssets;
};
var hlsOverrideValue = function hlsOverrideValue(_ref, embedOptions) {
  var pageUrl = _ref.pageUrl;
  var paramVal = hlsQueryParamValue(pageUrl);
  if (paramVal != null) {
    return paramVal;
  }
  var localStorageVal = (0,utilities_legacyLocalstorage_js__WEBPACK_IMPORTED_MODULE_3__/* .setOrGet */ .Qy)('forceHls');
  if (localStorageVal != null) {
    return localStorageVal;
  }
  return embedOptions.hls;
};
var hlsQueryParamValue = function hlsQueryParamValue(pageUrl) {
  var match = pageUrl && pageUrl.match && pageUrl.match(/[&?]whls=([^&]+)/);
  var val = match && match[1];
  if (val != null) {
    return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .cast */ .wg)(val);
  }
  return null;
};

// Chromecast doesn't work with hlsjs because it only understands a src
// that can be referenced externally. And playsinline=false or
// nativeMode=true is our signal to use something close to a native player.
var isBrowserInNativeAndroid = function isBrowserInNativeAndroid(detect, embedOptions) {
  return detect.android && (embedOptions.playsinline === false || embedOptions.nativeMode === true);
};

// chrome 49 and earlier (the last supported version on Win XP/Vista) does
// not support MSE well enough for hls.js.
var isBrowserOldChrome = function isBrowserOldChrome(detect) {
  return detect.chrome && parseInt(detect.chrome.version, 10) < 50;
};
var isHlsEnabled = function isHlsEnabled(context, mediaData, embedOptions) {
  // always prefer the hls override value if it is present, regardless of the
  // hls_enabled value
  var overrideValue = hlsOverrideValue(context, embedOptions);
  if (overrideValue === true || overrideValue === false) {
    return overrideValue;
  }
  if (mediaData.hls_enabled === false) {
    return false;
  }
  return true;
};
var isMobile = function isMobile(_ref2) {
  var detect = _ref2.detect;
  return detect.iphone || detect.ipad || detect.android;
};
var isNotPlayable = function isNotPlayable(context, mediaData) {
  var _embedOptions$authori;
  var embedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var assets = mediaData.assets;
  if (!mediaData.protected && (canUseInstantHls(context, mediaData, embedOptions) || canUseOriginalFilePlayback(context, mediaData, embedOptions))) {
    return false;
  }
  var assetsArentReady = mediaData.type === 'Audio' ? (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicMp3s */ .o2)(assets).length == 0 : (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicMp4s */ .Fi)(assets).length == 0;

  // LiveStreams won't have ready assets, but that does not mean we're in an
  // unplayable position.
  if (mediaData.mediaType === 'LiveStream') {
    return false;
  }

  // DRM-lite authorization check!
  // For DRM-lite, customers must include their `authorization` credentials as embedOptions. If we know
  // a media is "protected", but there are no authorization credentials for the embed, we can build
  // directly into the NotPlayablePlayer state.
  if (mediaData.protected && !((_embedOptions$authori = embedOptions.authorization) !== null && _embedOptions$authori !== void 0 && _embedOptions$authori.jwt)) {
    embedOptions.notPlayableOptions = {
      fadeIn: false,
      message: 'This video is set to private.',
      shouldRefresh: false
    };
    return true;
  }
  var allowHls = shouldServeHls(context, mediaData, embedOptions);
  if (mediaData.protected && allowHls === false) {
    embedOptions.notPlayableOptions = {
      fadeIn: false,
      message: 'This video is not playable.',
      shouldRefresh: false
    };
    return true;
  }
  return assets.length === 0 || assets.length === 1 && assets[0].type === 'original' || assetsArentReady || (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .nonfailedPublicOver400 */ .aF)(assets).length > 0 && (0,_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .readyPublicOver400 */ .n9)(assets).length === 0;
};
var isPasswordProtected = function isPasswordProtected(context, embedOptions) {
  var pluginOpts = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .getDeep */ .b$)(embedOptions, 'plugin.passwordProtectedVideo');
  return pluginOpts != null && pluginOpts.on !== false;
};
var isSphericalVideo = function isSphericalVideo() {
  var _mediaInfo$mediaData, _mediaInfo$opts;
  var mediaInfo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (mediaInfo.options.overrideSpherical) {
    return false;
  }
  var mediaDataSpherical = String((_mediaInfo$mediaData = mediaInfo.mediaData) === null || _mediaInfo$mediaData === void 0 ? void 0 : _mediaInfo$mediaData.spherical);
  var optsSpherical = String((_mediaInfo$opts = mediaInfo.opts) === null || _mediaInfo$opts === void 0 ? void 0 : _mediaInfo$opts.spherical);
  return mediaDataSpherical === 'true' || optsSpherical === 'true';
};
var isSupportedPlayer = function isSupportedPlayer(context, player) {
  if (!isValidPlayer(context, player)) {
    return false;
  }
  return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .indexOf */ .qh)(supportedPlayers(context), player) >= 0;
};
var isValidPlayer = function isValidPlayer(context, player) {
  return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .indexOf */ .qh)(PLAYERS, player) >= 0;
};
var logWarnings = function logWarnings(context) {
  var detect = context.detect,
    userAgent = context.userAgent,
    logger = context.logger,
    silenceGlobalWarnings = context.silenceGlobalWarnings;
  if (silenceGlobalWarnings) {
    // Customers can set window.wistiaSilenceGlobalWarnings = true, and that
    // will be included in the default judy context.
    return;
  }
  var isHeadless = /phantomjs/i.test(userAgent);
  if (xhrHasBeenTamperedWith()) {
    if (!isHeadless) {
      logger.error('The XMLHttpRequest constructor has been tampered with. Because this affects CORS/Range XHR requests, HLS playback has been disabled. To enable HLS playback and other important features, please remove code that changes the definition of window.XMLHttpRequest.');
    }
  }
  if (urlHasBeenTamperedWith()) {
    if (detect.mediaSource && !isHeadless) {
      logger.error('window.URL.createObjectURL has been tampered with. Because this affects use of Media Source Extensions, HLS playback has been disabled. window.URL is a browser API that should not be clobbered. Its current value is:', window.URL);
    }
  }
};
var playerPlugins = function playerPlugins(context, player, mediaData, embedOptions) {
  var logger = context.logger;
  var plugins = {};
  logger.info('playerPlugins input', player, mediaData.hashedId, mediaData, embedOptions);
  if (player === NOT_PLAYABLE) {
    merge(plugins, getPluginConfig(context, 'notPlayableVideo'));
  } else if (player === PASSWORD_PROTECTED) {
    merge(plugins, getPluginConfig(context, 'passwordProtectedVideo'));
  } else if (player === HTML5) {
    merge(plugins, getPluginConfig(context, 'html5Player'));
  } else if (player === EXTERNAL) {
    merge(plugins, getPluginConfig(context, 'externalPlayer'));
  } else if (player === VULCAN_V2) {
    merge(plugins, getPluginConfig(context, 'vulcanV2Player'));
  }
  var pluginNames = [];
  for (var k in plugins) {
    pluginNames.push(k);
  }
  logger.info.apply(logger, ['playerPlugins output'].concat(pluginNames, [plugins]));
  return plugins;
};
var report = function report(context, mediaData, embedOptions) {
  return {
    bestPlayer: bestPlayer(context, mediaData, embedOptions),
    playerPreferenceFromInput: determinePlayerPreferenceFromInput(context, mediaData, embedOptions),
    supportedPlayers: supportedPlayers(context),
    usablePlayers: usablePlayers(context, mediaData.assets)
  };
};
var shouldServeHls = function shouldServeHls(context, mediaData, embedOptions) {
  // start by forcing HLS when the type is livestream, but later
  // refactor things such that NotPlayablePlayer is used if we can't handle
  // live
  if (mediaData.type === 'LiveStream') {
    return true;
  }
  var detect = context.detect;
  return doesBrowserSupportHlsTools(detect) && !isBrowserOldChrome(detect) && !isBrowserInNativeAndroid(detect, embedOptions) &&
  // the account has hls enabled or explicitly trying to force
  isHlsEnabled(context, mediaData, embedOptions) &&
  // the media actually has desktop assets compatable with the delivery system
  hasSupportedHlsAssets(mediaData) && (
  // Some sites completely replace the XMLHttpRequest constructor with one
  // that doesn't work with hls.js. If we detect that, don't use HLS
  // (...unless we explicitly say to try it.)
  !xhrHasBeenTamperedWith(context) && !urlHasBeenTamperedWith(context) || hlsOverrideValue(context, embedOptions));
};
var supportedPlayers = function supportedPlayers(context) {
  var detect = context.detect;
  var result = [NOT_PLAYABLE, PASSWORD_PROTECTED, EXTERNAL, CAROUSEL_HARD_WALL];
  if (detect.vulcanV2Support) {
    result.push(VULCAN_V2);
  }
  if (detect.video.h264) {
    result.push(HTML5);
  }
  return result;
};
var usablePlayers = function usablePlayers(context, mediaData) {
  var result = [];
  var candidates = supportedPlayers(context);
  for (var i = 0; i < candidates.length; i++) {
    var player = candidates[i];
    if (canUsePlayer(context, player, mediaData)) {
      result.push(player);
    }
  }
  return result;
};

// `URL` is a built-in type, but a lot sites accidentally clobber it like
// `URL = location.href`. hls.js uses it though.
var urlHasBeenTamperedWith = function urlHasBeenTamperedWith() {
  return typeof (window.URL && window.URL.createObjectURL) !== 'function';
};

// `XMLHttpRequest.prototype.constructor.toString()` should be of this form if it's untampered with
var XMLHTTPREQUEST_CONSTRUCTOR_RE = /\s*function\s+XMLHttpRequest\(\)\s*{\s*\[native code\]\s*}\s*/m;
// Oddly, safari 9.x seems to display this in the [object ...] form.
var XMLHTTPREQUEST_CONSTRUCTOR_IN_SAFARI_9_RE = /\[object XMLHttpRequestConstructor\]/m;
var xhrHasBeenTamperedWith = function xhrHasBeenTamperedWith() {
  if (XMLHttpRequest && XMLHttpRequest.prototype && XMLHttpRequest.prototype.constructor) {
    var constructorString = XMLHttpRequest.prototype.constructor.toString();
    return !(XMLHTTPREQUEST_CONSTRUCTOR_RE.test(constructorString) || XMLHTTPREQUEST_CONSTRUCTOR_IN_SAFARI_9_RE.test(constructorString));
  }
  return true;
};

/***/ }),

/***/ 541:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ maybeStartWistiaQueue)
/* harmony export */ });
/* unused harmony export stopWistiaQueue */
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);

var QUEUE_INTERVAL = 500;
var wistiaQueue = null;

/**
 * Periodically checks the Wistia queue and executes the functions in it
 * @returns {void}
 */
var maybeStartWistiaQueue = function maybeStartWistiaQueue() {
  if (wistiaQueue) {
    return;
  }
  wistiaQueue = setInterval(function () {
    var queue = window._wq;
    if (!queue || queue.length === 0) {
      return;
    }
    queue.slice(0).forEach(function (item) {
      if (typeof item === 'function') {
        item(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s);
        queue.splice(queue.indexOf(item), 1);
      } else if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s.flushInitQueue) {
        queue.splice(queue.indexOf(item), 1);
        // eslint-disable-next-line no-console
        console.warn("<wistia-player> elements must be configured via window.wistiaOptions instead of window._wq. Config not applied", item);
      }
    });
  }, QUEUE_INTERVAL);
};

/**
 * Stops the Wistia queue
 * @returns {void}
 */
var stopWistiaQueue = function stopWistiaQueue() {
  if (wistiaQueue) {
    clearInterval(wistiaQueue);
    wistiaQueue = null;
  }
};

/***/ }),

/***/ 655:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U9: () => (/* binding */ count)
/* harmony export */ });
/* unused harmony exports send, msend, sample */
/* harmony import */ var utilities_timeout_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3737);
/* harmony import */ var utilities_wlog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6637);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(731);
/* harmony import */ var utilities_elem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7715);
/* harmony import */ var utilities_url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2671);
/* harmony import */ var utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5857);
/* harmony import */ var utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4755);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5509);
var _this = undefined;








var W = (/* unused pure expression or super */ null && (Wistia));
if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_7__/* .Wistia */ .s._metricsCache == null) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_7__/* .Wistia */ .s._metricsCache = {};
}
var METRICS_CACHE = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_7__/* .Wistia */ .s._metricsCache;
var send = function send(type, key, val) {
  var extraData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  try {
    if (METRICS_CACHE.toMput == null) {
      METRICS_CACHE.toMput = [];
    }
    if (METRICS_CACHE.requestId == null) {
      METRICS_CACHE.requestId = 0;
    }
    var messageObj = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__/* .merge */ .h1)({
      type: type,
      key: key,
      value: val != null ? val : null,
      request_id: METRICS_CACHE.requestId
    }, extraData);
    var serialized = JSON.stringify(messageObj);
    utilities_wlog_js__WEBPACK_IMPORTED_MODULE_1__/* .wlog */ .ct.debug('send metrics', serialized);
    METRICS_CACHE.toMput.push(serialized);
    (0,utilities_timeout_utils_js__WEBPACK_IMPORTED_MODULE_0__/* .doTimeout */ .L)('metrics.debounce', function () {
      (0,utilities_elem_js__WEBPACK_IMPORTED_MODULE_3__/* .pageLoaded */ .Rx)(function () {
        msend.apply(_this, METRICS_CACHE.toMput);
        METRICS_CACHE.toMput = [];
        METRICS_CACHE.requestId += 1;
      });
    }, 500);
  } catch (e) {
    utilities_wlog_js__WEBPACK_IMPORTED_MODULE_1__/* .wlog */ .ct.error(e);
  }
};
var msend = function msend() {
  if (!(0,utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_6__/* .isVisitorTrackingEnabled */ .D5)()) {
    return;
  }
  var url = "".concat((0,utilities_url_js__WEBPACK_IMPORTED_MODULE_4__/* .proto */ .ff)(), "//").concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__/* .metricsHost */ .Qz)(), "/mput?topic=metrics");
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  return fetch(url, {
    method: 'POST',
    mode: 'cors',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: messages.join('\n')
  }).then(function (response) {
    if (!response.ok) {
      // If fetch returns a response with an HTTP error code,
      // print an error in the console
      console.error(response);
    }
  }).catch(function (reason) {
    // If fetch fails (such as when this URL is blocked by an ad blocking extension),
    // print an error in the console
    console.error(reason);
  });
};
var count = function count(key) {
  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return send('count', key, val, extraData);
};
var sample = function sample(key, val, extraData) {
  return send('sample', key, val, extraData);
};

/***/ }),

/***/ 731:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cs: () => (/* binding */ eachLeaf),
/* harmony export */   G0: () => (/* binding */ unsetDeep),
/* harmony export */   Im: () => (/* binding */ isEmpty),
/* harmony export */   Lt: () => (/* binding */ select),
/* harmony export */   b$: () => (/* binding */ getDeep),
/* harmony export */   cy: () => (/* binding */ isArray),
/* harmony export */   di: () => (/* binding */ sort),
/* harmony export */   h1: () => (/* binding */ merge),
/* harmony export */   iu: () => (/* binding */ except),
/* harmony export */   j6: () => (/* binding */ only),
/* harmony export */   kp: () => (/* reexport safe */ utilities_assign_js__WEBPACK_IMPORTED_MODULE_0__.k),
/* harmony export */   mA: () => (/* binding */ setAndPreserveUndefined),
/* harmony export */   o8: () => (/* binding */ clone),
/* harmony export */   qh: () => (/* binding */ indexOf),
/* harmony export */   vd: () => (/* binding */ setDeep),
/* harmony export */   wg: () => (/* binding */ cast)
/* harmony export */ });
/* unused harmony exports mergeOne, identityFunc, legacyShouldDeleteFromMerge, exists, castDeep, filter, values, isObject, isFunction, isRegExp, isBasicType, isSubsetDeep, equalsDeep, eachDeep, pick, keys */
/* harmony import */ var utilities_assign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9025);
var _this = (/* unused pure expression or super */ null && (undefined));
var _objectHasOwn = function (object, property) {
  if (typeof object === 'undefined' || object === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
};


// Old trick to clone arrays, i.e. `aps.call(array)`.
var aps = Array.prototype.slice;
var merge = function merge(obj1) {
  if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {
    return obj1;
  }
  for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    _mergeOne(obj1, i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);
  }
  return obj1;
};

// Recursively merge the leaf values of obj2 into obj1. obj1 is modified
// in-place. Accepts objects or arrays. Always returns obj1.
//
// By default, we do not transform any merged values.
//
// We also use a non-ideal legacy strategy when merging null/undefined
// values from obj2: they will _delete_ corresponding keys in obj1. The more
// correct solution seems like it would be to _never_ delete from obj1, or
// at least to only delete `undefined` values, but maybe not null. We _may_
// be able to just make this change, but let's do one thing at a time.
var _mergeOne = function mergeOne(obj1, obj2) {
  var transformerFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identityFunc;
  var shouldDeleteFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : legacyShouldDeleteFromMerge;
  if (isArray(obj2)) {
    if (!isArray(obj1)) {
      obj1 = [];
    }
    for (var i = 0; i < obj2.length; i++) {
      var v = obj2[i];
      // note that setting an index of an array will naturally increase the
      // length of the array. Array#push() is not necessary.
      if (obj1[i] == null && v != null) {
        if (isArray(v)) {
          obj1[i] = [];
        } else if (isObject(v)) {
          obj1[i] = {};
        }
      }
      var result = _mergeOne(obj1[i], v, transformerFn);
      if (shouldDeleteFn(obj2, i, result)) {
        delete obj1[i];
      } else {
        obj1[i] = result;
      }
    }
    return transformerFn(obj1);
  }
  if (isObject(obj2)) {
    for (var k in obj2) {
      if (_objectHasOwn(obj2, k) && (_objectHasOwn(obj1, k) || obj1[k] == null)) {
        var _v = obj2[k];
        if (isArray(_v)) {
          if (!isArray(obj1[k])) {
            obj1[k] = [];
          }
          _mergeOne(obj1[k], _v, transformerFn);
          obj1[k] = transformerFn(obj1[k]);
        } else if (isObject(_v)) {
          if (!isObject(obj1[k])) {
            obj1[k] = {};
          }
          _mergeOne(obj1[k], _v, transformerFn);
          obj1[k] = transformerFn(obj1[k]);
        } else if (obj1 == null) {
          obj1 = {};
          if (!shouldDeleteFn(obj2, k, _v)) {
            obj1[k] = transformerFn(_v);
          }
        } else if (shouldDeleteFn(obj2, k, _v)) {
          delete obj1[k];
        } else {
          obj1[k] = transformerFn(_v);
        }
      }
    }
    return transformerFn(obj1);
  }
  // obj2 is not an object that can be cloned. Since we may recurse down
  // to this level, we should just return obj2, since it will overwrite
  // obj1.
  return transformerFn(obj2);
};
var identityFunc = function identityFunc(v) {
  return v;
};

// When merging, delete key from obj1 if the value from obj2 is null or
// undefined.
var legacyShouldDeleteFromMerge = function legacyShouldDeleteFromMerge(obj, k, v) {
  return v == null;
};
var clone = function clone(obj, transformerFn) {
  if (isArray(obj)) {
    return _mergeOne([], obj, transformerFn);
  }
  return _mergeOne({}, obj, transformerFn);
};
var getDeep = function getDeep(obj, parts, create) {
  if (typeof parts === 'string') {
    parts = parts.split('.');
  } else {
    parts = aps.call(parts);
  }
  var lastObj = obj;
  var lastP;
  while (obj != null && parts.length) {
    var p = parts.shift();
    if ((obj[p] === undefined || !isObject(obj[p]) && !isArray(obj[p])) && create) {
      if (p === 0) {
        obj = lastObj[lastP] = [];
        obj[p] = {};
      } else {
        obj[p] = {};
      }
    }
    lastObj = obj;
    lastP = p;

    // Only descend into properties that the object directly owns. getDeep({}, '__proto__')
    // See for security vulnerability reproduction.
    // https://github.com/wistia/player-modern/issues/1800
    if (_objectHasOwn(obj, p)) {
      obj = obj[p];
    } else {
      obj = undefined;
    }
  }
  return obj;
};
var setDeep = function setDeep(obj, parts, value) {
  return setAndMaybeDeleteUndefined(obj, parts, value, true);
};
var setAndPreserveUndefined = function setAndPreserveUndefined(obj, parts, value) {
  return setAndMaybeDeleteUndefined(obj, parts, value, false);
};
var setAndMaybeDeleteUndefined = function setAndMaybeDeleteUndefined(obj, parts, value) {
  var shouldDeleteUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  if (typeof parts === 'string') {
    parts = parts.split('.');
  } else {
    parts = aps.call(parts);
  }
  var prop = parts.pop();
  obj = getDeep(obj, parts, true);
  if (obj != null && (isObject(obj) || isArray(obj)) && prop != null) {
    if (!shouldDeleteUndefined || value != null) {
      obj[prop] = value;
    } else {
      delete obj[prop];
    }
  } else {
    // nothing to set or delete
    return undefined;
  }
};
var unsetDeep = function unsetDeep(obj, parts) {
  return setDeep(obj, parts);
};
var exists = function exists(obj, name) {
  return getDeep(obj, name) !== undefined;
};
var cast = function cast(maybeStr) {
  if (maybeStr == null) {
    return maybeStr;
  }
  if (isObject(maybeStr) || isArray(maybeStr)) {
    return castDeep(maybeStr);
  }
  return castStr("".concat(maybeStr), maybeStr);
};
var castStr = function castStr(str) {
  var defaultRet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : str;
  if (/^-?[1-9]\d*?$/.test(str)) {
    return parseInt(str, 10);
  }
  if (str === '0' || str === '-0') {
    return 0;
  }
  if (/^-?\d*\.\d+$/.test(str)) {
    return parseFloat(str);
  }
  if (/^true$/i.test(str)) {
    return true;
  }
  if (/^false$/i.test(str)) {
    return false;
  }
  return defaultRet;
};

// Given an object or array, iterates over each leaf and casts the value.
var castDeep = function castDeep(obj) {
  var castTransformer = function castTransformer(val) {
    if (typeof val === 'string') {
      return castStr(val);
    }
    return val;
  };
  var dontDeleteAnything = function dontDeleteAnything() {
    return false;
  };
  return _mergeOne(obj, obj, castTransformer, dontDeleteAnything);
};
var only = function only(hash, keys) {
  var result = {};
  var keyHash = {};
  for (var i = 0; i < keys.length; i++) {
    keyHash[keys[i]] = true;
  }
  for (var k in hash) {
    if (keyHash[k]) {
      result[k] = hash[k];
    }
  }
  return result;
};
var except = function except(hash, keys) {
  var result = {};
  var keyHash = {};
  for (var i = 0; i < keys.length; i++) {
    keyHash[keys[i]] = true;
  }
  for (var k in hash) {
    if (!keyHash[k]) {
      result[k] = hash[k];
    }
  }
  return result;
};

// Advanced sorting and filtering so we can be expressive and concise when
// choosing assets.
//
// Defined at the class level so it's easier to test sorting and filtering.
var select = function select(arr, keyPairs) {
  var result = [];
  var isFn = typeof keyPairs === 'function';
  var filterFn = isFn ? keyPairs : null;
  for (var i = 0; i < arr.length; i++) {
    var elem = arr[i];
    if (isFn) {
      // Filter by function. This gives the most freedom.
      if (filterFn(elem)) {
        result.push(elem);
      }
    } else {
      // Select the asset if all keyPairs of the object match. Common.
      var matching = true;
      for (var k in keyPairs) {
        var v = keyPairs[k];
        if (v instanceof Array) {
          // Range check.
          if (!elem[k] || elem[k] < v[0] || elem[k] > v[1]) {
            matching = false;
            break;
          }
        } else if (v instanceof RegExp) {
          // Regular Expression check.
          if (!v.test(elem[k])) {
            matching = false;
            break;
          }
        } else if (v instanceof MultipleValues) {
          var anyMatch = false;
          for (var j = 0; j < v.values.length; j++) {
            var value = v.values[j];
            if (elem[k] === value) {
              anyMatch = true;
              break;
            }
          }
          if (!anyMatch) {
            matching = false;
            break;
          }
        } else if (typeof v === 'function') {
          if (elem[k] == null || !v(elem[k])) {
            matching = false;
            break;
          }
        } else if (elem[k] !== v) {
          // Exact match.
          matching = false;
          break;
        }
      }
      if (matching) {
        result.push(elem);
      }
    }
  }
  return result;
};

// This is just a way to box multiple values in a semantic way, to help us
// differentiate between AND/OR/Range type situations.
var MultipleValues = function MultipleValues(values) {
  var self = this;
  var construct = function construct() {
    self.values = values;
  };
  construct();
  return self;
};
var values = function values() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }
  return new MultipleValues(values);
};
var sort = function sort(arr, keys) {
  var isFn = typeof keys === 'function';
  var filterFn = isFn ? keys : null;
  var result = aps.call(arr);

  // Sort results with this option.
  if (isFn) {
    // Sort via sort functions. This gives the most freedom.
    result.sort(filterFn);
  } else {
    // Convenience for sorting by one or many properties. Can either pass an
    // array or a comma separated list.
    result.sort(function (a, b) {
      var sortBys;
      if (keys instanceof Array) {
        sortBys = clone(keys);
      } else {
        sortBys = keys.split(/\s*,\s*/);
      }
      var ret = 0;
      while (ret === 0 && sortBys.length > 0) {
        var pieces = sortBys.shift().split(/\s+/);
        var sortBy = pieces[0];
        var dir = pieces[1];
        dir = dir === 'desc' ? -1 : 1;
        if (a[sortBy] < b[sortBy]) {
          ret = -1 * dir;
          break;
        } else if (a[sortBy] === b[sortBy]) {
          ret = 0;
        } else {
          ret = 1 * dir;
          break;
        }
      }
      return ret;
    });
  }
  return result;
};
var filter = function filter(arr, callback, thisArg) {
  var ctx = thisArg === undefined ? _this : thisArg;
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (callback.call(ctx, arr[i], i, arr)) {
      result.push(arr[i]);
    }
  }
  return result;
};

// returns true if obj is a basic Array, []
// duck type push as optimization; most checks are not arrays and will not
// have push set. this way we avoid the implicit toString() on the
// constructor.
var ARR_REGEXP = /^\s*function Array()/;
var isArray = function isArray(obj) {
  return obj != null && obj.push && ARR_REGEXP.test(obj.constructor);
};

// returns true if obj is a basic Object, {}
var OBJ_REGEXP = /^\s*function Object()/;
var isObject = function isObject(obj) {
  return obj != null && typeof obj === 'object' && OBJ_REGEXP.test(obj.constructor);
};
var isFunction = function isFunction(obj) {
  return obj != null && typeof obj === 'function';
};
var REGEXP_REGEXP = /^\s*function RegExp()/;
var isRegExp = function isRegExp(obj) {
  return obj != null && REGEXP_REGEXP.test(obj.constructor);
};

// returns true if obj is one of javascript's basic types
var BASIC_TYPE_REGEXP = /^string|number|boolean|function$/i;
var isBasicType = function isBasicType(obj) {
  return obj != null && (BASIC_TYPE_REGEXP.test(typeof obj) || isRegExp(obj));
};
var isEmpty = function isEmpty(obj) {
  if (obj == null) {
    return true;
  }
  if (isArray(obj) && !obj.length) {
    return true;
  }
  if (isObject(obj)) {
    if (Object.keys(obj).length) {
      return false;
    }
    return true;
  }
  return false;
};

// returns true if obj1 is a subset of obj2
var isSubsetDeep = function isSubsetDeep(obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }
  if (obj1 != null && obj2 == null || obj1 == null && obj2 != null) {
    return false;
  }
  var result = true;
  eachLeaf(obj1, function (obj1LeafVal, path) {
    var obj2LeafVal = getDeep(obj2, path);
    if (obj1LeafVal !== obj2LeafVal) {
      result = false;
    }
  });
  return result;
};

// true if each object is a subset of the other
var equalsDeep = function equalsDeep(obj1, obj2) {
  return isSubsetDeep(obj1, obj2) && isSubsetDeep(obj2, obj1);
};

//
// This is the meat and potatoes for iterating over
// javascript object/array structures.
//
// Call fn(node, path, parent, key) for each node in an object.
//
// We include the parent + key so that the callback can modify the leaf
// value in-place. We pass the path to the root node (the keys from root to
// leaf) so that we can serialize objects.
var _eachDeep = function eachDeep(obj, fn, path, parent, key) {
  if (path == null) {
    path = [];
  }
  if (isBasicType(obj)) {
    fn(obj, path, parent, key);
  } else if (isObject(obj) || isArray(obj)) {
    fn(obj, path, parent, key);
    for (var _key2 in obj) {
      if (_objectHasOwn(obj, _key2)) {
        var newPath = aps.call(path);
        newPath.push(_key2);
        _eachDeep(obj[_key2], fn, newPath, obj, _key2);
      }
    }
  } else {
    fn(obj, path, parent, key);
  }
};

// call fn(node, path, parent, key) for each leaf node in an object
var eachLeaf = function eachLeaf(obj, fn) {
  _eachDeep(obj, function (obj, path, parent, key) {
    if (!isArray(obj) && !isObject(obj)) {
      fn(obj, path, parent, key);
    }
  });
};
var pick = function pick(obj, keys) {
  var result = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (obj[key]) {
      result[key] = obj[key];
    }
  }
  return result;
};
var indexOf = function indexOf(arr, target) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i;
    }
  }
  return -1;
};
var keys = function keys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }
  var result = [];
  for (var k in obj) {
    if (_objectHasOwn(obj, k)) {
      result.push(k);
    }
  }
  return result;
};


/***/ }),

/***/ 787:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ appHostname)
/* harmony export */ });
var appHostname = function appHostname() {
  var subdomain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'app';
  var hostname =  false || "wistia.com";
  return "".concat(subdomain, ".").concat(hostname);
};

/***/ }),

/***/ 959:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ isMediaDataError)
/* harmony export */ });
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4586);

var isMediaDataError = function isMediaDataError(mediaData) {
  if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_0__/* .isNil */ .gD)(mediaData.error)) {
    return false;
  }
  if (mediaData.error === 'true' || mediaData.error === true) {
    return true;
  }
  return false;
};

/***/ }),

/***/ 998:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   K6: () => (/* binding */ rgbToHsl),
/* harmony export */   bJ: () => (/* binding */ getContrast),
/* harmony export */   s1: () => (/* binding */ colorContrastRatiosByShape)
/* harmony export */ });
/* unused harmony exports adjustColorForProperContrast, generateColorPalette, getBestColorForShape */
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4586);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5417);
/* harmony import */ var _sentryUtils_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2621);
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }




/* eslint-disable @typescript-eslint/no-magic-numbers */
var colorContrastRatiosByShape = {
  nonText: 3,
  // 3:1 - https://www.w3.org/TR/WCAG21/#non-text-contrast
  largeText: 3,
  // 3:1 - https://www.w3.org/TR/WCAG21/#contrast-minimum
  paragraphText: 4.5,
  // 4.5:1 -  https://www.w3.org/TR/WCAG21/#contrast-minimum
  smallText: 5.5 // We're making this up, but it should be more than the paragraph text
};
var rgbToHsl = function rgbToHsl(color) {
  var colorArray = color;
  if (color instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .Q) {
    if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(color.r) || (0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(color.g) || (0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(color.b)) {
      throw new Error('Color does not contain required RGB values');
    }
    colorArray = [color.r, color.g, color.b];
  } else if (typeof color === 'string') {
    var colorInstance = new _color_js__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .Q(color);
    if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(colorInstance.r) || (0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(colorInstance.g) || (0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(colorInstance.b)) {
      throw new Error('Color does not contain required RGB values');
    }
    colorArray = [colorInstance.r, colorInstance.g, colorInstance.b];
  }
  var red = colorArray[0] / 255;
  var green = colorArray[1] / 255;
  var blue = colorArray[2] / 255;
  var max = Math.max(red, green, blue);
  var min = Math.min(red, green, blue);
  var hue = 0;
  var saturation = 0;
  var lightness = (max + min) / 2;
  if (max === min) {
    hue = 0;
    saturation = 0;
  }
  var delta = max - min;
  if (delta === 0) {
    return {
      hue: hue,
      saturation: saturation,
      lightness: red * 100
    };
  }
  if (lightness > 0.5) {
    saturation = delta / (2 - max - min);
  } else {
    saturation = delta / (max + min);
  }
  if (max === red) {
    hue = (green - blue) / delta + (green < blue ? 6 : 0);
  } else if (max === green) {
    hue = (blue - red) / delta + 2;
  } else {
    hue = (red - green) / delta + 4;
  }
  hue /= 6;
  return {
    hue: hue * 360,
    saturation: saturation * 100,
    lightness: lightness * 100
  };
};
var getContrast = function getContrast(foreground, background) {
  // WCAG contrast ratio
  // see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
  var foregroundColor = new _color_js__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .Q(foreground);
  var backgroundColor = new _color_js__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .Q(background);
  var l1 = foregroundColor.getRelativeLuminance();
  var l2 = backgroundColor.getRelativeLuminance();
  return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
};
var adjustColorForProperContrast = function adjustColorForProperContrast(foreground, background) {
  var shape = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'paragraphText';
  var foregroundColor = new Color(foreground);
  var backgroundColor = new Color(background);

  // This shouldn't be a valid scenario, but since the Color class isn't converted to TS yet
  // the r, g, and b properties could theoretically be optional
  if (isNil(foregroundColor.r) || isNil(foregroundColor.g) || isNil(foregroundColor.b)) {
    throw new Error('Color does not contain required RGB values');
  }

  /* eslint-disable @typescript-eslint/no-magic-numbers */
  var initialContrastRatio = getContrast(foregroundColor.toHexWithHash(), backgroundColor.toHexWithHash());
  if (foregroundColor.hasAccessibleContrast(backgroundColor, shape)) {
    return foregroundColor.toHexWithHash();
  }
  var _rgbToHsl = rgbToHsl([foregroundColor.r, foregroundColor.g, foregroundColor.b]),
    foregroundColorLightness = _rgbToHsl.lightness;

  // Does lightening the foreground color slightly increase the contrast ratio?
  var shouldForegroundColorBeLighter = foregroundColorLightness < 0.1 || foregroundColor.getContrastRatio(backgroundColor) > initialContrastRatio;

  // If the foreground color is already very light and the initial contrast ratio was 1:1,
  // lightening the foreground color technically would have increased the contrast ratio, but
  // we know it can never be lightened enough to provide sufficient contrast,
  // so we'll set shouldForegroundColorBeLighter to false.
  if (foregroundColorLightness > 0.8 && initialContrastRatio === 1) {
    shouldForegroundColorBeLighter = false;
  }
  var adjustedForegroundColor = new Color(foregroundColor);
  var i = 0;
  while (!adjustedForegroundColor.hasAccessibleContrast(backgroundColor, shape)) {
    i += 1;
    // This is a safety mechanism to prevent getting stuck in an infinite loop.
    // If anyone exceeds 1,000 attempts to find a contrasting color, just return the best option we have
    // and log the colors where we couldn't generate sufficient contrast.
    if (i > 1000) {
      reportError('other', new Error("Exceeded ".concat(i, " attempts to find contrasting color")), {
        key: 'adjust-color-for-proper-contrast',
        foregroundColor: foregroundColor.toHexWithHash(),
        backgroundColor: backgroundColor.toHexWithHash()
      });
      return "#".concat(adjustedForegroundColor.toHex());
    }
    var adjustedForegroundColorLuminance = adjustedForegroundColor.getRelativeLuminance();
    // If the adjusted foreground color is white or black and the required contrast ratio is more than 3:1,
    // we should just return the adjusted foreground color.
    // Otherwise, if the adjusted foreground color is white or black,
    // reset the adjusted foreground color to the original foreground color and try looking
    // in the opposite direction for a properly contrasting color.
    if (i > 1 && (adjustedForegroundColorLuminance === 1 || adjustedForegroundColorLuminance === 0)) {
      if (colorContrastRatiosByShape[shape] > 3) {
        return getContrast('#fff', backgroundColor.toHexWithHash()) > getContrast('#000', backgroundColor.toHexWithHash()) ? '#fff' : '#000';
      }
      shouldForegroundColorBeLighter = !shouldForegroundColorBeLighter;
      adjustedForegroundColor = foregroundColor;
    }
    if (shouldForegroundColorBeLighter) {
      adjustedForegroundColor.lighten(1);
    } else {
      adjustedForegroundColor.darken(1);
    }

    /* eslint-enable @typescript-eslint/no-magic-numbers */
  }
  return adjustedForegroundColor.toHexWithHash();
};

/**
 * Takes an array of values, either strings or Color objects, then
 *   - inserts black and white values in case we need these for our contrast-fetching functions using palettes
 *   - filters any duplicate values
 *   - sorts the palette from darkest to lightest color value by its relative luminance
 *
 * @param colors - an array of Color objects or strings representing hex values
 * @returns Color[]
 */
var generateColorPalette = function generateColorPalette(colors) {
  var formattedColors = colors.map(function (color) {
    return new Color(color);
  });
  // Make sure we have black and white colors available in case they're needed for sufficient contrast
  var uniqueColors = [new Color('#ffffff'), new Color('#000000')].concat(_toConsumableArray(formattedColors)).reduce(function (acc, currentColor) {
    if (acc.find(function (colorObj) {
      return colorObj.toHex() === currentColor.toHex();
    })) {
      return acc;
    }
    acc.push(currentColor);
    return acc;
  }, []);
  return uniqueColors.sort(function (colorOne, colorTwo) {
    return colorOne.getRelativeLuminance() - colorTwo.getRelativeLuminance();
  });
};

/**
 * Given a set of colors, a background color, and any colors from the set that we want to exclude from consideration,
 * this utility returns an appropriate foreground color based on the contrast ratio required for the shape param.
 *
 * For example, this method could be used to determine that we should use white text against a black background and vice versa.
 *
 * @param colors - an array of Color objects or strings representing hex values
 * @param backgroundColor - a Color object or hex string
 * @param [colorsToExclude] - optional,  an array of Color objects or strings representing hex values
 * @param [shape] - optional, used to determine the appropriate contrast ratio used in calculating the foreground color
 * @returns
 */
var getBestColorForShape = function getBestColorForShape(colors, backgroundColor) {
  var colorsToExclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var shape = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'paragraphText';
  var colorPalette = generateColorPalette(colors);
  var backgroundColorObj = new Color(backgroundColor);

  // Always exclude the background color in addition to the colorsToExclude
  var formattedExcludedColors = colorsToExclude.map(function (color) {
    return new Color(color);
  });
  formattedExcludedColors.push(new Color(backgroundColor));

  // If one of the excluded colors is black or white, don't exclude it.
  // We always need black and white as potential text color options.
  formattedExcludedColors = formattedExcludedColors.filter(function (color) {
    return color.toHex() !== '000000' && color.toHex() !== 'FFFFFF';
  });
  var stringifiedExcludedColors = formattedExcludedColors.map(function (formattedColor) {
    return formattedColor.toHex();
  });
  var availableColors = colorPalette.filter(function (color) {
    return !stringifiedExcludedColors.includes(color.toHex());
  });

  // If the background color is light, sort the available colors from lightest to darkest
  if (!backgroundColorObj.isDark(true)) {
    availableColors.reverse();
  }
  var textColor = availableColors.find(function (color) {
    return color.getContrastRatio(backgroundColor) >= colorContrastRatiosByShape[shape];
  });
  if (!textColor) {
    return backgroundColorObj.isDark(true) ? '#ffffff' : '#000000';
  }
  return textColor.toHexWithHash();
};

/***/ }),

/***/ 1161:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WO: () => (/* binding */ countMetric)
/* harmony export */ });
/* unused harmony exports sendMetrics, sampleMetric, sendMetric, _clearMetricsCache */
/* harmony import */ var utilities_assign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9025);
/* harmony import */ var utilities_pageLoaded_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9562);
/* harmony import */ var utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4755);
/* harmony import */ var _hosts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5857);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5509);
var _this = undefined;





if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._simpleMetricsCache == null) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._simpleMetricsCache = {};
}
if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._simpleMetricsDebounceInterval == null) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._simpleMetricsDebounceInterval = 500;
}
var METRICS_CACHE = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._simpleMetricsCache;
var countMetric = function countMetric(key) {
  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return sendMetric('count', key, val, extraData);
};
var sendMetrics = function sendMetrics() {
  if (!(0,utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_0__/* .isVisitorTrackingEnabled */ .D5)()) {
    return;
  }
  var url = "https://".concat((0,_hosts_js__WEBPACK_IMPORTED_MODULE_1__/* .metricsHost */ .Qz)(), "/mput?topic=metrics");
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  return fetch(url, {
    method: 'POST',
    mode: 'cors',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: messages.join('\n')
  }).then(function (response) {
    if (!response.ok) {
      // If fetch returns a response with an HTTP error code,
      // print an error in the console
      console.error(response);
    }
  }).catch(function (reason) {
    // If fetch fails (such as when this URL is blocked by an ad blocking extension),
    // print an error in the console
    console.error(reason);
  });
};
var sampleMetric = function sampleMetric(key, val, extraData) {
  return sendMetric('sample', key, val, extraData);
};
var getCircularReplacer = function getCircularReplacer() {
  // form a closure and use this
  // weakset to monitor object reference.
  var seen = new WeakSet();

  // return the replacer function
  return function (key, value) {
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) {
        return '[Circular]';
      }
      seen.add(value);
    }
    return value;
  };
};
var sendMetric = function sendMetric(type, key, val) {
  var extraData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (!(0,utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_0__/* .isVisitorTrackingEnabled */ .D5)()) {
    return;
  }
  try {
    if (METRICS_CACHE.toMput == null) {
      METRICS_CACHE.toMput = [];
    }
    var messageObj = (0,utilities_assign_js__WEBPACK_IMPORTED_MODULE_3__/* .assign */ .k)({
      type: type,
      key: key,
      value: val != null ? val : null
    }, extraData);
    var serialized = JSON.stringify(messageObj, getCircularReplacer());
    METRICS_CACHE.toMput.push(serialized);
    clearTimeout(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._msendTimeout);
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._msendTimeout = setTimeout(function () {
      (0,utilities_pageLoaded_js__WEBPACK_IMPORTED_MODULE_4__/* .pageLoaded */ .R)(function () {
        sendMetrics.apply(_this, METRICS_CACHE.toMput);
        METRICS_CACHE.toMput = [];
      });
    }, _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._simpleMetricsDebounceInterval);
  } catch (e) {
    console.error(e.message);
    console.error(e.stack);
  }
};

// only used in testing to clear the cache
var _clearMetricsCache = function _clearMetricsCache() {
  METRICS_CACHE.toMput = [];
};

/***/ }),

/***/ 1224:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h: () => (/* binding */ seqId)
/* harmony export */ });
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);

var seqId = function seqId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'wistia_';
  var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var currentVal = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._sequenceVal || 1;
  var result = "".concat(prefix).concat(currentVal).concat(suffix);
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._sequenceVal = currentVal + 1;
  return result;
};

/***/ }),

/***/ 1248:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ runScript)
/* harmony export */ });
/* harmony import */ var _hosts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5857);

// fire and forget.
// run a script and immediately remove it from the DOM.
var runScript = function runScript(src, timeout) {
  var taggedVersion = _hosts_js__WEBPACK_IMPORTED_MODULE_0__/* .TAGGED_VERSION */ .U4;
  return new Promise(function (resolve, reject) {
    if (timeout == null) {
      timeout = 8000;
    }
    var s;
    s = document.createElement('script');
    s.src = src;
    s.async = true;
    s.type = 'text/javascript';
    if (/https?:\/\/fast\.wistia\./.test(s.src) && taggedVersion !== '' && taggedVersion.length > 0) {
      s.src = "".concat(s.src, "@").concat(taggedVersion);
    }
    var cleanupTimeoutId = null;
    var done = false;
    var cleanUp = function cleanUp() {
      s.onerror = s.onreadystatechange = s.onload = null;
      clearTimeout(cleanupTimeoutId);
      clearTimeout(loadingTimeout);
      cleanupTimeoutId = setTimeout(function () {
        if (s && s.parentNode) {
          s.parentNode.removeChild(s);
        }
      }, 500);
    };
    var onSuccess = function onSuccess() {
      var state = s.readyState;
      if (!done && (!state || /loaded|complete/.test(state))) {
        done = true;
        // We call success on next tick to separate script evaluation time from
        // callback execution time. This helps reduce thread-blocking since
        // script-eval and initialization tend to be expensive.
        setTimeout(function () {
          resolve();
          cleanUp();
        }, 1);
      }
    };
    var onTimeout = function onTimeout() {
      done = true;
      cleanUp();
      reject(new Error('timeout'));
    };
    var onError = function onError(e) {
      done = true;
      cleanUp();
      reject(e);
    };
    var loadingTimeout = setTimeout(onTimeout, timeout);
    s.onerror = onError;
    s.onreadystatechange = onSuccess;
    s.onload = onSuccess;
    (document.body || document.head).appendChild(s);
  });
};

/***/ }),

/***/ 1341:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G5: () => (/* binding */ flexibleDuration),
/* harmony export */   ab: () => (/* binding */ secondsConverter)
/* harmony export */ });
/* unused harmony exports formattedDurationToSeconds, accessibilityDuration, humanReadableDuration, getSecondsRemaining, secondsToMilliseconds */
/* harmony import */ var iso8601_duration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6633);


var SECONDS_IN_HOUR = 3600;
var MINUTES_IN_HOUR = 60;
var SECONDS_IN_MINUTE = 60;
var padNumber = function padNumber(num) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var result = "".concat(num);
  while (result.length < length) {
    result = "0".concat(result);
  }
  return result;
};
var secondsConverter = function secondsConverter(total, format) {
  var hours = 0;
  var minutes = 0;
  var seconds = 0;
  var remainingDuration = total;
  var useHours = format.includes('h');
  var useMinutes = format.includes('m');
  if (useHours && remainingDuration > 0) {
    hours += Math.floor(remainingDuration / SECONDS_IN_HOUR);
    remainingDuration %= SECONDS_IN_HOUR;
  }
  if (useMinutes && remainingDuration > 0) {
    minutes += Math.floor(remainingDuration / MINUTES_IN_HOUR);
    remainingDuration %= MINUTES_IN_HOUR;
  }
  seconds = Math.round(remainingDuration);
  if (useHours && minutes === MINUTES_IN_HOUR) {
    hours += 1;
    minutes = 0;
  }
  if (useMinutes && seconds === SECONDS_IN_MINUTE) {
    minutes += 1;
    seconds = 0;
  }
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
};

// flexibleDuration is a duration format that uses as
// few digits as possible to express that duration
var flexibleDuration = function flexibleDuration(total) {
  var _secondsConverter = secondsConverter(total, 'hms'),
    hours = _secondsConverter.hours,
    minutes = _secondsConverter.minutes,
    seconds = _secondsConverter.seconds;
  if (hours === 0) {
    return "".concat(minutes, ":").concat(padNumber(seconds, 2));
  }
  return "".concat(hours, ":").concat(padNumber(minutes, 2), ":").concat(padNumber(seconds, 2));
};
var formattedDurationToSeconds = function formattedDurationToSeconds(dur) {
  if (isNil(dur) || isNumber(dur)) {
    return dur;
  }
  try {
    var parsed = parse(dur.toUpperCase());
    return toSeconds(parsed);
  } catch (_unused) {
    /* empty, we want to swallow and continue */
  }

  // We allow for non-standard IS0 6801 Duration strings, eg. 1H30M,
  // the parsing lib can do that if prefixed with the correct ISO Duration prefixes
  try {
    var _parsed = parse("PT".concat(dur.toUpperCase()));
    return toSeconds(_parsed);
  } catch (_unused2) {
    /* empty, we want to swallow and continue */
  }
  return dur;
};
var accessibilityDuration = function accessibilityDuration(duration) {
  var _secondsConverter2 = secondsConverter(duration, 'hms'),
    hours = _secondsConverter2.hours,
    minutes = _secondsConverter2.minutes,
    seconds = _secondsConverter2.seconds;
  var zeroHours = hours === 0;
  var zeroMinutes = minutes === 0;
  if (zeroHours && zeroMinutes) {
    return "".concat(seconds, " second").concat(seconds === 1 ? '' : 's');
  }
  var hoursText = zeroHours ? '' : "".concat(hours, " hour").concat(hours === 1 ? '' : 's');
  var minText = zeroMinutes ? '' : "".concat(minutes, " minute").concat(hours === 1 ? '' : 's');
  return "".concat(hoursText, " ").concat(minText).trim();
};
var humanReadableDuration = function humanReadableDuration(duration) {
  var _secondsConverter3 = secondsConverter(duration, 'hms'),
    hours = _secondsConverter3.hours,
    minutes = _secondsConverter3.minutes,
    seconds = _secondsConverter3.seconds;
  var zeroHours = hours === 0;
  var zeroMinutes = minutes === 0;
  if (zeroHours && zeroMinutes) return "".concat(seconds, " Sec");
  var hoursText = zeroHours ? '' : "".concat(hours, " Hr");
  var minText = zeroMinutes ? '' : "".concat(minutes, " Min");
  return "".concat(hoursText, " ").concat(minText).trim();
};
var getSecondsRemaining = function getSecondsRemaining(start, end) {
  var remaining = end.getTime() - start.getTime();
  return remaining / 1000;
};
var secondsToMilliseconds = function secondsToMilliseconds(seconds) {
  return seconds * 1000;
};

/***/ }),

/***/ 1512:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ CONTROL_BAR_HEIGHT),
/* harmony export */   R: () => (/* binding */ DEFAULT_ASPECT)
/* harmony export */ });
var CONTROL_BAR_HEIGHT = 34;

// eslint-disable-next-line @typescript-eslint/no-magic-numbers
var DEFAULT_ASPECT = 16 / 9;

/***/ }),

/***/ 1627:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Uh: () => (/* reexport safe */ utilities_unescape_html_js__WEBPACK_IMPORTED_MODULE_0__.U),
/* harmony export */   u: () => (/* binding */ base64Decode)
/* harmony export */ });
/* unused harmony exports unbreakifyText, stripHtml, camelCase, snakeCase, shallowCamelizeKeys, shallowSnakeKeys, base64Encode, notSetOrTrue, preventOuterMouseWheel, parentFramesLength */
/* harmony import */ var utilities_unescape_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2428);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);






// replace spaces in text with &nbsp; this prevents the line from wrapping.
// specifically, it allows menu items in the vulcan ui to push their parent div
// open as wide as the text.
var unbreakifyText = function unbreakifyText() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return text.replace(' ', '&nbsp;');
};
var stripHtml = function stripHtml(htmlStr) {
  var tmp = document.createElement('div');
  tmp.innerHTML = htmlStr;
  return tmp.textContent || tmp.innerText || '';
};
var camelCase = function camelCase(snakeStr) {
  return snakeStr.replace(/[_-]([a-z])/g, function (g) {
    return g.charAt(1).toUpperCase();
  });
};
var snakeCase = function snakeCase(camelStr) {
  return camelStr.replace(/[A-Z]/g, function (g) {
    return "_".concat(g.toLowerCase());
  });
};

// Not safe IE8 and below.
var shallowCamelizeKeys = function shallowCamelizeKeys(o) {
  return Object.keys(o).reduce(function (memo, key) {
    memo[camelCase(key)] = o[key];
    return memo;
  }, {});
};

// Not safe IE8 and below.
var shallowSnakeKeys = function shallowSnakeKeys(o) {
  return Object.keys(o).reduce(function (memo, key) {
    memo[snakeCase(key)] = o[key];
    return memo;
  }, {});
};

// the implementations of base64Decode and base64Encode here are adapted from
// https://stackoverflow.com/a/30106551/529530, and designed to safely handle
// multibyte characters

var base64Decode = function base64Decode(input) {
  return decodeURIComponent(atob(input).split('').map(function (c) {
    return "%".concat("00".concat(c.charCodeAt(0).toString(16)).slice(-2));
  }).join(''));
};
var base64Encode = function base64Encode(input) {
  return btoa(encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode("0x".concat(p1));
  }));
};
var notSetOrTrue = function notSetOrTrue(val) {
  return val == null || val === true;
};

// prevent scrolling outside a container
// topMargin and bottomMargin are optional and can be used to provide a cushion to adjust to determine
// if you are at the top. We have seen some weird behavior with some uses where the scrollTop maxes out
// at scrollHeight - offsetHeight - 1.  Possible subpixel rendering issue???
var preventOuterMouseWheel = function preventOuterMouseWheel(e, container) {
  var topMargin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var bottomMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var scrollTop = container.scrollTop,
    scrollHeight = container.scrollHeight,
    offsetHeight = container.offsetHeight;
  var hitTop = function hitTop() {
    var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return scrollTop + extra - topMargin <= 0;
  };
  var hitBottom = function hitBottom() {
    var extra = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return scrollTop + extra + bottomMargin >= scrollHeight - offsetHeight;
  };
  var delta = e.deltaY || -e.wheelDelta;
  var dir = delta > 0 ? 'down' : 'up';
  var isModernBrowser = !!e.deltaY;
  if (isModernBrowser) {
    if (dir === 'up' && hitTop() || dir === 'down' && hitBottom()) {
      e.preventDefault();
    }
  } else {
    // IE scrolls 47.5 pixels each scroll but reports 120
    var extra = 47.5 * delta / 120;
    if (dir === 'up' && hitTop(extra)) {
      e.preventDefault();
      // Manually set scroll to avoid scrolling parent in IE 11
      container.scrollTop = 0;
    } else if (dir === 'down' && hitBottom(extra)) {
      e.preventDefault();
      container.scrollTop = scrollHeight - offsetHeight;
    }
  }
};

// parent.frames.length should tell us how many iframes exist on the parent
// page. However, if the user has overwritten the accessor with something
// that's not safe for CORS (i.e. they changed it at all), then
// parent.frames.length throws an exception and screws up the embedding
// process. This function just gives a safe way of getting the value, or
// defaulting to something unknown.
var parentFramesLength = function parentFramesLength() {
  try {
    return parent.frames.length;
  } catch (e) {
    Wistia.warn(e);
    return 1;
  }
};

/***/ }),

/***/ 1885:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CC: () => (/* binding */ mediaDataUrl),
/* harmony export */   dq: () => (/* binding */ mediaDataScriptRegExp)
/* harmony export */ });
/* unused harmony exports transformResponse, cacheMedia, uncacheMedia, mediaFromCache */
/* harmony import */ var wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);
/* harmony import */ var utilities_root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8176);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(731);
/* harmony import */ var utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(159);
/* harmony import */ var utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3411);
/* harmony import */ var utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5857);
/* harmony import */ var utilities_media_data_transforms_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3917);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }







var transformResponse = function transformResponse(mediaData, options) {
  var _mediaWithOpts$media;
  var mediaWithOpts = _objectSpread({}, mediaData);
  var transformOpts = merge({}, (_mediaWithOpts$media = mediaWithOpts.media) === null || _mediaWithOpts$media === void 0 ? void 0 : _mediaWithOpts$media.embedOptions, options);
  if (mediaWithOpts.error) {
    return mediaWithOpts;
  }
  delete mediaWithOpts.media.unnamed_assets;
  mediaDataTransforms(mediaWithOpts.media, transformOpts);
  return mediaWithOpts.media;
};
var mediaDataUrl = function mediaDataUrl(hashedId) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var host = (0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__/* .mediaDataHost */ .Dd)(options);
  return "".concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__/* .eV1Protocol */ .v9)(), "//").concat(host, "/embed/medias/").concat(hashedId, ".json");
};
var mediaDataScriptRegExp = function mediaDataScriptRegExp(hashedId) {
  var protocolMatch = location.protocol === 'https:' ? 'https' : 'https?';
  return new RegExp("^(".concat(protocolMatch, ":)?//((").concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__/* .cdnFastWistiaComHost */ .CX)().replace('.', '\\.'), ")|(").concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_5__/* .cdnFastWistiaNetHost */ .kh)().replace('.', '\\.'), "))/embed/medias/").concat(hashedId, "\\.jsonp\\??"));
};
var cacheMedia = function cacheMedia(hashedId, data) {
  return cacheMediaData(hashedId, data);
};
var uncacheMedia = function uncacheMedia(hashedId) {
  var _Wistia$uncacheCaptio;
  uncacheMediaData(hashedId);
  (_Wistia$uncacheCaptio = Wistia.uncacheCaptions) === null || _Wistia$uncacheCaptio === void 0 ? void 0 : _Wistia$uncacheCaptio.call(Wistia, hashedId);
  removeSpeedDemonScriptAndData(hashedId);
};
var removeSpeedDemonScriptAndData = function removeSpeedDemonScriptAndData(hashedId) {
  window["wistiajsonp-/embed/medias/".concat(hashedId, ".json")] = null;
  removeScriptsBySrc(mediaDataUrl(hashedId), {
    scriptRegex: mediaDataScriptRegExp(hashedId)
  });
};
var mediaFromCache = function mediaFromCache(hashedId) {
  return dataFromCache(hashedId);
};
var dataFromCache = function dataFromCache(hashedId) {
  var resultFromFetchCache = getMediaDataFromCache(hashedId);
  if (resultFromFetchCache) {
    return resultFromFetchCache;
  }
  var speedDemonData = root["wistiajsonp-/embed/medias/".concat(hashedId, ".json")];
  if (speedDemonData != null && speedDemonData.media) {
    return speedDemonData.media;
  }
  return null;
};

/***/ }),

/***/ 1919:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ standardSvgAttrs)
/* harmony export */ });
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var standardSvgAttrs = function standardSvgAttrs(_ref) {
  var _ref$width = _ref.width,
    width = _ref$width === void 0 ? 40 : _ref$width,
    _ref$height = _ref.height,
    height = _ref$height === void 0 ? 34 : _ref$height,
    _ref$styleOverride = _ref.styleOverride,
    styleOverride = _ref$styleOverride === void 0 ? {} : _ref$styleOverride,
    _ref$ariaHidden = _ref.ariaHidden,
    ariaHidden = _ref$ariaHidden === void 0 ? false : _ref$ariaHidden,
    _ref$fillColor = _ref.fillColor,
    fillColor = _ref$fillColor === void 0 ? '#ffffff' : _ref$fillColor;
  return {
    x: '0px',
    y: '0px',
    viewBox: "0 0 ".concat(width, " ").concat(height),
    'enable-background': "new 0 0 ".concat(width, " ").concat(height),
    'aria-hidden': "".concat(!!ariaHidden),
    style: _objectSpread({
      fill: fillColor,
      height: '100%',
      left: 0,
      strokeWidth: 0,
      top: 0,
      width: '100%'
    }, styleOverride)
  };
};

/***/ }),

/***/ 2147:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ removeInjectedJsonLd),
/* harmony export */   g: () => (/* binding */ injectJsonLd)
/* harmony export */ });
/* harmony import */ var utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3441);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_hosts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5857);
/* harmony import */ var utilities_assets_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7209);
/* harmony import */ var utilities_url_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2671);
/* harmony import */ var _iso8601Helper_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7229);
/* harmony import */ var _normalizeChapters_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9128);







var generateAudioJsonLd = function generateAudioJsonLd(mediaData) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var videoWidth = options.videoWidth,
    videoHeight = options.videoHeight;
  var embedOptions = options.embedOptions;
  if (!embedOptions) {
    embedOptions = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .cast */ .wg)((0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(mediaData.embedOptions));
  }
  var obj = {
    '@context': 'http://schema.org/',
    '@id': "https://".concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_1__/* .cdnFastWistiaNetHost */ .kh)(), "/embed/iframe/").concat(mediaData.hashedId),
    '@type': 'AudioObject',
    duration: "PT".concat((0,_iso8601Helper_ts__WEBPACK_IMPORTED_MODULE_4__/* .secondsToIso8601Duration */ .J)(mediaData.duration)),
    name: mediaData.name,
    thumbnailUrl: (0,utilities_assets_js__WEBPACK_IMPORTED_MODULE_2__/* .stillUrl */ .Wz)(mediaData.assets, {
      ext: 'jpg',
      protocol: 'https:',
      videoWidth: videoWidth,
      videoHeight: videoHeight,
      embedHost: embedOptions.embedHost
    }),
    contentUrl: generateContentUrl(mediaData),
    embedUrl: generateEmbedUrl(mediaData, embedOptions),
    uploadDate: new Date(mediaData.createdAt * 1000).toISOString(),
    description: mediaData.seoDescription
  };

  // multilingual captions should come as array of transcript objects.
  if (mediaData.captions && mediaData.captions[0]) {
    obj.transcript = mediaData.captions[0].text;
  }
  return obj;
};
var generateEmbedUrl = function generateEmbedUrl(mediaData, embedOptions) {
  var _mediaData$embedOptio;
  var baseUrl = "https://".concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_1__/* .cdnFastWistiaNetHost */ .kh)(), "/embed/iframe/").concat(mediaData.hashedId);
  // if we're doing SeekToAction for Google KeyMoments AND video thumbnail
  // is enabled, we need to attach a query param so that it is disabled when
  // Google tries to crawl it
  if ((0,utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__/* .shouldAddKeyMoments */ .Vq)(mediaData, embedOptions) && !(0,utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__/* .shouldAddClipsFromChapters */ .Qy)(embedOptions) && (_mediaData$embedOptio = mediaData.embedOptions.plugin) !== null && _mediaData$embedOptio !== void 0 && _mediaData$embedOptio.videoThumbnail) {
    return "".concat(baseUrl, "?wseektoaction=true");
  }
  return baseUrl;
};

// Google has been struggling with Key Moments using our normal iframe pages as the embedUrl
// and have asked us to use a contentUrl with a direct m3u8 asset instead.
var generateContentUrl = function generateContentUrl(mediaData) {
  var assets = mediaData.assets;
  if (mediaData.mediaType === 'Audio') {
    var _readyPublicMp3s$;
    return (_readyPublicMp3s$ = (0,utilities_assets_js__WEBPACK_IMPORTED_MODULE_2__/* .readyPublicMp3s */ .o2)(assets)[0]) === null || _readyPublicMp3s$ === void 0 ? void 0 : _readyPublicMp3s$.url;
  }
  var availableMp4s = (0,utilities_assets_js__WEBPACK_IMPORTED_MODULE_2__/* .readyPublicMp4s */ .Fi)(assets);
  if (availableMp4s.length === 0) {
    return;
  }
  var highestQuality = (0,utilities_assets_js__WEBPACK_IMPORTED_MODULE_2__/* .findClosestAssetByQuality */ .tt)(availableMp4s, 1080);
  if (!highestQuality) {
    return;
  }
  var url = new utilities_url_js__WEBPACK_IMPORTED_MODULE_3__/* .Url */ .s0(highestQuality.url);
  url.ext('m3u8');
  return url.absolute();
};
var generateVideoJsonLd = function generateVideoJsonLd(mediaData) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var videoWidth = options.videoWidth,
    videoHeight = options.videoHeight;
  var embedOptions = options.embedOptions;
  if (!embedOptions) {
    embedOptions = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .cast */ .wg)((0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(mediaData.embedOptions));
  }
  var obj = {
    '@context': 'http://schema.org/',
    '@id': "https://".concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_1__/* .cdnFastWistiaNetHost */ .kh)(), "/embed/iframe/").concat(mediaData.hashedId),
    '@type': 'VideoObject',
    duration: "PT".concat((0,_iso8601Helper_ts__WEBPACK_IMPORTED_MODULE_4__/* .secondsToIso8601Duration */ .J)(mediaData.duration)),
    name: mediaData.name,
    thumbnailUrl: (0,utilities_assets_js__WEBPACK_IMPORTED_MODULE_2__/* .stillUrl */ .Wz)(mediaData.assets, {
      ext: 'jpg',
      protocol: 'https:',
      videoWidth: videoWidth,
      videoHeight: videoHeight,
      embedHost: embedOptions.embedHost
    }),
    embedUrl: generateEmbedUrl(mediaData, embedOptions),
    uploadDate: new Date(mediaData.createdAt * 1000).toISOString(),
    description: mediaData.seoDescription
  };

  // LiveStream Medias should not get content urls as we might not have any video assets available
  if (mediaData.mediaType === 'Video') {
    obj.contentUrl = generateContentUrl(mediaData);
  }

  // multilingual captions should come as array of transcript objects. Like
  // Scar in Lion King, we should Be Prepared!
  if (mediaData.captions && mediaData.captions[0]) {
    obj.transcript = mediaData.captions[0].text;
  }
  if ((0,utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__/* .shouldAddKeyMoments */ .Vq)(mediaData, embedOptions)) {
    // keyMoments come in two flavors.
    // A. If we have chapters, then we will manually define the key moments via the "Clip" schema property
    // B. If we don't, we will use the "SeekToAction" property that lets google parse via `wtime`
    if ((0,utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__/* .shouldAddClipsFromChapters */ .Qy)(embedOptions)) {
      var chapters = (0,_normalizeChapters_ts__WEBPACK_IMPORTED_MODULE_6__/* .normalizeChapters */ .a)(embedOptions);
      var chapterList = chapters.chapterList;
      obj.hasPart = (0,utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__/* .clipsFromChapters */ .oG)(chapterList, location.href, mediaData.duration);
    } else {
      obj.potentialAction = (0,utilities_keyMoments_ts__WEBPACK_IMPORTED_MODULE_5__/* .seekToAction */ .CR)();
    }
  }
  return obj;
};
var injectJsonLd = function injectJsonLd(id, mediaData) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var jsonLdObj;
  if (mediaData.mediaType === 'Audio') {
    jsonLdObj = generateAudioJsonLd(mediaData, options);
  } else {
    jsonLdObj = generateVideoJsonLd(mediaData, options);
  }
  var stringified = JSON.stringify(jsonLdObj);
  var jsonLd = document.createElement('script');
  jsonLd.className = 'w-json-ld';
  jsonLd.type = 'application/ld+json';
  jsonLd.innerHTML = stringified;
  jsonLd._wistia = true;
  jsonLd.setAttribute('id', id);
  removeInjectedJsonLd(id);
  var existingScripts = document.querySelectorAll('script.w-json-ld');
  var existingScript = existingScripts[existingScripts.length - 1];
  if (existingScript) {
    // insert JSON-LD after last JSON-LD script we injected.
    existingScript.parentNode.insertBefore(jsonLd, existingScript.nextSibling);
  } else {
    // prepend JSON-LD to head if we don't see any others yet
    document.head.insertBefore(jsonLd, document.head.childNodes[0]);
  }
};
var removeInjectedJsonLd = function removeInjectedJsonLd(id) {
  if (!id) {
    return;
  }
  var el = document.getElementById(id);
  if (!el) {
    return;
  }
  el.remove();
};

/***/ }),

/***/ 2428:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ unescapeHtml)
/* harmony export */ });
var unescapedCache = {};
var unescapeHtml = function unescapeHtml(encodedHtmlStr) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!encodedHtmlStr) {
    return '';
  }
  if (options.cache) {
    var cachedVal = unescapedCache[encodedHtmlStr];
    if (unescapedCache[encodedHtmlStr]) {
      return cachedVal;
    }
  }
  var e = document.createElement('div');
  e.innerHTML = encodedHtmlStr.toString().replace(/</g, '&lt;').replace(/>/g, '&gt;');
  var result;
  if (e.childNodes.length > 0) {
    result = e.childNodes[0].nodeValue;
  } else {
    result = '';
  }
  if (options.cache) {
    unescapedCache[encodedHtmlStr] = result;
  }
  return result;
};

/***/ }),

/***/ 2621:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports initializeSentry, reportError, listenForGlobalErrors, listenForGlobalUnhandledRejections */
/* harmony import */ var _trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4755);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);
/* harmony import */ var _hosts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5857);





var getSampleRatesByProductType = function getSampleRatesByProductType(productType) {
  /* eslint-disable @typescript-eslint/no-magic-numbers */
  switch (productType) {
    case 'carousel':
    case 'playlist':
      return 1;
    case 'channel':
    case 'form':
    case 'transcript':
      return 0.25;
    case 'globalListener':
    case 'other':
    case 'player':
    default:
      // Setting a low sample rate here as a precaution against blowing up Sentry with player errors
      // Ideally we can keep increasing this.
      return 0.01;
  }
  /* eslint-enable @typescript-eslint/no-magic-numbers */
};
var IS_DEV_ENV = (/* unused pure expression or super */ null && ("production" === 'development'));
var IS_TEST_ENV = (/* unused pure expression or super */ null && ("production" === 'test'));
var configureSentry = function configureSentry() {
  if (isNil(window.Sentry) || isNil(window.Sentry.BrowserClient) || isNil(window.Sentry.makeFetchTransport) || isNil(window.Sentry.defaultStackParser) || isNil(window.Sentry.Scope)) {
    return;
  }

  /**
   * Since the webpages our code is embedded in might have their own Sentry instances defined,
   * we cannot use Sentry.init();
   *
   * Instead, we can follow the example provided by Sentry (https://docs.sentry.io/platforms/javascript/best-practices/shared-environments/)
   * and create our own client that we use to report errors. This will prevent any Wistia exceptions
   * from being logged in customer Sentry instances, and it should also help prevent our Sentry instance
   * from picking up exceptions in customer code.
   */
  var client = new window.Sentry.BrowserClient({
    dsn: 'https://a3591ba5e949a37083cc6f5a4191e903@o4505518331658240.ingest.us.sentry.io/4505794284290048',
    transport: window.Sentry.makeFetchTransport,
    stackParser: window.Sentry.defaultStackParser,
    integrations: [],
    release: isNonEmptyString(TAGGED_VERSION) ? TAGGED_VERSION : CURRENT_SHA
  });
  var scope = new window.Sentry.Scope();
  scope.setClient(client);
  scope.setTags({
    pillar: 'publish'
  });
  Wistia._sentryScope = scope;
  client.init(); // initializing has to be done after setting the client on the scope

  Wistia.isSentryInitialized = true;

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  listenForGlobalErrors();
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  listenForGlobalUnhandledRejections();
};
var initializeSentry = function initializeSentry() {
  if (isVisitorTrackingEnabled() !== true) {
    return;
  }
  if (!window.Sentry || !Wistia.isSentryInitialized) {
    var sentryLoader = document.createElement('script');
    /**
     * Using the Sentry loader script means Sentry will init a second time after
     * our own call to init inside configureSentry(). The second init will include
     * all the default Sentry integrations, which we do not want.
     *
     * Instead of using the loader script, we can load the bundle directly
     * and configure the client when the script loads. This allows us to maintain
     * our own Sentry client without worrying about it colliding with customer instances of Sentry.
     *
     */
    sentryLoader.src = 'https://browser.sentry-cdn.com/9.6.1/bundle.min.js';
    sentryLoader.crossOrigin = 'anonymous';
    sentryLoader.integrity = 'sha384-kbRmCeIl7Uxr+vT9YhSAdguCdd4L5QPRj7jzQTanorUVVlw/Y5X9vtzVyOEHLfpH';
    sentryLoader.onload = function () {
      return configureSentry();
    };
    document.head.appendChild(sentryLoader);
  }
};
var reportError = function reportError(product, error, details) {
  try {
    if (!Wistia.isSentryInitialized) {
      return;
    }
    var sampleRate = getSampleRatesByProductType(product);
    if (IS_DEV_ENV) {
      console.error(error); // eslint-disable-line no-console
      return;
    }
    if (IS_TEST_ENV) {
      // Do nothing
      return;
    }
    var shouldSendToSentry = false;
    var cryptoObj = isNil(window.crypto) ? window.msCrypto : window.crypto;
    if (cryptoObj !== undefined) {
      var cryptoRandom = cryptoObj.getRandomValues(new Uint32Array(1));
      // eslint-disable-next-line @typescript-eslint/no-magic-numbers
      shouldSendToSentry = cryptoRandom[0] / (0xffffffff + 1) < sampleRate;
    } else {
      var mathRandom = Math.random();
      shouldSendToSentry = mathRandom < sampleRate;
    }
    if (!shouldSendToSentry) {
      // If we shouldn't send to Sentry, just print to the console
      console.error(error); // eslint-disable-line no-console
      // trackingConsentApi is not yet converted to TS
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    } else if (isVisitorTrackingEnabled()) {
      // The Sentry docs indicate that we can pass context in a few different ways (https://docs.sentry.io/platforms/javascript/enriching-events/context/#passing-context-directly)
      // Those examples do not actually seem to work.
      // Instead, we will clear out the scope each time we report a new exception and manually re-create it.
      Wistia._sentryScope.clear();
      Wistia._sentryScope.setTag('pillar', 'publish');
      Wistia._sentryScope.setTag('product', product);
      if (isNonEmptyRecord(details)) {
        Wistia._sentryScope.setTags(details);
      }
      Wistia._sentryScope.captureException(error);
    }
  } catch (err) {
    // We don't want any problems with our error logging to break other things,
    // so we'll just print this to the console.
    console.error(err); // eslint-disable-line no-console
  }
};
var globalErrorHandler = function globalErrorHandler(event) {
  var _event$error$source, _event$error;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  var eventError = event.error;
  if (!(eventError instanceof Error)) {
    return;
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
  var eventErrorSource = (_event$error$source = (_event$error = event.error) === null || _event$error === void 0 ? void 0 : _event$error.source) !== null && _event$error$source !== void 0 ? _event$error$source : '';
  var fastHostName = appHostname('fast');
  // Filter out any global errors that didn't originate from Wistia code
  if (eventErrorSource.includes(fastHostName)) {
    reportError('globalListener', eventError);
  }
};
var globalUnhandledRejectionHandler = function globalUnhandledRejectionHandler(event) {
  var _event$reason$stack, _event$reason;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  var eventReason = event.reason;
  if (!(eventReason instanceof Error)) {
    return;
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
  var eventReasonStack = (_event$reason$stack = (_event$reason = event.reason) === null || _event$reason === void 0 ? void 0 : _event$reason.stack) !== null && _event$reason$stack !== void 0 ? _event$reason$stack : '';
  // Filter out any unhandled rejections that didn't originate from Wistia code
  if (eventReasonStack.includes(appHostname('fast'))) {
    reportError('globalListener', eventReason);
  }
};
var listenForGlobalErrors = function listenForGlobalErrors() {
  if (!Wistia._isListeningForGlobalErrors) {
    window.addEventListener('error', globalErrorHandler);
    Wistia._isListeningForGlobalErrors = true;
  }
};
var listenForGlobalUnhandledRejections = function listenForGlobalUnhandledRejections() {
  if (!Wistia._isListeningForGlobalUnhandledRejections) {
    window.addEventListener('unhandledrejection', globalUnhandledRejectionHandler);
    Wistia._isListeningForGlobalUnhandledRejections = true;
  }
};

/***/ }),

/***/ 2671:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ff: () => (/* binding */ proto),
/* harmony export */   s0: () => (/* binding */ Url)
/* harmony export */ });
/* unused harmony exports queryParamsToObject, urlComponentToObject, objectToQueryParams, splitPath, joinPath, brack, debrack, createUrl, parseUrl */
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_wlog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6637);


var proto = function proto() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : location.href;
  if (/^http:\/\//.test(url)) {
    return 'http:';
  }
  return 'https:';
};

// decompose the raw query params into a JSON object
// root[level1][level2][level3] to deep set
// param[a]=1&param[a]=2 to create an array
var queryParamsToObject = function queryParamsToObject(raw) {
  // get each key/val pair separated by &
  var result = {};
  if (!raw) {
    return result;
  }
  var parts = raw.split('&');
  var _loop = function _loop() {
    var part = parts[i];

    // break up key/vals
    var pair = part.split('=');
    var key = pair[0];
    var val = pair[1];
    try {
      key = debrack(decodeURIComponent(key)) || '';
    } catch (e) {
      // log on a timeout so that wlog has a chance to set its level from page
      // url.
      setTimeout(function () {
        utilities_wlog_js__WEBPACK_IMPORTED_MODULE_1__/* .wlog */ .ct.notice(e);
      }, 50);
      key = '';
    }

    // deep cast each piece of the key (e.g. "foo.1" yields ["foo", 1])
    (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .cast */ .wg)(key);

    // if the key already exists in params
    var existing = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .getDeep */ .b$)(result, key);
    if (existing != null) {
      // make this value an array of same-name params
      if ((0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(existing)) {
        existing.push(urlComponentToObject(val));
      } else {
        var arr = [existing];
        arr.push(urlComponentToObject(val));
        (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .setAndPreserveUndefined */ .mA)(result, key, arr);
      }
    } else {
      // otherwise save key/val
      (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .setAndPreserveUndefined */ .mA)(result, key, urlComponentToObject(val));
    }
  };
  for (var i = 0; i < parts.length; i++) {
    _loop();
  }

  // return the json object
  return result;
};

// Any val that starts with json:slashslash should have its data
// parsed as JSON.
var urlComponentToObject = function urlComponentToObject(val) {
  if (val == null) {
    return val;
  }
  var result;
  try {
    result = decodeURIComponent(val);
  } catch (e) {
    // log on a timeout so that wlog has a chance to set its level from page
    // url.
    setTimeout(function () {
      utilities_wlog_js__WEBPACK_IMPORTED_MODULE_1__/* .wlog */ .ct.notice(e);
    }, 50);
    result = val;
  }
  return result;
};
var objectToQueryParams = function objectToQueryParams(obj) {
  var result = [];
  (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .eachLeaf */ .Cs)(obj, function (leafVal, path) {
    if (leafVal != null) {
      result.push("".concat(encodeURIComponent(brack(path)), "=").concat(encodeURIComponent(leafVal)));
    } else {
      result.push(encodeURIComponent(brack(path)));
    }
  });
  return result.join('&');
};
var splitPath = function splitPath(str) {
  var result = [];
  if (str == null) {
    return result;
  }
  var parts = str.split(/\/+/);
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    if (part != null && part !== '') {
      result.push(part);
    }
  }
  return result;
};

// `path` can be a string or an array of strings.
var joinPath = function joinPath(path) {
  if (typeof path === 'string') {
    path = path.split('/');
  }
  if (path == null) {
    return '';
  }
  return "/".concat(path.join('/'));
};

// convert array [abc, def, ghi] to bracketed format "abc[def][ghi]"
var brack = function brack(path) {
  var result = path[0];
  for (var i = 1; i < path.length; i++) {
    result += "[".concat(path[i], "]");
  }
  return result;
};

// convert "abc[def][ghi][jkl]" to array [abc, def, ghi, jkl]
var debrack = function debrack(str) {
  return str.match(/([\w\-_]+)/g);
};

/// /
// An object to represent an URL, and to make it easy to
// get/set various properties and parameters of the URL.
/// /
var URL_CONSTRUCTOR_KEYS = ['protocol', 'host', 'port', 'params', 'path'];
var Url = function Url(url) {
  var self = this;

  // if an url is supplied, parse. if it's an object, explicitly
  // set options. otherwise, just assume we're building an url
  // from scratch.
  var construct = function construct() {
    self.params = {};
    self.path = [];
    self.host = '';
    if (typeof url === 'object') {
      self.fromOptions(url);
    } else if (url) {
      self.fromRaw(url);
    }
  };
  construct();
};
var uproto = Url.prototype;
uproto.fromOptions = function (options) {
  for (var i = 0; i < URL_CONSTRUCTOR_KEYS.length; i++) {
    var opt = URL_CONSTRUCTOR_KEYS[i];
    if (options[opt] != null) {
      this[opt] = options[opt];
    }
  }
  return this;
};

// parse the url and save the info
uproto.fromRaw = function (raw) {
  this.rawUrl = raw;
  var match;

  // protocol
  match = raw.match(/^((?:https?:)|(?:file:)|(?:ftp:))?\/\//);
  if (match) {
    this.protocol = match[1] || undefined;
  }

  // host
  match = raw.match(/\/\/([^:?#/]*)/);
  if (match) {
    this.host = match[1] || undefined;
  }

  // path
  match = raw.match(/\/\/.*?(\/[^?#$]+)/) || raw.match(/(^\/[^/][^?#$]+)/);
  if (match) {
    this.setPath(match[1]);
  }

  // port
  match = raw.match(/:(\d+)/);
  if (match) {
    this.port = parseInt(match[1], 10);
  }

  // url parameters
  match = raw.match(/\?([^#]+)/);
  if (match) {
    this.rawParams = match[1];
    this.params = queryParamsToObject(this.rawParams);
  }

  // anchor
  match = raw.match(/#(.*)$/);
  if (match) {
    this.anchor = match[1];
  }
  return this;
};
uproto.clone = function () {
  return new Url({
    protocol: this.protocol,
    host: this.host,
    port: this.port,
    path: (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(this.path),
    params: (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(this.params),
    anchor: this.anchor
  });
};
uproto.ext = function (ext) {
  if (ext != null) {
    var current = this.ext();
    var i = this.path.length - 1;
    var regexp = new RegExp("\\.".concat(current), 'g');
    if (current) {
      this.path[i] = "".concat(this.path[i].replace(regexp, ''));
    }
    return this.path[i] = "".concat(this.path[i], ".").concat(ext);
  }
  var match = this.path[this.path.length - 1].match(/\.(.*)$/);
  return match != null && match[1] || null;
};

// accept loc for testing purposes
uproto.isRelative = function () {
  var loc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location;
  var proto = this.protocol;
  var host = this.host;
  return (proto == null || proto === '' || proto === loc.protocol) && (!host || host === loc.hostname);
};
uproto.toString = function () {
  if (this.isRelative()) {
    return this.relative();
  }
  return this.absolute();
};

// print this url object as a simple string
// choose sane defaults if parts aren't specified
uproto.absolute = function () {
  var protocolPart = '';
  if (this.protocol != null) {
    protocolPart = this.protocol;
  }
  var portPart = '';
  if (this.port != null) {
    portPart = ":".concat(this.port);
  }
  return "".concat(protocolPart, "//").concat(this.host || location.host).concat(portPart).concat(this.relative());
};
uproto.relative = function () {
  var pathPart = '';
  if (this.path.length > 0) {
    pathPart = joinPath(this.path);
    if (this._hasTrailingSlash) {
      pathPart += '/';
    }
  }
  var paramPart = "?".concat(objectToQueryParams(this.params));
  if (paramPart.length === 1) {
    paramPart = '';
  }
  return "".concat(pathPart).concat(paramPart).concat(this.relativeAnchor());
};
uproto.authority = function () {
  var portPart = this.port != null ? ":".concat(this.port) : '';
  return "".concat(this.host).concat(portPart);
};
uproto.relativeProtocol = function () {
  var portPart = '';
  if (this.port != null) {
    portPart = ":".concat(this.port);
  }
  return "//".concat(this.host).concat(portPart).concat(this.relative());
};
uproto.relativeAnchor = function () {
  var anchorPart = '';
  if (this.anchor != null) {
    anchorPart = "#".concat(this.anchor);
  }
  return "".concat(anchorPart);
};
uproto.setPath = function (rawPath) {
  this.rawPath = rawPath;
  this._hasTrailingSlash = /\/$/.test(this.rawPath);
  this.path = splitPath(this.rawPath);
};

// create some aliases in Url to create/parse URLs
Url.create = function (options) {
  return new Url(options);
};
var createUrl = Url.create;
Url.parse = function (str) {
  return new Url(str);
};
var parseUrl = Url.parse;

/***/ }),

/***/ 2694:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ EventShepherd),
/* harmony export */   h: () => (/* binding */ convertedEventNames)
/* harmony export */ });
/* harmony import */ var _eventConstants_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2760);
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

// some legacy events are converted to a different name when they are added to the event listener
var convertedEventNames = {
  mutechange: _eventConstants_ts__WEBPACK_IMPORTED_MODULE_0__/* .MUTE_CHANGE_EVENT */ .Gd
};

// some legacy events have a different detail structure than the new ones
// this is a mapping of the old detail structure to the new one
var callbackDetailsConversions = {
  mutechange: function mutechange(detail) {
    return detail.isMuted;
  }
};
var EventShepherd = /*#__PURE__*/function () {
  function EventShepherd() {
    _classCallCheck(this, EventShepherd);
    _defineProperty(this, "convertedEventsMap", {});
  }
  return _createClass(EventShepherd, [{
    key: "addListener",
    value: function addListener(eventName, element, callback) {
      var _convertedEventNames$;
      // if the event name is not in the convertedEventNames map, use the event name as is
      // this accounts for legacy events that do not have kebab-case names
      var normalizedEventName = (_convertedEventNames$ = convertedEventNames[eventName]) !== null && _convertedEventNames$ !== void 0 ? _convertedEventNames$ : eventName;

      // if the event name is not in the convertedEventsMap, initialize an empty array
      if (!this.convertedEventsMap[normalizedEventName]) {
        this.convertedEventsMap[normalizedEventName] = [];
      }
      var eventListenerCallback = function eventListenerCallback(customEvent) {
        // if the callbackDetailsConversions map has a conversion function for the event name, use it.
        // for example, the mute-change event has a detail of { isMuted: boolean }, but the legacy event just passes a boolean
        if (callbackDetailsConversions[eventName]) {
          var convertedDetail = callbackDetailsConversions[eventName](customEvent.detail);
          callback(convertedDetail);
        } else {
          callback();
        }
      };

      // we have to store the callback and the event listener callback separately because:
      // 1. to properly remove the event listener, we need to have a reference to the event listener callback
      // 2. we need to match against the given callback to remove the correct listener
      this.convertedEventsMap[normalizedEventName].push({
        givenCallback: callback,
        eventListenerCallback: eventListenerCallback
      });

      // add the event listener to the element
      element.addEventListener(normalizedEventName, eventListenerCallback);
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(element) {
      var _this = this;
      Object.keys(this.convertedEventsMap).forEach(function (eventName) {
        var _this$convertedEvents;
        (_this$convertedEvents = _this.convertedEventsMap[eventName]) === null || _this$convertedEvents === void 0 ? void 0 : _this$convertedEvents.forEach(function (storedCallbacks) {
          element.removeEventListener(eventName, storedCallbacks.eventListenerCallback);
        });
        _this.convertedEventsMap[eventName] = [];
      });
    }
  }, {
    key: "removeListener",
    value: function removeListener(eventName, element, callback) {
      var _convertedEventNames$2,
        _this2 = this;
      var normalizedEventName = (_convertedEventNames$2 = convertedEventNames[eventName]) !== null && _convertedEventNames$2 !== void 0 ? _convertedEventNames$2 : eventName;
      var indexesToRemove = [];
      if (callback) {
        element.removeEventListener(normalizedEventName, callback);
        if (this.convertedEventsMap[normalizedEventName]) {
          this.convertedEventsMap[normalizedEventName].forEach(function (storedCallbacks, index) {
            if (storedCallbacks.givenCallback === callback) {
              indexesToRemove.push(index);
              element.removeEventListener(normalizedEventName, storedCallbacks.eventListenerCallback);
            }
          });

          // remove the bindings entirely
          indexesToRemove.forEach(function (index) {
            if (_this2.convertedEventsMap[normalizedEventName]) {
              _this2.convertedEventsMap[normalizedEventName].splice(index, 1);
            }
          });
        }
      } else {
        this.convertedEventsMap[normalizedEventName] = [];
      }
    }
  }]);
}();

/***/ }),

/***/ 2721:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ usePlayerData),
/* harmony export */   z: () => (/* binding */ PlayerDataProvider)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3817);


var PlayerDataContext = (0,preact__WEBPACK_IMPORTED_MODULE_0__/* .createContext */ .q6)(null);
var PlayerDataProvider = function PlayerDataProvider(_ref) {
  var children = _ref.children,
    embedOptions = _ref.embedOptions,
    mediaData = _ref.mediaData;
  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(PlayerDataContext.Provider, {
    value: {
      embedOptions: embedOptions,
      mediaData: mediaData
    }
  }, children);
};
var usePlayerData = function usePlayerData() {
  var context = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useContext */ .NT)(PlayerDataContext);
  if (context == null) {
    throw new Error('usePlayerData must be used within a PlayerDataProvider');
  }
  return context;
};

/***/ }),

/***/ 2760:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $1: () => (/* binding */ AFTER_REPLACE_EVENT),
/* harmony export */   Gd: () => (/* binding */ MUTE_CHANGE_EVENT),
/* harmony export */   c5: () => (/* binding */ API_READY_EVENT),
/* harmony export */   dp: () => (/* binding */ IMPL_CREATED_EVENT),
/* harmony export */   iP: () => (/* binding */ INTERNAL_API_ON_FIND_EVENT),
/* harmony export */   kY: () => (/* binding */ BEFORE_REPLACE_EVENT),
/* harmony export */   rO: () => (/* binding */ LOADED_MEDIA_DATA_EVENT),
/* harmony export */   ve: () => (/* binding */ INPUT_CONTEXT_CHANGE_EVENT)
/* harmony export */ });
/* unused harmony exports BETWEENTIMES_EVENT_EV1, CROSSTIME_EVENT_EV1, INIT_EMBED_EVENT */
var AFTER_REPLACE_EVENT = 'after-replace';
var API_READY_EVENT = 'api-ready';
var BEFORE_REPLACE_EVENT = 'before-replace';
var BETWEENTIMES_EVENT_EV1 = 'betweentimes';
var CROSSTIME_EVENT_EV1 = 'crosstime';
var IMPL_CREATED_EVENT = 'impl-created';
var INIT_EMBED_EVENT = 'initembed';
var INPUT_CONTEXT_CHANGE_EVENT = 'input-context-change';
var INTERNAL_API_ON_FIND_EVENT = 'internal-api-on-find';
var LOADED_MEDIA_DATA_EVENT = 'loaded-media-data';
var MUTE_CHANGE_EVENT = 'mute-change';

/***/ }),

/***/ 2917:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lg: () => (/* binding */ getLocalStorage),
/* harmony export */   yo: () => (/* binding */ updateLocalStorage)
/* harmony export */ });
/* unused harmony exports removeLocalStorage, setLocalStorage */
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);


/*
 * This module is designed as a simpler version of our old localStorage
 * utility.  To reduce potential bundle size, it doesn't make use of Obj
 * utilities or wlog, and doesn't return early based on browser detection.
 *
 * To avoid multiple tab bugs, it does not try to do any kind of commit
 * debouncing. Every call to `set` involves JSON.serialize() and every call to
 * `get` involves JSON.parse(). Therefore, if you are performing many
 * operations, you should cache an intermediate value. The
 * updateLocalStorage function is also provided for doing many updates
 * with a single parse and serialize call.
 *
 * If you are working with localStorage on something that requires lots of
 * updates, you should use a separate namespace. That way there is less to
 * deserialize and serialize on each read and write.
 */

var throwAsync = function throwAsync(e) {
  setTimeout(function () {
    throw e;
  }, 0);
};
var OBJ_PROP = '_namespacedLocalStorage';
var localStorageWorks = function localStorageWorks() {
  var ns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'wistia-test-localstorage';
  if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._localStorageWorks != null) {
    return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._localStorageWorks;
  }
  try {
    // no-ops that test get, set, and remove. These may throw an exception
    // in Private Browsing mode on iOS and Safari.
    var currentVal = localStorage.getItem(ns);
    localStorage.removeItem(ns);
    localStorage.setItem(ns, currentVal);
    localStorage.removeItem(ns);
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._localStorageWorks = true;
  } catch (e) {
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._localStorageWorks = false;
  }
  return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._localStorageWorks;
};

// Gets our memory store, which we use in parallel with localStorage in case
// localStorage is disabled. In some browsers and situations, disabled
// localStorage will throw exceptions.
var getMemory = function getMemory() {
  if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s[OBJ_PROP] == null) {
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s[OBJ_PROP] = {};
  }
  return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s[OBJ_PROP];
};
var getLocalStorage = function getLocalStorage(ns) {
  if (!localStorageWorks()) {
    return getMemory()[ns] || {};
  }
  if (localStorage[ns]) {
    try {
      if (localStorage[ns] === 'null') {
        // "null" is valid JSON, and JSON.parse("null") will return null, which
        // isn't usable for our purposes at all.
        return {};
      }
      return JSON.parse(localStorage[ns]);
    } catch (e) {
      throwAsync(e);
    }
  }
  return {};
};
var removeLocalStorage = function removeLocalStorage(ns) {
  if (!localStorageWorks()) {
    getMemory()[ns] = {};
    return;
  }
  try {
    localStorage.removeItem(ns);
  } catch (e) {
    throwAsync(e);
  }
};
var setLocalStorage = function setLocalStorage(ns, obj) {
  if (!localStorageWorks()) {
    if (obj != null && typeof obj === 'object') {
      getMemory()[ns] = obj;
    }
    return obj;
  }
  try {
    // We set Wistia._localStorage for compatibility with the old localStorage util,
    // which would otherwise overwrite any changes we make. :0
    getMemory()[ns] = obj;
    localStorage[ns] = JSON.stringify(obj);
  } catch (e) {
    throwAsync(e);

    // TODO: We might want some strategy of dealing with QuotaExceededError
    // exceptions. Ideally we'd be really smart about pruning, but our other
    // options are (a) just don't update localStorage (that's what we're
    // doing now), or (b) clobber our localStorage to see if that helps.
  }
  return obj;
};
var updateLocalStorage = function updateLocalStorage(ns, fn) {
  var obj = getLocalStorage(ns);

  // fn() may throw an exception. we catch and report because we don't want
  // an exception after modifying in-place localStorage to get our local store
  // out of sync.
  try {
    fn(obj);
  } catch (e) {
    throwAsync(e);
  }
  return setLocalStorage(ns, obj);
};

/***/ }),

/***/ 3065:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   j: () => (/* binding */ fetchMediaData)
/* harmony export */ });
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4586);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);
/* harmony import */ var _hosts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5857);
/* harmony import */ var _media_data_transforms_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3917);
/* harmony import */ var _remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3411);
/* harmony import */ var _mediaDataError_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(959);
/* harmony import */ var _embeds_wistiaPlayer_utilities_getPreferredLanguageIndex_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4400);
/* harmony import */ var _viewerPreferences_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7438);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }








var fetchUnlocalizedMediaData = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(hashedId) {
    var _options$channelPassw, _options$plugin, _options$plugin$passw;
    var options,
      cacheKey,
      mediaDataFromCache,
      host,
      url,
      channelPasswordParam,
      promise,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          cacheKey = hashedId;
          mediaDataFromCache = (0,_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_3__/* .getMediaDataFromCache */ .F2)(cacheKey);
          if (!(mediaDataFromCache && options.skipCache !== true)) {
            _context.next = 5;
            break;
          }
          return _context.abrupt("return", Promise.resolve(mediaDataFromCache));
        case 5:
          if (!((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_5__/* .isNotNil */ .n9)(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._mediaDataPromises[cacheKey]) && options.skipCache !== true)) {
            _context.next = 7;
            break;
          }
          return _context.abrupt("return", _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._mediaDataPromises[cacheKey]);
        case 7:
          host = (0,_hosts_js__WEBPACK_IMPORTED_MODULE_1__/* .mediaDataHost */ .Dd)(options);
          url = new window.URL("https://".concat(host, "/embed/medias/").concat(hashedId, ".json"));
          if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_5__/* .isNotNil */ .n9)(options.channelId)) {
            url.searchParams.set('channelId', options.channelId.toString());
          }
          channelPasswordParam = (_options$channelPassw = options.channelPassword) !== null && _options$channelPassw !== void 0 ? _options$channelPassw : (_options$plugin = options.plugin) === null || _options$plugin === void 0 ? void 0 : (_options$plugin$passw = _options$plugin.passwordProtectedChannel) === null || _options$plugin$passw === void 0 ? void 0 : _options$plugin$passw.password;
          if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_5__/* .isNotNil */ .n9)(channelPasswordParam)) {
            url.searchParams.set('channelPassword', channelPasswordParam);
          }
          if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_5__/* .isNotNil */ .n9)(options.password)) {
            url.searchParams.set('password', options.password);
          }
          if (options.deferFetchingToCarousel) {
            url.searchParams.set('defer_fetching_to_carousel', 'true');
          }
          promise = fetch(url.href).then(function (resp) {
            return resp.json();
          }).then(function (response) {
            var _mediaData$hashedId;
            if ((0,_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_6__/* .isMediaDataError */ .V)(response)) {
              return response;
            }
            var _ref2 = response,
              mediaData = _ref2.media;
            (0,_media_data_transforms_js__WEBPACK_IMPORTED_MODULE_2__/* .mediaDataTransforms */ .M)(mediaData, options);
            (0,_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_3__/* .cacheMediaData */ .ry)((_mediaData$hashedId = mediaData.hashedId) !== null && _mediaData$hashedId !== void 0 ? _mediaData$hashedId : '', mediaData);
            return mediaData;
          }).finally(function () {
            Reflect.deleteProperty(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._mediaDataPromises, cacheKey);
          });
          _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._mediaDataPromises[cacheKey] = promise;
          return _context.abrupt("return", promise);
        case 17:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function fetchUnlocalizedMediaData(_x) {
    return _ref.apply(this, arguments);
  };
}();
var fetchMediaData = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hashedId) {
    var options,
      mediaDataOrError,
      mediaData,
      typedViewerPreferences,
      localizationViewerPreferences,
      preferredLanguages,
      uniquePreferredLanguages,
      preferredLanguageIndex,
      _navigator$languages,
      preferredLocalization,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
          _context2.next = 3;
          return fetchUnlocalizedMediaData(hashedId, options);
        case 3:
          mediaDataOrError = _context2.sent;
          if (!(0,_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_6__/* .isMediaDataError */ .V)(mediaDataOrError)) {
            _context2.next = 6;
            break;
          }
          return _context2.abrupt("return", mediaDataOrError);
        case 6:
          mediaData = mediaDataOrError;
          if (!(mediaData.localizations == null || mediaData.localizations.length === 0)) {
            _context2.next = 9;
            break;
          }
          return _context2.abrupt("return", mediaData);
        case 9:
          typedViewerPreferences = (0,_viewerPreferences_js__WEBPACK_IMPORTED_MODULE_4__/* .getViewerPreferences */ .hy)();
          localizationViewerPreferences = typedViewerPreferences.localization; // The order is meaningful here. Languages earlier in the array take priority
          // over those later in the array.
          preferredLanguages = [];
          if (options.overrideMediaLanguage != null) {
            preferredLanguages.push(options.overrideMediaLanguage);
          }
          if ((localizationViewerPreferences === null || localizationViewerPreferences === void 0 ? void 0 : localizationViewerPreferences.iso6392LanguageCode) != null) {
            preferredLanguages.push(localizationViewerPreferences.iso6392LanguageCode);
          }
          if (options.defaultMediaLanguage != null) {
            preferredLanguages.push(options.defaultMediaLanguage);
          }

          // Remove duplicates, keeping the first occurrence
          uniquePreferredLanguages = preferredLanguages.filter(function (lang, index) {
            return preferredLanguages.indexOf(lang) === index;
          }); // First look for exact iso639-2 language code matches
          preferredLanguageIndex = (0,_embeds_wistiaPlayer_utilities_getPreferredLanguageIndex_ts__WEBPACK_IMPORTED_MODULE_7__/* .getPreferredAvailableLanguageIndex */ .J)(mediaData.localizations.map(function (loc) {
            return loc.iso6392LanguageCode;
          }), uniquePreferredLanguages); // If none found, look for exact ietfLanguageTag matches
          if (preferredLanguageIndex === -1) {
            preferredLanguageIndex = (0,_embeds_wistiaPlayer_utilities_getPreferredLanguageIndex_ts__WEBPACK_IMPORTED_MODULE_7__/* .getPreferredAvailableLanguageIndex */ .J)(mediaData.localizations.map(function (loc) {
              return loc.ietfLanguageTag;
            }), uniquePreferredLanguages);
          }

          // If still no match, default to the browser language preferences
          if (preferredLanguageIndex === -1) {
            preferredLanguageIndex = (0,_embeds_wistiaPlayer_utilities_getPreferredLanguageIndex_ts__WEBPACK_IMPORTED_MODULE_7__/* .getPreferredAvailableLanguageIndex */ .J)(mediaData.localizations.map(function (loc) {
              return loc.iso6392LanguageCode;
            }), // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            _toConsumableArray((_navigator$languages = navigator.languages) !== null && _navigator$languages !== void 0 ? _navigator$languages : ['en']));
          }
          if (!(preferredLanguageIndex >= 0)) {
            _context2.next = 24;
            break;
          }
          preferredLocalization = mediaData.localizations[preferredLanguageIndex];
          if (!(mediaData.hashedId === preferredLocalization.hashedId)) {
            _context2.next = 23;
            break;
          }
          return _context2.abrupt("return", mediaData);
        case 23:
          return _context2.abrupt("return", fetchUnlocalizedMediaData(preferredLocalization.hashedId, _objectSpread({}, options)));
        case 24:
          return _context2.abrupt("return", mediaData);
        case 25:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function fetchMediaData(_x2) {
    return _ref3.apply(this, arguments);
  };
}();

/***/ }),

/***/ 3123:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JA: () => (/* binding */ getDefaultPlayerBorderRadius),
/* harmony export */   Ru: () => (/* binding */ getDefaultControlBarDistance),
/* harmony export */   gl: () => (/* binding */ getDefaultBigPlayButtonBorderRadius)
/* harmony export */ });
/* unused harmony exports CONTROL_BAR_DISTANCE_RATIO, getDefaultControlBarBorderRadius */
var BIG_PLAY_BUTTON_RADIUS_RATIO = 0.75;
var CONTROL_BAR_DISTANCE_RATIO = 0.75;
var FLOATING_CONTROL_BAR_RADIUS = 18;
var FLOATING_CONTROL_BAR_DISTANCE = 6;

/*

Rounded Player

These four methods determine the defaults for rounding the player.

- {roundedPlayer} - if it is the _only_ option, it is used as the base upon which all the other border radiuses are derived.
- {playerBorderRadius} - Determines the border radius of the thumbnail and outer parts of the player.
- {bigPlayButtonBorderRadius} - Border radius of the big play button.
- {controlBarBorderRadius} - Border radius of the control bar.
- {controlBarDistance} - Distance the control bar is from the edges of the player - also how far control bar dialogs are from the control bar.
- {floatingControlBar} - Boolean that can used to just create a floating control bar with border radius - no configuration.

*/

/**
 * Takes rounded player embed options and returns the calculated player border radius.
 * @param {EmbedOptions} embedOptions
 * @returns {number}
 */
var getDefaultPlayerBorderRadius = function getDefaultPlayerBorderRadius(_ref) {
  var playerBorderRadius = _ref.playerBorderRadius,
    roundedPlayer = _ref.roundedPlayer;
  if (roundedPlayer !== undefined) {
    return roundedPlayer;
  }
  if (playerBorderRadius !== undefined) {
    return playerBorderRadius;
  }
  return 0;
};

/**
 * Takes rounded player embed options and returns the calculated big play button border radius.
 * @param {EmbedOptions} embedOptions
 * @returns {number}
 */
var getDefaultBigPlayButtonBorderRadius = function getDefaultBigPlayButtonBorderRadius(_ref2) {
  var bigPlayButtonBorderRadius = _ref2.bigPlayButtonBorderRadius,
    roundedPlayer = _ref2.roundedPlayer;
  if (bigPlayButtonBorderRadius !== undefined) {
    return bigPlayButtonBorderRadius;
  }
  if (roundedPlayer !== undefined) {
    return roundedPlayer * BIG_PLAY_BUTTON_RADIUS_RATIO;
  }
  return 0;
};

/**
 * Takes rounded player embed options and returns the calculated control bar border radius.
 * @param {EmbedOptions} embedOptions
 * @returns {number}
 */
var getDefaultControlBarBorderRadius = function getDefaultControlBarBorderRadius(_ref3) {
  var controlBarBorderRadius = _ref3.controlBarBorderRadius,
    floatingControlBar = _ref3.floatingControlBar,
    roundedPlayer = _ref3.roundedPlayer;
  if (controlBarBorderRadius !== undefined) {
    return controlBarBorderRadius;
  }
  if (roundedPlayer !== undefined) {
    return roundedPlayer * CONTROL_BAR_DISTANCE_RATIO;
  }
  if (floatingControlBar === true) {
    return FLOATING_CONTROL_BAR_RADIUS;
  }
  return 0;
};

/**
 * Takes rounded player embed options and returns the calculated control bar distance.
 * @param {EmbedOptions} embedOptions
 * @returns {number}
 */
var getDefaultControlBarDistance = function getDefaultControlBarDistance(_ref4) {
  var controlBarBorderRadius = _ref4.controlBarBorderRadius,
    floatingControlBar = _ref4.floatingControlBar,
    roundedPlayer = _ref4.roundedPlayer;
  if (roundedPlayer !== undefined) {
    return roundedPlayer / 4;
  }
  if (controlBarBorderRadius !== undefined) {
    return controlBarBorderRadius / 2;
  }
  if (floatingControlBar === true) {
    return FLOATING_CONTROL_BAR_DISTANCE;
  }
  return 0;
};

/***/ }),

/***/ 3164:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ ProgressiveThumbnail)
/* harmony export */ });
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5181);
/* harmony import */ var utilities_hosts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5857);
/* harmony import */ var _Thumbnail_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5819);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == typeof e || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var ProgressiveThumbnail = /*#__PURE__*/function (_Component) {
  function ProgressiveThumbnail(props) {
    var _this;
    _classCallCheck(this, ProgressiveThumbnail);
    _this = _callSuper(this, ProgressiveThumbnail, [props]);
    _defineProperty(_this, "afterTwoSeconds", function () {
      // If we've waited 2 seconds for the thumbnail to load but it still hasn't
      // finished, then we guessed wrong about what the initial opacity should
      // be. Set it back to 0 so we do a slow fade when it's done loading.
      if (!_this._displayed && _this.state.normalThumbOpacity === 1) {
        _this.setState({
          normalThumbOpacity: 0
        });
      }
    });
    _defineProperty(_this, "onDisplayNormalThumb", function () {
      _this.setState({
        normalThumbOpacity: 1
      });
      _this._displayed = true;
      if (_this.onDisplay) {
        _this.onDisplay();
      }
    });
    _this.state = {
      normalThumbOpacity: props.isVisible ? 1 : 0
    };
    _this.onDisplay = props.onDisplay;
    return _this;
  }
  _inherits(ProgressiveThumbnail, _Component);
  return _createClass(ProgressiveThumbnail, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (!this.onDisplay && nextProps.onDisplay) {
        this.onDisplay = nextProps.onDisplay;
      }
    }
  }, {
    key: "render",
    value: function render() {
      if (this.props.isVisible) {
        this._hasRenderedVisible = true;
      }
      var sharedProps = {
        backgroundColor: this.props.backgroundColor,
        fitStrategy: this.props.fitStrategy,
        isVisible: this.props.isVisible,
        stillSnap: this.props.stillSnap,
        stretchLimit: this.props.stretchLimit,
        videoHeight: this.props.videoHeight,
        videoWidth: this.props.videoWidth,
        thumbnailAltText: this.props.thumbnailAltText,
        playerBorderRadius: this.props.playerBorderRadius
      };
      var swatchProps = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .assign */ .kp)({}, sharedProps, {
        ariaHidden: true,
        images: [{
          url: "".concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_2__/* .eV1Protocol */ .v9)(), "//").concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_2__/* .eV1Host */ .bC)(), "/embed/medias/").concat(this.props.hashedId, "/swatch")
        }]
      });
      var normalThumbProps = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .assign */ .kp)({}, sharedProps, {
        onDisplay: this.onDisplayNormalThumb,
        images: this.props.images
      });
      return (0,preact__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
        ref: this.props.elemRef
      }, this.props.swatchEnabled && this._hasRenderedVisible ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.h)(_Thumbnail_jsx__WEBPACK_IMPORTED_MODULE_3__/* .Thumbnail */ .V, _extends({}, swatchProps, {
        wrapperStyle: this.swatchWrapperStyle()
      })) : null, this._hasRenderedVisible ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.h)(_Thumbnail_jsx__WEBPACK_IMPORTED_MODULE_3__/* .Thumbnail */ .V, _extends({}, normalThumbProps, {
        wrapperStyle: this.normalThumbWrapperStyle()
      })) : null);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      setTimeout(this.afterTwoSeconds, 2000);
    }
  }, {
    key: "normalThumbWrapperStyle",
    value: function normalThumbWrapperStyle() {
      var transition = this.props.swatchEnabled && this.props.uiHasRendered && this.state.normalThumbOpacity === 1 ? 'opacity 3s' : '';
      return {
        height: '100%',
        left: 0,
        opacity: this.state.normalThumbOpacity,
        position: this.props.fitStrategy === 'naturalHeight' ? 'relative' : 'absolute',
        top: 0,
        transition: transition,
        width: '100%'
      };
    }
  }, {
    key: "swatchWrapperStyle",
    value: function swatchWrapperStyle() {
      return {
        filter: 'blur(5px)',
        height: '100%',
        left: 0,
        position: this.props.fitStrategy === 'naturalHeight' ? 'relative' : 'absolute',
        top: 0,
        width: '100%'
      };
    }
  }]);
}(preact__WEBPACK_IMPORTED_MODULE_1__/* .Component */ .uA);

/***/ }),

/***/ 3280:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gY: () => (/* binding */ setEmbedOptionStore),
/* harmony export */   iU: () => (/* binding */ removeEmbedOptionStore)
/* harmony export */ });
/* unused harmony exports OPTION_PREFIX, GLOBAL_ID_KEY, getEmbedOptionStore, getOrSetEmbedOptionStore */
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var _wistiaData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3997);
/* harmony import */ var _getApiHandles_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5510);



var OPTION_PREFIX = 'wistia_embed_options_';
var GLOBAL_ID_KEY = '__global__';

/**
 * Get the embed options for a given key or embed id
 * @param {string} id - The key or embed id
 * @param {Function} [matcherFn=getOneApiHandle] - Custom matcher function
 * @returns {object}
 */
var getEmbedOptionStore = function getEmbedOptionStore(id) {
  var matcherFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getOneApiHandle;
  // If options exist for the provided id, just return them
  if (wData([OPTION_PREFIX, id]) !== undefined) {
    return wData([OPTION_PREFIX, id]);
  }

  // Otherwise, lets check this key's api handle
  var apiHandleFromKey = matcherFn(id);
  if (apiHandleFromKey === null || apiHandleFromKey === 'removed') {
    return {};
  }
  // And compare it against all the other stored api handles
  if (wData(OPTION_PREFIX) !== undefined) {
    // If the api handles match, return the options for that key
    var matchedKey = Object.keys(wData(OPTION_PREFIX)).find(function (key) {
      return matcherFn(key) === apiHandleFromKey;
    });
    if (wData([OPTION_PREFIX, matchedKey]) !== undefined) {
      return wData([OPTION_PREFIX, matchedKey]);
    }
  }
  return {};
};

/**
 * Set the embed options for a given key or embed id
 * @param {string} id - The key or embed id
 * @param {object} options - The options to set
 * @returns {object}
 */
var setEmbedOptionStore = function setEmbedOptionStore(id, options) {
  if (options !== null) {
    return (0,_wistiaData_js__WEBPACK_IMPORTED_MODULE_1__/* .wData */ .m)([OPTION_PREFIX, id], (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .cast */ .wg)((0,_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(options)));
  }
  return {};
};

/**
 * Remove the embed options for a given key or embed id
 * @param {string} id - The key or embed id
 * @param {object} options - The options to set
 * @returns {void}
 */
var removeEmbedOptionStore = function removeEmbedOptionStore(id) {
  (0,_wistiaData_js__WEBPACK_IMPORTED_MODULE_1__/* .wRemoveData */ .S)([OPTION_PREFIX, id]);
};

/**
 * Legacy behavior replacement for Wistia.options - Get or set embed options based
 * on the parameters provided
 * @param {string | object} id - The id of the embed or an object of options
 * @param {object} options - The options to set
 * @returns {object}
 */
var getOrSetEmbedOptionStore = function getOrSetEmbedOptionStore(id, options) {
  var optionsKey = id;
  var embedOptions = options;

  // Redundant "typeof" check is needed to make typescript happy
  if (isObject(optionsKey) && typeof optionsKey === 'object') {
    embedOptions = optionsKey;
    optionsKey = GLOBAL_ID_KEY;
  }

  // Set options
  if (embedOptions !== undefined && embedOptions !== null) {
    return wData([OPTION_PREFIX, optionsKey], cast(clone(embedOptions)));
  }

  // Get options
  if (optionsKey !== undefined) {
    // If options exist for the provided id, just return them
    if (wData([OPTION_PREFIX, id]) !== undefined) {
      return wData([OPTION_PREFIX, id]);
    }

    // Otherwise, lets check this key's api handle
    var apiHandleFromKey = getOneApiHandle(optionsKey);
    if (apiHandleFromKey === null || apiHandleFromKey === 'removed') {
      return {};
    }
    // And compare it against all the other stored api handles
    if (wData(OPTION_PREFIX) !== undefined) {
      // If the api handles match, return the options for that key
      var matchedKey = Object.keys(wData(OPTION_PREFIX)).find(function (key) {
        return getOneApiHandle(key) === apiHandleFromKey;
      });
      if (wData([OPTION_PREFIX, matchedKey]) !== undefined) {
        return wData([OPTION_PREFIX, matchedKey]);
      }
    }
    return {};
  }
  return wData(OPTION_PREFIX);
};

/***/ }),

/***/ 3411:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F2: () => (/* binding */ getMediaDataFromCache),
/* harmony export */   ry: () => (/* binding */ cacheMediaData),
/* harmony export */   s3: () => (/* binding */ uncacheMediaData)
/* harmony export */ });
/* unused harmony exports getCarouselDataFromCache, cacheCarouselData, uncacheCarouselData */
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4586);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);
/* harmony import */ var _wlog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6637);
var _objectHasOwn = function (object, property) {
  if (typeof object === 'undefined' || object === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
};



var getMediaDataFromCache = function getMediaDataFromCache(hashedId) {
  var mediaData = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._remoteData.get("media_".concat(hashedId));
  if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_2__/* .isNil */ .gD)(mediaData)) return null;

  // It's possible that we're caching a server error response as MediaData.
  // If we find one of those places, log an error.
  if (_objectHasOwn(mediaData, 'error')) {
    _wlog_js__WEBPACK_IMPORTED_MODULE_1__/* .wlog */ .ct.error("Received cached error response instead of MediaData when retrieving cached mediaData for ".concat(hashedId));
  }
  return mediaData;
};
var cacheMediaData = function cacheMediaData(hashedId, data) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._remoteData.set("media_".concat(hashedId), data);
};
var uncacheMediaData = function uncacheMediaData(hashedId) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._remoteData.delete("media_".concat(hashedId));
  Reflect.deleteProperty(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._mediaDataPromises, hashedId);
};
var getCarouselDataFromCache = function getCarouselDataFromCache(hashedId) {
  var carouselData = Wistia._remoteData.get("carousel_".concat(hashedId));
  if (isNil(carouselData)) return null;
  return carouselData;
};
var cacheCarouselData = function cacheCarouselData(hashedId, data) {
  Wistia._remoteData.set("carousel_".concat(hashedId), data);
};
var uncacheCarouselData = function uncacheCarouselData(hashedId) {
  Wistia._remoteData.delete("carousel_".concat(hashedId));
};

/***/ }),

/***/ 3441:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CR: () => (/* binding */ seekToAction),
/* harmony export */   Qy: () => (/* binding */ shouldAddClipsFromChapters),
/* harmony export */   Vq: () => (/* binding */ shouldAddKeyMoments),
/* harmony export */   oG: () => (/* binding */ clipsFromChapters)
/* harmony export */ });
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4586);
/* harmony import */ var _normalizeChapters_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9128);
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }


// Google got mad that the default chapter title is (of course) not very
// descriptive, and wanted us to make sure it's never used for Key Moments.
var DEFAULT_CHAPTER_TITLE = 'Chapter Title';
var MINIMUM_DURATION = 30;
var shouldAddClipsFromChapters = function shouldAddClipsFromChapters(embedOptions) {
  var chapters = (0,_normalizeChapters_ts__WEBPACK_IMPORTED_MODULE_0__/* .normalizeChapters */ .a)(embedOptions);
  if (!chapters) {
    return false;
  }
  var chapterList = chapters.chapterList;

  // the `on` property must be explicitly false to disable
  return chapters.on !== false && chapters.on !== 'false' && Array.isArray(chapterList) && chapterList.length > 0;
};

// keyMoments should only be limited by a few factors:
// 1. a turnstile is blocking content
// 2. it's password protected
// 3. the video is really short
// 4. only available for VOD, not Live
// Then, there are two different _types_ of key moments. If we have chapters
// we will use the Clips format to specifically tell google the timestamps we think
// are important. Otherwise, we will use the SeekToAction field along with the wtime
// param to allow Google to search through the video for key moments
var shouldAddKeyMoments = function shouldAddKeyMoments(mediaData, embedOptions) {
  var _embedOptions$plugin;
  if (embedOptions.keyMoments === false) {
    return false;
  }
  var duration = mediaData.duration,
    type = mediaData.type;
  var _ref = (_embedOptions$plugin = embedOptions.plugin) !== null && _embedOptions$plugin !== void 0 ? _embedOptions$plugin : {},
    passwordProtectedVideo = _ref.passwordProtectedVideo,
    turnstilePlugin = _ref['requireEmail-v1'];
  var isLiveStream = type === 'LiveStream';
  var passwordEnabled = (passwordProtectedVideo === null || passwordProtectedVideo === void 0 ? void 0 : passwordProtectedVideo.on) === true || (passwordProtectedVideo === null || passwordProtectedVideo === void 0 ? void 0 : passwordProtectedVideo.on) === 'true';
  var turnstileBlocksContent = turnstilePlugin && turnstilePlugin.on !== false && turnstilePlugin.time !== 'end' && !turnstilePlugin.persistentTurnstile;
  return Boolean(!passwordEnabled && !turnstileBlocksContent && !isLiveStream && typeof duration === 'number' && duration >= MINIMUM_DURATION);
};
var sortedFilteredChapters = function sortedFilteredChapters(chapterList) {
  var chapterExistsAtTime = {};
  return _toConsumableArray(chapterList).sort(function (firstChapter, secondChapter) {
    return firstChapter.time - secondChapter.time;
  }).filter(function (_ref2) {
    var time = _ref2.time,
      title = _ref2.title,
      deleted = _ref2.deleted;
    if (Boolean(chapterExistsAtTime[time]) || deleted || title === DEFAULT_CHAPTER_TITLE) {
      return false;
    }
    chapterExistsAtTime[time] = true;
    return true;
  });
};
var clipsFromChapters = function clipsFromChapters(chapterList, baseUrl, mediaDuration) {
  if (!Array.isArray(chapterList) || chapterList.length === 0) {
    return [];
  }
  var clips = sortedFilteredChapters(chapterList).map(function (chapter, index, chapters) {
    var time = chapter.time,
      title = chapter.title;
    var url = new window.URL(baseUrl);
    var floorTime = Math.floor(time);
    var nextChapter = chapters[index + 1];
    var endOffsetTime = (0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_1__/* .isNotNil */ .n9)(nextChapter) ? nextChapter.time : mediaDuration;

    // wtime does not support decimals
    url.searchParams.set('wtime', "".concat(floorTime, "s"));

    // https://schema.org/Clip
    return {
      '@type': 'Clip',
      endOffset: Math.floor(endOffsetTime),
      name: title,
      startOffset: floorTime,
      url: url.toString()
    };
  });
  return clips;
};
// https://developers.google.com/search/docs/advanced/structured-data/video#seek
var seekToAction = function seekToAction() {
  var url = new window.URL(window.location.href);
  // if wtime is already on the url as query param, it will be overwritten here. This is only for the JSON+LD though.
  url.searchParams.set('wtime', '{seek_to_second_number}');
  return {
    '@type': 'SeekToAction',
    target: url.toString().replace('%7Bseek_to_second_number%7D', '{seek_to_second_number}'),
    // we need to replace the encoded uri with the direct string
    'startOffset-input': 'required name=seek_to_second_number'
  };
};

/***/ }),

/***/ 3695:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Qy: () => (/* binding */ setOrGet)
/* harmony export */ });
/* unused harmony exports uncache, removeLocalStorage, dumpLocalStorage */
/* harmony import */ var utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4997);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(731);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5509);




/*
 * DEPRECATED: Use utilities/wistiaLocalStorage.js directly instead.
 *
 * This module has two failings.
 *
 * First, it must include utilities/obj for its deep setting and getting
 * functionality, which is a core part of its API. However, this convenience
 * does not merit the size of its inclusion; if we want to do deep setting and
 * getting, we can just compose with Obj.setDeep and Obj.getDeep at the import site.
 *
 * Second, in order to avoid lots of JSON.parse calls, it keeps a cache that
 * should mirror the contents of localStorage. However, because localStorage
 * data is shared across tabs with the same domain--and because we are never
 * syncing the actual localStorage values here--changes in multiple open tabs
 * will overwrite each other, causing general strangeness.
 */

if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._localStorage) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._localStorage = (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__/* .getWistiaLocalStorage */ .y1)();
}
var uncache = function uncache() {
  Wistia._localStorage = {};
};
var setOrGet = function setOrGet(key, val) {
  var unset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (val != null) {
    var fn = unset ? utilities_obj_js__WEBPACK_IMPORTED_MODULE_1__/* .unsetDeep */ .G0 : utilities_obj_js__WEBPACK_IMPORTED_MODULE_1__/* .setDeep */ .vd;
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._localStorage = (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__/* .updateWistiaLocalStorage */ .$B)(function (ls) {
      return fn(ls, key, val);
    });
    return val;
  }
  if (key != null) {
    return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_1__/* .getDeep */ .b$)(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._localStorage, key);
  }
  return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._localStorage;
};
var removeLocalStorage = function removeLocalStorage(key) {
  return setOrGet(key, 'nada', true);
};
var dumpLocalStorage = (/* unused pure expression or super */ null && (removeWistiaLocalStorage));

/***/ }),

/***/ 3737:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ doTimeout)
/* harmony export */ });
/* unused harmony export clearTimeouts */
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);


var W = (/* unused pure expression or super */ null && (Wistia));
if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts == null) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts = {};
}

// Improved timeouts!
// allows us to
//   1. auto-debounce if an identical key is replaced
//   2. associate timeouts with a specific context, but access them globally
//   3. Clear all timeouts in a specific context
//   4. Do nextTick by not specifying the time argument
// e.g. Wistia.timeout("video1234", function() { ... });
//
// In our implementation, we treat the first dot-delimited value in the key
// as a namespace. This is an optimization since most of our videos prefix
// their timeouts with a uuid. By keeping them in a namespace, it means
// clearTimeouts doesn't need to iterate through _all_ timeouts globally,
// which makes doTimeout itself faster (since it calls clearTimeouts internally).
//
// Returns the timeoutId.
var doTimeout = function doTimeout(key, fn) {
  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  if ((0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(key)) {
    key = key.join('.');
  }
  var namespace = timeoutNamespace(key);
  clearTimeouts(key, namespace);
  if (fn) {
    var timeouts = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[namespace];
    if (timeouts == null) {
      timeouts = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[namespace] = {};
    }
    var timeoutId = setTimeout(function () {
      delete timeouts[key];
      fn();
    }, time);
    timeouts[key] = timeoutId;
    return timeoutId;
  }
  return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[namespace][key];
};

// This will clear timeouts matching the key. Key is dot-delimited list
// like:
//
// mynamespace.more_specific.
// mynamespace.anothernamespace.more_specific
//
// We allow passing in namespace as an optimization for doTimeout.
var clearTimeouts = function clearTimeouts(key) {
  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if ((0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(key)) {
    key = key.join('.');
  }
  namespace = namespace || timeoutNamespace(key);

  // If there's no namespacing on the input key, then we should treat the
  // input as both a namespace _and_ a key. This handles the namespace case.
  // We handle the key case with our normal logic.
  var timeouts;
  if (namespace === '__global__') {
    timeouts = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[key];
    if (timeouts) {
      for (var k in timeouts) {
        var v = timeouts[k];
        clearTimeout(v);
        delete timeouts[k];
      }
    }
  }
  timeouts = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[namespace];
  if (timeouts) {
    for (var _k in timeouts) {
      var _v = timeouts[_k];
      if (_k.indexOf && _k.indexOf(key) === 0 && (_k.length === key.length || _k.charAt(key.length) === '.')) {
        clearTimeout(_v);
        delete timeouts[_k];
      }
    }
  }

  // Cleaning out namespaces is not particularly efficient, and isn't
  // particularly helpful, so let's only do it once every 5 seconds.
  if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.blockSweepTimeouts) {
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.blockSweepTimeouts = true;
    setTimeout(sweepTimeouts, 0);
    setTimeout(function () {
      _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.blockSweepTimeouts = false;
    }, 5000);
  }
};

// Clear out any namespaces that are no longer active
var sweepTimeouts = function sweepTimeouts() {
  for (var namespace in _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts) {
    var timeouts = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[namespace];
    if ((0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .isEmpty */ .Im)(timeouts)) {
      delete _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._timeouts[namespace];
    }
  }
};
var timeoutNamespace = function timeoutNamespace(key) {
  var dotIndex = key.indexOf('.');
  if (dotIndex > 0) {
    return key.substring(0, dotIndex);
  }
  return '__global__';
};

/***/ }),

/***/ 3817:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J0: () => (/* binding */ d),
/* harmony export */   NT: () => (/* binding */ x),
/* harmony export */   li: () => (/* binding */ A),
/* harmony export */   vJ: () => (/* binding */ y)
/* harmony export */ });
/* unused harmony exports useCallback, useDebugValue, useErrorBoundary, useId, useImperativeHandle, useLayoutEffect, useMemo, useReducer */
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
var t,r,u,i,o=0,f=[],c=preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .fF,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function p(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function d(n){return o=1,h(D,n)}function h(n,u,i){var o=p(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.__f)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=o.__c.props!==n;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),c&&c.call(this,n,t,r)||i};r.__f=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=p(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__H.__h.push(i))}function _(n,u){var i=p(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.u=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){if("function"==typeof n){var r=n(t());return function(){n(null),r&&"function"==typeof r&&r()}}if(n)return n.current=t(),function(){return n.current=null}},null==r?r:r.concat(n))}function T(n,r){var u=p(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=p(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=p(t++,10),i=d();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=p(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.u=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.u=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k="function"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ 3832:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ extractEmailFromParams)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1627);
/* harmony import */ var _wlog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6637);



/**
 * Extracts the email from the pageUrl and returns it if found
 * @param {string} pageUrl the url of the page
 * @returns {string | null} the email if found, null otherwise
 */
var extractEmailFromParams = function extractEmailFromParams(pageUrl) {
  var _exec, _exec2;
  var wemail = (_exec = /wemail=([^&#]+)/.exec(pageUrl)) !== null && _exec !== void 0 ? _exec : null;
  if (wemail) {
    return wemail[1];
  }
  var wkey = (_exec2 = /wkey=([^&#]+)/.exec(pageUrl)) !== null && _exec2 !== void 0 ? _exec2 : null;
  if (wkey) {
    var base64Email = wkey[1];
    try {
      var decodedEmail = (0,_core_js__WEBPACK_IMPORTED_MODULE_0__/* .base64Decode */ .u)(base64Email);
      return decodedEmail;
    } catch (error) {
      _wlog_js__WEBPACK_IMPORTED_MODULE_1__/* .wlog */ .ct.info('Failed to decode email from wkey', error);
    }
  }
  return null;
};

/***/ }),

/***/ 3917:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ mediaDataTransforms)
/* harmony export */ });
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2671);
/* harmony import */ var utilities_detect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7231);
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4586);
/* harmony import */ var _assets_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7209);
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }





var detect = (0,utilities_detect_js__WEBPACK_IMPORTED_MODULE_2__/* .cachedDetect */ .o1)();
var convertStillImageToWebp = function convertStillImageToWebp(media) {
  if (media.assets && detect.webp) {
    media.assets = media.assets.map(function (asset) {
      // there was a flow with the uploader + notPlayablePlayer where we have assets
      // but they're not ready and don't have urls, so just double check for that here
      if (asset.type === 'still_image' && Object(asset).url) {
        var url = new utilities_url_js__WEBPACK_IMPORTED_MODULE_1__/* .Url */ .s0(asset.url);
        url.ext('webp');
        asset.url = url.absolute();
      }
      return asset;
    });
  }
};
var maybeCloneOriginalAsMp4 = function maybeCloneOriginalAsMp4(media) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (options.allowOriginalAsMp4 !== true) {
    // only transform if the embed options ask for it
    return;
  }
  var original = media.assets.filter(function (a) {
    return a.type === 'original';
  })[0];
  if ((0,_assets_js__WEBPACK_IMPORTED_MODULE_3__/* .readyPublicOver400 */ .n9)(media.assets).length > 0) {
    // we have a derivative we can show instead
    return;
  }
  media.assets = [].concat(_toConsumableArray(media.assets), [(0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .assign */ .kp)({}, original, {
    display_name: "".concat(original.display_name, " copy"),
    container: 'mp4',
    codec: 'h264',
    type: 'mp4_video'
  })]);
};
var maybeAddChannelIdToEmbedOptions = function maybeAddChannelIdToEmbedOptions(media) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_4__/* .isNotNil */ .n9)(options.channelId) && media.embedOptions) {
    media.embedOptions.channelId = options.channelId;
  }
};
var maybeAddChannelPasswordToEmbedOptions = function maybeAddChannelPasswordToEmbedOptions(media) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_4__/* .isNotNil */ .n9)(options.channelPassword) && media.embedOptions) {
    media.embedOptions.channelPassword = options.channelPassword;
  }
};
var mediaDataTransforms = function mediaDataTransforms(media) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  maybeCloneOriginalAsMp4(media, options);
  convertStillImageToWebp(media);
  maybeAddChannelIdToEmbedOptions(media, options);
  maybeAddChannelPasswordToEmbedOptions(media, options);
  return media;
};

/***/ }),

/***/ 3997:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ wRemoveData),
/* harmony export */   m: () => (/* binding */ wData)
/* harmony export */ });
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);



// A simple key/value store implementation
// stored on the Wistia namespace
//
// To set:
//
//     wData("key.path", "val")
//     wData(["key", "path"], "val")
//
// To get
//
//     wData("key.path")
//     wData(["key", "path"])

var wData = function wData(key, val) {
  if (!(0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(key)) {
    key = key.split('.');
  }
  if (val != null) {
    (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .setDeep */ .vd)(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s, ['_data'].concat(key), val);
  }
  return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .getDeep */ .b$)(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s, ['_data'].concat(key));
};
var wRemoveData = function wRemoveData(key) {
  if (!(0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(key)) {
    key = key.split('.');
  }
  return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .unsetDeep */ .G0)(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s, ['_data'].concat(key));
};

/***/ }),

/***/ 4271:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mj: () => (/* binding */ globalTrigger)
/* harmony export */ });
/* unused harmony exports globalBind, globalOn, globalOff, globalRebind, globalUnbind */
/* harmony import */ var utilities_wbindable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9376);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);


(0,utilities_wbindable_js__WEBPACK_IMPORTED_MODULE_0__/* .makeWbindable */ .R)(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);
var globalBind = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.bind.bind(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);
var globalOn = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.on.bind(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);
var globalOff = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.off.bind(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);
var globalRebind = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.rebind.bind(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);
var globalTrigger = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.trigger.bind(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);
var globalUnbind = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.unbind.bind(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s);

/***/ }),

/***/ 4309:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wt: () => (/* binding */ controlMultiplierEstimatedByWidth)
/* harmony export */ });
/* unused harmony exports scalingOptionsFromVideo, controlDimensions, bigPlayButtonDimensions, fontSizeMultiplier, allowBigControls, maxMultiplierForVideo, minMultiplierForVideo, getZoomMultiplier, getDeviceMultiplier, controlMultiplierForVideo, controlMultiplier, menuMultiplier, fitControl, tapIcon, parseMetaViewport, controlMultiplierBasedOnVideo */
/* harmony import */ var utilities_elem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7715);
/* harmony import */ var utilities_timeout_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3737);
/* harmony import */ var utilities_detect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7231);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(731);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }




var detect = (0,utilities_detect_js__WEBPACK_IMPORTED_MODULE_2__/* .cachedDetect */ .o1)();
var scalingOptionsFromVideo = function scalingOptionsFromVideo(video, options) {
  return merge({
    videoWidth: video.videoWidth(),
    videoHeight: video.videoHeight(),
    isInFullscreen: video.inFullscreen(),
    controlScaling: video.controlScaling()
  }, options);
};
var controlDimensions = function controlDimensions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var baseWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 40;
  var baseHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 34;
  options = merge({
    videoWidth: 640,
    videoHeight: 360,
    isInFullscreen: false,
    baseWidth: baseWidth != null ? baseWidth : 40,
    baseHeight: baseHeight != null ? baseHeight : 34
  }, options);
  var multiplier = controlMultiplier(options);
  return {
    width: multiplier * options.baseWidth,
    height: multiplier * options.baseHeight
  };
};
var bigPlayButtonDimensions = function bigPlayButtonDimensions(options, baseWidth, baseHeight) {
  return controlDimensions(options, baseWidth, baseHeight);
};

// abstracted so this can easily be changed if we wanted.
var fontSizeMultiplier = function fontSizeMultiplier(options) {
  return controlMultiplier(options);
};
var allowBigControls = function allowBigControls() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var screenHeight = options.screenHeight || window.screen.height;
  var screenWidth = options.screenWidth || window.screen.width;
  return options.controlScaling != 'auto' || detect.iphone || detect.android || screenWidth < screenHeight;
};
var maxMultiplierForVideo = function maxMultiplierForVideo(options) {
  if (options.controlScaling != 'auto') {
    return options.controlScaling;
  }
  if (allowBigControls(options)) {
    // the device dimensions are oriented vertically; this is probably a phone
    // or tablet, or just a monitor that would be fine with huge controls.
    return 3.5;
  }
  return 1.4;
};
var minMultiplierForVideo = function minMultiplierForVideo(options) {
  if (options.controlScaling != 'auto') {
    return options.controlScaling;
  }
  if (allowBigControls(options)) {
    // the controls are unusable if we scale down too much for on phones and
    // tablets.
    return 1;
  }
  return 0.75;
};
var getZoomMultiplier = function getZoomMultiplier(options) {
  if (!options.isInFullscreen) {
    return 1;
  }
  var result = Math.max(1, window.innerWidth / Math.max(screen.width, screen.height));
  return result;
};
var getDeviceMultiplier = function getDeviceMultiplier(options) {
  if (allowBigControls(options)) {
    return 1.4;
  }
  return 1;
};
var controlMultiplierForVideo = function controlMultiplierForVideo(video, options) {
  return controlMultiplier(scalingOptionsFromVideo(video, options));
};
var controlMultiplier = function controlMultiplier(options) {
  if (options.controlScaling != 'auto') {
    return options.controlScaling;
  }
  var videoWidth = options.videoWidth,
    videoHeight = options.videoHeight;
  var zoomMultiplier = getZoomMultiplier(options);
  var largestDimension = Math.max(videoWidth, videoHeight);
  if (largestDimension > 960) {
    var percentOverThreshold = largestDimension / 960;
    var scaleFactor = percentOverThreshold * getDeviceMultiplier(options);
    return Math.min(maxMultiplierForVideo(options) * zoomMultiplier, scaleFactor * zoomMultiplier);
  }
  if (largestDimension < 640) {
    var percentUnderThreshold = largestDimension / 640;
    var _scaleFactor = percentUnderThreshold * getDeviceMultiplier(options);
    return Math.max(minMultiplierForVideo(options) * zoomMultiplier, _scaleFactor * zoomMultiplier);
  }
  return 1 * getDeviceMultiplier(options);
};

// abstracted so this can easily be changed if we wanted.
var menuMultiplier = function menuMultiplier(options) {
  return Math.max(0.75, controlMultiplier(options));
};
var fitControl = function fitControl(options) {
  var _options = options,
    controlId = _options.controlId,
    video = _options.video,
    controlElem = _options.controlElem;
  options = merge({
    videoWidth: video.videoWidth(),
    videoHeight: video.videoHeight(),
    controlScaling: video.controlScaling(),
    isInFullscreen: video.inFullscreen()
  }, options);
  var _controlDimensions = controlDimensions(options),
    width = _controlDimensions.width,
    height = _controlDimensions.height;
  elemStyle(controlElem, {
    height: "".concat(height, "px"),
    width: "".concat(width, "px")
  });
  tapIcon("".concat(video.uuid, ".").concat(controlId), controlElem);
  return {
    width: width,
    height: height
  };
};

// Often the svg size changes don't visually change the vertical position of
// the icon. "tapping" it by forcing it to reevaluate the stack is one way to
// fix that.
var tapIcon = function tapIcon(timeoutPrefix, controlElem) {
  var svgs = controlElem.getElementsByTagName('svg');
  for (var i = 0; i < svgs.length; i++) {
    (function (svg) {
      doTimeout("".concat(timeoutPrefix, ".tap_icon"), function () {
        elemStyle(svg, {
          position: 'relative'
        });
        doTimeout('#{timeoutPrefix}.tap_icon', function () {
          elemStyle(svg, {
            position: ''
          });
        }, 30);
      }, 30);
    })(svgs[i]);
  }
};
var parseMetaViewport = function parseMetaViewport() {
  var metaTag = document.querySelector('meta[name=viewport]');
  var content = metaTag && metaTag.getAttribute('content');
  var result = {};
  if (content) {
    var pairs = content.split(/[\s,]+/);
    pairs.forEach(function (pair) {
      var keyAndVal = pair.split('=');
      if (keyAndVal.length === 2) {
        result[keyAndVal[0]] = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_3__/* .cast */ .wg)(keyAndVal[1]);
      }
    });
  }
  return result;
};
var normalScaleWidthRange = function normalScaleWidthRange(media) {
  var onMobile = detect.iphone || detect.ipad || detect.android;
  if (!onMobile) {
    return [640, 960];
  }
  if (media !== null && media !== void 0 && media.isAudio()) {
    return [500, 960];
  }
  var viewport = parseMetaViewport();
  var screenWidth;
  if (viewport.width) {
    // Initial render being controled by <meta name='viewport' content='...'/>
    if (typeof viewport.width === 'number') {
      screenWidth = 0 + viewport.width;
    } else {
      screenWidth = screen.width || window.innerWidth;
    }

    // This doesn't capture any scaling the user does after the initial
    // render, but the page designer would expect the video to render at the
    // scale they set.
    var scale = Math.max(viewport['minimum-scale'] || 0, Math.min(viewport['maximum-scale'] || 10, viewport['initial-scale'] || 1));
    if (scale < 1) {
      screenWidth /= scale;
    }
  } else {
    // Initial render will use the width of the document to determine its
    // size, then zoom out to show the whole page.
    screenWidth = window.innerWidth;
  }
  return [screenWidth, screenWidth * 2 / 3];
};
var normalScaleHeightRange = function normalScaleHeightRange(media) {
  var onMobile = detect.iphone || detect.ipad || detect.android;
  if (!onMobile) {
    return [340, 860];
  }
  if (media !== null && media !== void 0 && media.isAudio()) {
    return [500, 960];
  }
  var viewport = parseMetaViewport();
  var screenHeight;
  if (viewport.height) {
    // Initial render being controled by <meta name='viewport' content='...'/>
    if (typeof viewport.height === 'number') {
      screenHeight = 0 + viewport.height;
    } else {
      screenHeight = screen.height || window.innerHeight;
    }

    // This doesn't capture any scaling the user does after the initial
    // render, but the page designer would expect the video to render at the
    // scale they set.
    var scale = Math.max(viewport['minimum-scale'] || 0, Math.min(viewport['maximum-scale'] || 10, viewport['initial-scale'] || 1));
    if (scale < 1) {
      screenHeight /= scale;
    }
  } else {
    // Initial render will use the width of the document to determine its
    // size, then zoom out to show the whole page.
    screenHeight = window.innerWidth;
  }
  return [screenHeight, screenHeight * 2 / 1.3];
};
var controlMultiplierBasedOnVideo = function controlMultiplierBasedOnVideo(video, normalRange) {
  var vidWidth = video.videoWidth();
  var vidHeight = video.videoHeight();
  var aspect = vidWidth / vidHeight;

  // vertical orientation
  if (aspect < 1) {
    var _normalScaleHeightRan = normalScaleHeightRange(video),
      _normalScaleHeightRan2 = _slicedToArray(_normalScaleHeightRan, 2),
      lowerCutoff = _normalScaleHeightRan2[0],
      upperCutoff = _normalScaleHeightRan2[1];
    if (vidHeight <= lowerCutoff) {
      return vidHeight / lowerCutoff;
    }
    if (vidHeight > upperCutoff) {
      return vidHeight / upperCutoff;
    }
  }
  // horizontal orientation
  else {
    var _ref = normalRange || normalScaleWidthRange(video),
      _ref2 = _slicedToArray(_ref, 2),
      _lowerCutoff = _ref2[0],
      _upperCutoff = _ref2[1];
    if (vidWidth <= _lowerCutoff) {
      return vidWidth / _lowerCutoff;
    }
    if (vidWidth > _upperCutoff) {
      return vidWidth / _upperCutoff;
    }
  }

  // default when the video is within normal range
  return 1;
};

// A more general version of controlMultiplierBasedOnVideo that doesn't require
// a video object.
var controlMultiplierEstimatedByWidth = function controlMultiplierEstimatedByWidth(width, normalRange) {
  var _ref3 = normalRange || normalScaleWidthRange(),
    _ref4 = _slicedToArray(_ref3, 2),
    lowerCutoff = _ref4[0],
    upperCutoff = _ref4[1];
  if (width <= lowerCutoff) {
    return width / lowerCutoff;
  }
  if (width > upperCutoff) {
    return width / upperCutoff;
  }
  return 1;
};

/***/ }),

/***/ 4372:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   qN: () => (/* binding */ getCssGradient),
/* harmony export */   yz: () => (/* binding */ getGradientColor)
/* harmony export */ });
/* unused harmony export cleanGradient */
/* harmony import */ var _types_gradient_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7350);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5417);
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(731);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }



var DEFAULT_ALPHA = 0.9;
var GRADIENT_COLOR_INDEX = 0;
var GRADIENT_PERCENTAGE_INDEX = 1;
var hexToRGBA = function hexToRGBA(hex) {
  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ALPHA;
  var color = new _color_js__WEBPACK_IMPORTED_MODULE_0__/* .Color */ .Q(hex);

  // the "as Color" here is because the implicit types are not quite right... because we're passing a value to the
  // alpha function and using it as a setter it returns the new color as a Color object, not a number or undefined
  // (which happens if you're using the function as a getter)
  var colorWithAlpha = color.alpha(alpha);
  return colorWithAlpha.toRgba();
};
var decimalToPercentage = function decimalToPercentage(decimal) {
  return decimal * 100;
};
var getCssGradient = function getCssGradient(gradient) {
  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ALPHA;
  if (gradient.colors.length === 0) {
    return null;
  }
  var areAllColorsValid = gradient.colors.every(function (gradientColor) {
    return Boolean(gradientColor[GRADIENT_COLOR_INDEX] && gradientColor[GRADIENT_PERCENTAGE_INDEX] >= 0 && gradientColor[GRADIENT_PERCENTAGE_INDEX] <= 1);
  });
  if (!areAllColorsValid) {
    return null;
  }
  return "linear-gradient(90deg, ".concat(gradient.colors.map(function (gradientColor) {
    return "".concat(hexToRGBA(gradientColor[0], alpha), " ").concat(decimalToPercentage(gradientColor[1]), "%");
  }).join(', '), ")");
};
var getGradientColor = function getGradientColor(gradient) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!(0,_types_gradient_ts__WEBPACK_IMPORTED_MODULE_2__/* .isGradient */ .b)(gradient)) {
    return null;
  }
  return gradient.colors[index][GRADIENT_COLOR_INDEX];
};
var cleanGradient = function cleanGradient(gradient) {
  var casted = cast(clone(gradient));
  var result = {
    colors: casted.colors.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        color = _ref2[0],
        percentage = _ref2[1];
      return [color.toString(), percentage];
    }),
    on: casted.on
  };
  return result;
};

/***/ }),

/***/ 4400:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ getPreferredAvailableLanguageIndex)
/* harmony export */ });
var getAlpha2Code = function getAlpha2Code(iso6392Code) {
  return iso6392Code.split('-')[0];
};

/**
 * Finds the index of the preferred language from a list of available languages.
 *
 * This function helps select the best matching language based on user preferences and browser settings.
 * It's designed to work with arrays of ISO 639-2 language codes, optionally with region codes (e.g. 'en' or 'en-US'),
 * but can also be used for matching alpha3 ietf language tags, e.g. "eng".
 *
 * @param availableLanguages - Array of language codes that are available to choose from
 * @param preferredLanguages - Array of language codes to try matching
 * @returns The index of the best matching language in the availableLanguages array, or -1 if no languages are available
 *
 * @example
 * const captions = [
 *   { language: 'en', text: 'Hello' },
 *   { language: 'es', text: 'Hola' }
 * ];
 * const index = getPreferredAvailableLanguageIndex(
 *   captions.map(c => c.language),
 *   ['es']
 * );
 * const preferredCaption = captions[index];
 */
var getPreferredAvailableLanguageIndex = function getPreferredAvailableLanguageIndex(availableLanguages, preferredLanguages) {
  // Try exact matches first
  var exactMatch = preferredLanguages.find(function (preferred) {
    return availableLanguages.includes(preferred);
  });
  if (exactMatch != null) {
    return availableLanguages.indexOf(exactMatch);
  }

  // Try region matches
  var regionMatch = preferredLanguages.find(function (preferred) {
    var preferredAlpha2 = getAlpha2Code(preferred);
    return availableLanguages.some(function (lang) {
      return getAlpha2Code(lang) === preferredAlpha2;
    });
  });
  if (regionMatch != null) {
    return availableLanguages.findIndex(function (lang) {
      return getAlpha2Code(lang) === getAlpha2Code(regionMatch);
    });
  }
  return -1;
};

/***/ }),

/***/ 4586:
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
__webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.Lm = __webpack_unused_export__ = exports.Tn = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.cy = exports.uu = __webpack_unused_export__ = exports.u4 = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.Et = __webpack_unused_export__ = exports.jw = __webpack_unused_export__ = exports.Kg = exports.n9 = exports.gD = __webpack_unused_export__ = exports.b0 = __webpack_unused_export__ = exports.kZ = void 0;
const isNull = (x) => x === null;
exports.kZ = isNull;
const isNotNull = (x) => !(0, exports.kZ)(x);
__webpack_unused_export__ = isNotNull;
const isUndefined = (x) => x === undefined;
exports.b0 = isUndefined;
const isNotUndefined = (x) => !(0, exports.b0)(x);
__webpack_unused_export__ = isNotUndefined;
const isNil = (x) => (0, exports.kZ)(x) || (0, exports.b0)(x);
exports.gD = isNil;
const isNotNil = (x) => !(0, exports.gD)(x);
exports.n9 = isNotNil;
const isString = (x) => typeof x === 'string';
exports.Kg = isString;
const isNotString = (x) => !(0, exports.Kg)(x);
__webpack_unused_export__ = isNotString;
const isEmptyString = (x) => (0, exports.Kg)(x) && x === '';
exports.jw = isEmptyString;
const isNonEmptyString = (x) => (0, exports.Kg)(x) && !(0, exports.jw)(x);
__webpack_unused_export__ = isNonEmptyString;
const isNumber = (x) => typeof x === 'number';
exports.Et = isNumber;
const isNotNumber = (x) => !(0, exports.Et)(x);
__webpack_unused_export__ = isNotNumber;
const isNaN = (x) => Number.isNaN(x);
__webpack_unused_export__ = isNaN;
const isInteger = (x) => Number.isInteger(x);
__webpack_unused_export__ = isInteger;
const isRecord = (x) => (0, exports.n9)(x) && typeof x === 'object' && !(x instanceof Array);
exports.u4 = isRecord;
const isEmptyRecord = (x) => (0, exports.u4)(x) && Object.keys(x).length === 0;
__webpack_unused_export__ = isEmptyRecord;
const isNonEmptyRecord = (x) => (0, exports.u4)(x) && Object.keys(x).length > 0;
exports.uu = isNonEmptyRecord;
const isArray = (x) => (0, exports.n9)(x) && typeof x === 'object' && x instanceof Array;
exports.cy = isArray;
const isNotArray = (x) => !(0, exports.cy)(x);
__webpack_unused_export__ = isNotArray;
const isEmptyArray = (x) => (0, exports.cy)(x) && x.length === 0;
__webpack_unused_export__ = isEmptyArray;
const isNonEmptyArray = (x) => (0, exports.cy)(x) && x.length > 0;
__webpack_unused_export__ = isNonEmptyArray;
const isFunction = (x) => (0, exports.n9)(x) && typeof x === 'function';
exports.Tn = isFunction;
const isNotFunction = (x) => !(0, exports.Tn)(x);
__webpack_unused_export__ = isNotFunction;
const isBoolean = (x) => (0, exports.n9)(x) && typeof x === 'boolean';
exports.Lm = isBoolean;
const isNotBoolean = (x) => !(0, exports.Lm)(x);
__webpack_unused_export__ = isNotBoolean;
// eslint-disable-next-line no-void
const isVoid = (x) => x === void 0;
__webpack_unused_export__ = isVoid;
const isError = (error) => {
    return (0, exports.n9)(error) && error instanceof Error;
};
__webpack_unused_export__ = isError;
/**
 * Curried function that tests if an input is an object
 * _and_ that a key that was passed in is a property of that object
 *
 * @param key - The key to test if it is a property of the input record
 * @returns A function that takes an unknown input and then tests if the
 *  input is an object and whether the key is a property of that object or not
 */
const hasKey = (x, key) => (0, exports.uu)(x) && key in x;
__webpack_unused_export__ = hasKey;


/***/ }),

/***/ 4635:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   YG: () => (/* binding */ blankImage),
/* harmony export */   cd: () => (/* binding */ bestImage),
/* harmony export */   eZ: () => (/* binding */ sortedImages)
/* harmony export */ });
/* harmony import */ var utilities_hosts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5857);

var bestImage = function bestImage(images) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _sortedImages = sortedImages(images);
  if (_sortedImages.length === 0) {
    // If the still failed to process, we might find ourselves going down
    // this path.
    return blankImage(opts.videoWith, opts.videoHeight);
  }

  // When this first loads it's possible that @img will have a width of -1
  // until fit() fully takes hold. This could probably be fixed a better
  // way, but this code is here to ensure that we don't return a bogus
  // bestImage() if that's the case.
  var currentWidth = opts.videoWidth;

  // For sharper screens, let's load up larger images so the thumbnail
  // looks hella sharp
  var desiredWidth = (window.devicePixelRatio || 1) * currentWidth;
  if (desiredWidth <= _sortedImages[0].width) {
    return _sortedImages[0];
  }
  for (var i = 0; i < _sortedImages.length; i++) {
    var image = _sortedImages[i];
    if (image.width >= desiredWidth) {
      return image;
    }
  }
  return _sortedImages[_sortedImages.length - 1];
};
var blankImage = function blankImage(videoWidth, videoHeight) {
  return {
    height: videoHeight,
    url: "https://".concat((0,utilities_hosts_js__WEBPACK_IMPORTED_MODULE_0__/* .eV1HostWithPort */ .aY)(), "/assets/images/blank.gif"),
    width: videoWidth
  };
};
var sortedImages = function sortedImages(images) {
  return images.map(function (image) {
    image.aspect = image.width / image.height;
    return image;
  });
};

/***/ }),

/***/ 4719:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   e: () => (/* binding */ BigPlayButtonLoadingAnim)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3817);
/* harmony import */ var _utilities_elem_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7715);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }



var BigPlayButtonLoadingAnim = function BigPlayButtonLoadingAnim() {
  var svgEl = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useRef */ .li)(null);
  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useState */ .J0)(false),
    _useState2 = _slicedToArray(_useState, 2),
    isAnimating = _useState2[0],
    setIsAnimating = _useState2[1];
  (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useEffect */ .vJ)(function () {
    (0,_utilities_elem_js__WEBPACK_IMPORTED_MODULE_2__/* .addInlineCss */ .Ev)(svgEl.current, "\n        @keyframes w-loading-pulse {\n          from {\n            stroke-dashoffset: 55;\n          }\n          to {\n            stroke-dashoffset: -175;\n          }\n        }\n        .w-big-play-button-loading-anim {\n          stroke-dasharray: 50 260;\n          stroke-dashoffset: 55;\n          animation: w-loading-pulse 1.2s infinite cubic-bezier(0.65, 0, 0, 1);\n        }\n      ");
    setIsAnimating(true);
  }, []);
  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("line", {
    ref: svgEl,
    class: "w-big-play-button-loading-anim",
    x1: "0",
    y1: "78",
    x2: "125",
    y2: "78",
    style: {
      stroke: '#FFFFFF',
      strokeWidth: 4,
      strokeLinecap: 'round',
      opacity: isAnimating ? 1 : 0
    }
  });
};

/***/ }),

/***/ 4730:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Oj: () => (/* binding */ defineTranslations),
/* harmony export */   Z0: () => (/* binding */ getLanguage),
/* harmony export */   sC: () => (/* binding */ getTranslation)
/* harmony export */ });
/* unused harmony exports supportedLanguages, getLanguagePreference, loadAndDefineTranslation, matchingLanguages, getDefaultTranslation */
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_dynamicImport_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7157);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5509);



var languages = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.languages = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.languages || {};
var translations = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.translations = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.translations || {};

// set translationPromises if doesn't exist
if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._translationPromises) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s._translationPromises = {};
}
var supportedLanguages = (/* unused pure expression or super */ null && (['ar', 'de', 'es', 'en-US', 'fr', 'it', 'ja', 'ko', 'pt', 'ru', 'zh-CN']));
var defineLanguage = function defineLanguage(code, text, translations) {
  languages[code] = {
    code: code,
    text: decodeEntities(text)
  };
  if (translations) {
    defineTranslations(code, translations);
  }
};
var getLanguage = function getLanguage(code) {
  return languages[code];
};
var defineTranslations = function defineTranslations(code, keyValPairs) {
  if (languages[code] == null) {
    throw new Error("Must define a language with code ".concat(code, " before defining its translations."));
  }
  var translation = translations[code];
  if (translation) {
    (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .merge */ .h1)(translation, keyValPairs);
  } else {
    translations[code] = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(keyValPairs);
  }
};
var withFallbackText = function withFallbackText(text) {
  if (text == null) {
    return '?';
  }
  return text;
};
var dummyTextArea;
var cachedDecodings = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.cachedDecodings = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.cachedDecodings || {};
var decodeEntities = function decodeEntities(text) {
  if (!dummyTextArea) {
    // Create this lazily to avoid race conditions while document is rendering.
    dummyTextArea = document.createElement('textarea');
  }
  if (cachedDecodings[text] != null) {
    // If we've decoded this before, use that value; DOM operations aren't
    // fast.
    return cachedDecodings[text];
  }
  dummyTextArea.innerHTML = text;
  cachedDecodings[text] = dummyTextArea.value;
  return dummyTextArea.value;
};
var getTranslation = function getTranslation(code, key) {
  var text;
  if (translations[code] && translations[code][key]) {
    text = translations[code][key];
  } else {
    text = translations['en-US'][key];
  }
  return decodeEntities(withFallbackText(text));
};
var getLanguagePreference = function getLanguagePreference() {
  if (navigator.languages || navigator.language) {
    Wistia.languagePreference = navigator.languages || [navigator.language];
  } else {
    // in old browsers that don't support navigator.language(s), like IE 9/10,
    // just go with English.
    Wistia.languagePreference = ['en-US'];
  }
  return Wistia.languagePreference;
};
var loadAndDefineTranslation = function loadAndDefineTranslation(code) {
  if (Wistia._translationPromises[code]) {
    return Wistia._translationPromises[code];
  }
  var result = new Promise(function (resolve, reject) {
    dynamicImport(["assets/external/translations/".concat(code, ".js")]).then(function (moduleClass) {
      var languageCode = moduleClass.languageCode,
        languageLabel = moduleClass.languageLabel,
        translations = moduleClass.translations;
      defineLanguage(languageCode, languageLabel, translations);
      resolve({
        code: code,
        translations: translations[code]
      });
    }).catch(reject);
  });
  Wistia._translationPromises[code] = result;
  return result;
};
var matchingLanguages = function matchingLanguages() {
  var languagePrefs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getLanguagePreference;
  return languagePrefs().reduce(function (matches, langCode) {
    var isFullMatch = supportedLanguages.indexOf(langCode) !== -1;

    // strip the region off a language, e.g. `es-ES` -> `es`
    var partialLangCode = langCode.split('-')[0];

    // take a partial match if the language hits, just not the region, e.g. `es-ES` -> `es`
    var isPartialMatch = supportedLanguages.indexOf(partialLangCode) !== -1;
    if (isFullMatch) {
      matches.push(langCode);
    } else if (isPartialMatch) {
      matches.push(partialLangCode);
    }
    return matches;
  }, []);
};
var getDefaultTranslation = function getDefaultTranslation() {
  var matchingLanguage = matchingLanguages()[0];

  // if there is not match, or if it is 'en', go to our
  // default of 'en-US'
  if (!matchingLanguage || matchingLanguage === 'en') {
    matchingLanguage = 'en-US';
  }
  if (translations[matchingLanguage]) {
    return Promise.resolve({
      code: matchingLanguage,
      translations: translations[matchingLanguage]
    });
  }
  return loadAndDefineTranslation(matchingLanguage);
};

// Most translations are defined where they are used, however these translations are
// rather generic and used in multiple places. They are defined here so we don't
// duplicate multiple translation keys.
defineLanguage('en-US', 'English');
defineTranslations('en-US', {
  PLAY: 'Play',
  PLAY_BUTTON_LIVE_NOT_STARTED: 'Livestream has not started',
  PLAY_BUTTON_TITLE_WHEN_NOT_PLAYING: 'Play Video',
  PLAY_BUTTON_TITLE_WHEN_PLAYING: 'Pause',
  REWATCH: 'Rewatch',
  SKIP: 'Skip'
});

/***/ }),

/***/ 4755:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D5: () => (/* binding */ isVisitorTrackingEnabled)
/* harmony export */ });
/* unused harmony exports migrateLegacyVisitorTracking, consent, setVisitorTrackingEnabled */
/* harmony import */ var utilities_globalBindAndTrigger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4271);
/* harmony import */ var utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4997);
/* harmony import */ var utilities_getApiHandles_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5510);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5509);
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }




var migrateLegacyVisitorTracking = function migrateLegacyVisitorTracking() {
  var legacyIsEnabled = (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_1__/* .getWistiaLocalStorage */ .y1)().visitorTrackingEnabled;
  if (legacyIsEnabled != null) {
    // Migrate old structure to new structure
    //
    // old:
    // localStorage
    //   visitorTrackingEnabled: boolean
    //
    // new:
    // localStorage
    //   visitorTracking: {
    //     isEnabled: boolean,
    //     updatedAt: timestamp,
    //   }
    //
    (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_1__/* .updateWistiaLocalStorage */ .$B)(function (ls) {
      return delete ls.visitorTrackingEnabled;
    });
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking = {};
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking[_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTrackingDomain] = {
      isEnabled: legacyIsEnabled,
      updatedAt: Date.now()
    };
    (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_1__/* .updateWistiaLocalStorage */ .$B)(function (ls) {
      return ls.visitorTracking = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking;
    });
  }
};
if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTrackingDomain) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTrackingDomain = location.hostname || '';
}

// Initialize from localStorage, or with an empty hash if not set.
if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking) {
  migrateLegacyVisitorTracking();
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking = (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_1__/* .getWistiaLocalStorage */ .y1)().visitorTracking || {};
}
var consent = function consent(val) {
  if (val == null) {
    return isVisitorTrackingEnabled();
  }
  return setVisitorTrackingEnabled(val);
};
_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s.consent = consent;
var setVisitorTrackingEnabled = function setVisitorTrackingEnabled(val) {
  var domain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTrackingDomain;
  if (val === 'default') {
    delete _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking[domain];
  } else {
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking[domain] = {
      isEnabled: "".concat(val) === 'true',
      updatedAt: Date.now()
    };
  }
  (0,utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_1__/* .updateWistiaLocalStorage */ .$B)(function (obj) {
    return obj.visitorTracking = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking;
  });
  (0,utilities_globalBindAndTrigger_js__WEBPACK_IMPORTED_MODULE_0__/* .globalTrigger */ .mj)('visitortrackingchange', val);
  var allWistiaPlayers = _toConsumableArray(document.getElementsByTagName('wistia-player'));
  allWistiaPlayers.forEach(function (player) {
    player.dispatchEvent(new CustomEvent('visitor-tracking-change', {
      detail: {
        isTrackingEnabled: val
      }
    }));
  });
};
var isCurrentDomainOrAnyParentDomainsEnabled = function isCurrentDomainOrAnyParentDomainsEnabled() {
  if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTrackingDomain) {
    var domainParts = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTrackingDomain.split('.');
    while (domainParts.length > 0) {
      var entry = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking[domainParts.join('.')];
      var enabledVal = entry && entry.isEnabled;
      if (enabledVal != null) {
        return enabledVal;
      }
      domainParts.shift();
    }
  }

  // returns undefined instead of false as a result so that we can have
  // different behavior if it has not been set.
};
var isVisitorTrackingEnabled = function isVisitorTrackingEnabled() {
  if (typeof _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking === 'boolean') {
    // Legacy. We previously persisted this data as a boolean
    return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking;
  }
  if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s._visitorTracking) {
    // _visitorTracking has been set. Let's check the value for the current
    // domain. And if that's set, we return.
    var isEnabledVal = isCurrentDomainOrAnyParentDomainsEnabled();
    if (isEnabledVal != null) {
      return Boolean(isEnabledVal);
    }
  }
  var apis = (0,utilities_getApiHandles_ts__WEBPACK_IMPORTED_MODULE_2__/* .getAllApiHandles */ .bp)();
  if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s.channel && _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s.channel.all) {
    try {
      apis.push.apply(apis, _toConsumableArray(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_3__/* .Wistia */ .s.channel.all()));
    } catch (e) {
      // If Wistia.api.all() is called before Wistia._data is setup, this will throw
      // an exception. That's okay--it just means there are effectively no
      // channel embeds yet.
    }
  }

  // By default, if any videos have privacy mode enabled, then we disable
  // visitor tracking for all videos on the page. In practice, we would only
  // see this occur if videos from multiple accounts--with different privacy
  // mode settings--appear on the same page.
  var isPrivacyModeEnabled = apis.some(function (api) {
    var data = api._mediaData || api._galleryData || {};
    return data.privacyMode === true;
  });
  return !isPrivacyModeEnabled;
};

/***/ }),

/***/ 4989:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ camelCaseToKebabCase),
/* harmony export */   b: () => (/* binding */ kebabCaseToCamelCase)
/* harmony export */ });
var camelCaseToKebabCase = function camelCaseToKebabCase(camelCaseString) {
  return camelCaseString.replace(/[A-Z]+(?![a-z])|[A-Z]/g, function (letter, idx) {
    return (idx !== undefined ? '-' : '') + letter.toLowerCase();
  });
};
var kebabCaseToCamelCase = function kebabCaseToCamelCase(kebabCaseString) {
  return kebabCaseString.replace(/-./g, function (word) {
    return word[1].toUpperCase();
  });
};

/***/ }),

/***/ 4997:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $B: () => (/* binding */ updateWistiaLocalStorage),
/* harmony export */   y1: () => (/* binding */ getWistiaLocalStorage)
/* harmony export */ });
/* unused harmony exports removeWistiaLocalStorage, setWistiaLocalStorage */
/* harmony import */ var utilities_namespacedLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2917);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);



// This localStorage utility can be used in situations where we don't need to
// do very frequent updates or reads. If frequent updates or reads are
// expected, you should use namespacedLocalStorage.js with its own namespace,
// since the entire namespace is deserialized and serialized on read and write
// respectively.

var WISTIA_NAMESPACE = 'wistia';
var getWistiaLocalStorage = function getWistiaLocalStorage() {
  return (0,utilities_namespacedLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__/* .getLocalStorage */ .Lg)(WISTIA_NAMESPACE);
};
var removeWistiaLocalStorage = function removeWistiaLocalStorage() {
  Wistia._localStorage = removeLocalStorage(WISTIA_NAMESPACE);
  return Wistia._localStorage;
};
var setWistiaLocalStorage = function setWistiaLocalStorage(obj) {
  Wistia._localStorage = setLocalStorage(WISTIA_NAMESPACE, obj);
  return Wistia._localStorage;
};
var updateWistiaLocalStorage = function updateWistiaLocalStorage(fn) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._localStorage = (0,utilities_namespacedLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__/* .updateLocalStorage */ .yo)(WISTIA_NAMESPACE, fn);
  return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s._localStorage;
};

/***/ }),

/***/ 5181:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FK: () => (/* binding */ k),
/* harmony export */   XX: () => (/* binding */ E),
/* harmony export */   fF: () => (/* binding */ l),
/* harmony export */   h: () => (/* binding */ _),
/* harmony export */   q6: () => (/* binding */ K),
/* harmony export */   uA: () => (/* binding */ x)
/* harmony export */ });
/* unused harmony exports cloneElement, createElement, createRef, hydrate, isValidElement, toChildArray */
var n,l,u,t,i,r,o,e,f,c,s,a,h,p={},y=[],v=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,w=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function g(n){n&&n.parentNode&&n.parentNode.removeChild(n)}function _(l,u,t){var i,r,o,e={};for(o in u)"key"==o?i=u[o]:"ref"==o?r=u[o]:e[o]=u[o];if(arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(o in l.defaultProps)null==e[o]&&(e[o]=l.defaultProps[o]);return m(l,e,i,r,null)}function m(n,t,i,r,o){var e={type:n,props:t,key:i,ref:r,__k:null,__:null,__b:0,__e:null,__c:null,constructor:void 0,__v:null==o?++u:o,__i:-1,__u:0};return null==o&&null!=l.vnode&&l.vnode(e),e}function b(){return{current:null}}function k(n){return n.children}function x(n,l){this.props=n,this.context=l}function S(n,l){if(null==l)return n.__?S(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?S(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!$.__r++||r!=l.debounceRendering)&&((r=l.debounceRendering)||o)($)}function $(){for(var n,u,t,r,o,f,c,s=1;i.length;)i.length>s&&i.sort(e),n=i.shift(),s=i.length,n.__d&&(t=void 0,o=(r=(u=n).__v).__e,f=[],c=[],u.__P&&((t=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(t),O(u.__P,t,r,u.__n,u.__P.namespaceURI,32&r.__u?[o]:null,f,null==o?S(r):o,!!(32&r.__u),c),t.__v=r.__v,t.__.__k[t.__i]=t,z(f,t,c),t.__e!=o&&C(t)));$.__r=0}function I(n,l,u,t,i,r,o,e,f,c,s){var a,h,v,w,d,g,_=t&&t.__k||y,m=l.length;for(f=P(u,l,_,f,m),a=0;a<m;a++)null!=(v=u.__k[a])&&(h=-1==v.__i?p:_[v.__i]||p,v.__i=a,g=O(n,v,h,i,r,o,e,f,c,s),w=v.__e,v.ref&&h.ref!=v.ref&&(h.ref&&q(h.ref,null,v),s.push(v.ref,v.__c||w,v)),null==d&&null!=w&&(d=w),4&v.__u||h.__k===v.__k?f=A(v,f,n):"function"==typeof v.type&&void 0!==g?f=g:w&&(f=w.nextSibling),v.__u&=-7);return u.__e=d,f}function P(n,l,u,t,i){var r,o,e,f,c,s=u.length,a=s,h=0;for(n.__k=new Array(i),r=0;r<i;r++)null!=(o=l[r])&&"boolean"!=typeof o&&"function"!=typeof o?(f=r+h,(o=n.__k[r]="string"==typeof o||"number"==typeof o||"bigint"==typeof o||o.constructor==String?m(null,o,null,null,null):w(o)?m(k,{children:o},null,null,null):null==o.constructor&&o.__b>0?m(o.type,o.props,o.key,o.ref?o.ref:null,o.__v):o).__=n,o.__b=n.__b+1,e=null,-1!=(c=o.__i=L(o,u,f,a))&&(a--,(e=u[c])&&(e.__u|=2)),null==e||null==e.__v?(-1==c&&(i>s?h--:i<s&&h++),"function"!=typeof o.type&&(o.__u|=4)):c!=f&&(c==f-1?h--:c==f+1?h++:(c>f?h--:h++,o.__u|=4))):n.__k[r]=null;if(a)for(r=0;r<s;r++)null!=(e=u[r])&&0==(2&e.__u)&&(e.__e==t&&(t=S(e)),B(e,e));return t}function A(n,l,u){var t,i;if("function"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=A(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=S(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8==l.nodeType);return l}function H(n,l){return l=l||[],null==n||"boolean"==typeof n||(w(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i,r,o=n.key,e=n.type,f=l[u];if(null===f&&null==n.key||f&&o==f.key&&e==f.type&&0==(2&f.__u))return u;if(t>(null!=f&&0==(2&f.__u)?1:0))for(i=u-1,r=u+1;i>=0||r<l.length;){if(i>=0){if((f=l[i])&&0==(2&f.__u)&&o==f.key&&e==f.type)return i;i--}if(r<l.length){if((f=l[r])&&0==(2&f.__u)&&o==f.key&&e==f.type)return r;r++}}return-1}function T(n,l,u){"-"==l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||v.test(l)?u:u+"px"}function j(n,l,u,t,i){var r;n:if("style"==l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||T(n.style,l,"");if(u)for(l in u)t&&u[l]==t[l]||T(n.style,l,u[l])}else if("o"==l[0]&&"n"==l[1])r=l!=(l=l.replace(f,"$1")),l=l.toLowerCase()in n||"onFocusOut"==l||"onFocusIn"==l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?t?u.u=t.u:(u.u=c,n.addEventListener(l,r?a:s,r)):n.removeEventListener(l,r?a:s,r);else{if("http://www.w3.org/2000/svg"==i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!=l&&"height"!=l&&"href"!=l&&"list"!=l&&"form"!=l&&"tabIndex"!=l&&"download"!=l&&"rowSpan"!=l&&"colSpan"!=l&&"role"!=l&&"popover"!=l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!=l[4]?n.removeAttribute(l):n.setAttribute(l,"popover"==l&&1==u?"":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=c++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,r,o,e,f,c,s){var a,h,p,y,v,_,m,b,S,C,M,$,P,A,H,L,T,j=u.type;if(null!=u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),o=[f=u.__e=t.__e]),(a=l.__b)&&a(u);n:if("function"==typeof j)try{if(b=u.props,S="prototype"in j&&j.prototype.render,C=(a=j.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?m=(h=u.__c=t.__c).__=h.__E:(S?u.__c=h=new j(b,M):(u.__c=h=new x(b,M),h.constructor=j,h.render=D),C&&C.sub(h),h.props=b,h.state||(h.state={}),h.context=M,h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),S&&null==h.__s&&(h.__s=h.state),S&&null!=j.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,j.getDerivedStateFromProps(b,h.__s))),y=h.props,v=h.state,h.__v=u,p)S&&null==j.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),S&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(S&&null==j.getDerivedStateFromProps&&b!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(b,M),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(b,h.__s,M)||u.__v==t.__v){for(u.__v!=t.__v&&(h.props=b,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.some(function(n){n&&(n.__=u)}),$=0;$<h._sb.length;$++)h.__h.push(h._sb[$]);h._sb=[],h.__h.length&&e.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(b,h.__s,M),S&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,v,_)})}if(h.context=M,h.props=b,h.__P=n,h.__e=!1,P=l.__r,A=0,S){for(h.state=h.__s,h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,P&&P(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++A<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),S&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(y,v)),L=a,null!=a&&a.type===k&&null==a.key&&(L=N(a.props.children)),f=I(n,w(L)?L:[L],u,t,i,r,o,e,f,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&e.push(h),m&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=o)if(n.then){for(u.__u|=c?160:128;f&&8==f.nodeType&&f.nextSibling;)f=f.nextSibling;o[o.indexOf(f)]=null,u.__e=f}else for(T=o.length;T--;)g(o[T]);else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t)}else null==o&&u.__v==t.__v?(u.__k=t.__k,u.__e=t.__e):f=u.__e=V(t.__e,u,t,i,r,o,e,c,s);return(a=l.diffed)&&a(u),128&u.__u?void 0:f}function z(n,u,t){for(var i=0;i<t.length;i++)q(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function N(n){return"object"!=typeof n||null==n||n.__b&&n.__b>0?n:w(n)?n.map(N):d({},n)}function V(u,t,i,r,o,e,f,c,s){var a,h,y,v,d,_,m,b=i.props,k=t.props,x=t.type;if("svg"==x?o="http://www.w3.org/2000/svg":"math"==x?o="http://www.w3.org/1998/Math/MathML":o||(o="http://www.w3.org/1999/xhtml"),null!=e)for(a=0;a<e.length;a++)if((d=e[a])&&"setAttribute"in d==!!x&&(x?d.localName==x:3==d.nodeType)){u=d,e[a]=null;break}if(null==u){if(null==x)return document.createTextNode(k);u=document.createElementNS(o,x,k.is&&k),c&&(l.__m&&l.__m(t,e),c=!1),e=null}if(null==x)b===k||c&&u.data==k||(u.data=k);else{if(e=e&&n.call(u.childNodes),b=i.props||p,!c&&null!=e)for(b={},a=0;a<u.attributes.length;a++)b[(d=u.attributes[a]).name]=d.value;for(a in b)if(d=b[a],"children"==a);else if("dangerouslySetInnerHTML"==a)y=d;else if(!(a in k)){if("value"==a&&"defaultValue"in k||"checked"==a&&"defaultChecked"in k)continue;j(u,a,null,d,o)}for(a in k)d=k[a],"children"==a?v=d:"dangerouslySetInnerHTML"==a?h=d:"value"==a?_=d:"checked"==a?m=d:c&&"function"!=typeof d||b[a]===d||j(u,a,d,b[a],o);if(h)c||y&&(h.__html==y.__html||h.__html==u.innerHTML)||(u.innerHTML=h.__html),t.__k=[];else if(y&&(u.innerHTML=""),I("template"==t.type?u.content:u,w(v)?v:[v],t,i,r,"foreignObject"==x?"http://www.w3.org/1999/xhtml":o,e,f,e?e[0]:i.__k&&S(i,0),c,s),null!=e)for(a=e.length;a--;)g(e[a]);c||(a="value","progress"==x&&null==_?u.removeAttribute("value"):null!=_&&(_!==u[a]||"progress"==x&&!_||"option"==x&&_!=b[a])&&j(u,a,_,b[a],o),a="checked",null!=m&&m!=u[a]&&j(u,a,m,b[a],o))}return u}function q(n,u,t){try{if("function"==typeof n){var i="function"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function B(n,u,t){var i,r;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!=n.__e||q(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(r=0;r<i.length;r++)i[r]&&B(i[r],u,t||"function"!=typeof n.type);t||g(n.__e),n.__c=n.__=n.__e=void 0}function D(n,l,u){return this.constructor(n,u)}function E(u,t,i){var r,o,e,f;t==document&&(t=document.documentElement),l.__&&l.__(u,t),o=(r="function"==typeof i)?null:i&&i.__k||t.__k,e=[],f=[],O(t,u=(!r&&i||t).__k=_(k,null,[u]),o||p,p,t.namespaceURI,!r&&i?[i]:o?null:t.firstChild?n.call(t.childNodes):null,e,!r&&i?i:o?o.__e:t.firstChild,r,f),z(e,u,f)}function G(n,l){E(n,l,G)}function J(l,u,t){var i,r,o,e,f=d({},l.props);for(o in l.type&&l.type.defaultProps&&(e=l.type.defaultProps),u)"key"==o?i=u[o]:"ref"==o?r=u[o]:f[o]=null==u[o]&&null!=e?e[o]:u[o];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),m(l.type,f,i||l.key,r||l.ref,null)}function K(n){function l(n){var u,t;return this.getChildContext||(u=new Set,(t={})[l.__c]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!=n.value&&u.forEach(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.add(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.delete(n),l&&l.call(n)}}),n.children}return l.__c="__cC"+h++,l.__=n,l.Provider=l.__l=(l.Consumer=function(n,l){return n.children(l)}).contextType=l,l}n=y.slice,l={__e:function(n,l,u,t){for(var i,r,o;l=l.__;)if((i=l.__c)&&!i.__)try{if((r=i.constructor)&&null!=r.getDerivedStateFromError&&(i.setState(r.getDerivedStateFromError(n)),o=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),o=i.__d),o)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},x.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!=this.state?this.__s:this.__s=d({},this.state),"function"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},x.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},x.prototype.render=k,i=[],o="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,e=function(n,l){return n.__v.__b-l.__v.__b},$.__r=0,f=/(PointerCapture)$|Capture$/i,c=0,s=F(!1),a=F(!0),h=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ 5393:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ inferPageUrl)
/* harmony export */ });
/**
 * Infer the url of the page best we can
 * @returns {string} the url of the page
 */
var inferPageUrl = function inferPageUrl() {
  var _window$FreshUrl;
  if (((_window$FreshUrl = window.FreshUrl) === null || _window$FreshUrl === void 0 ? void 0 : _window$FreshUrl.originalUrl) != null) {
    return window.FreshUrl.originalUrl;
  }
  if (window.top === window.self) {
    return window.location.href || '';
  }
  return document.referrer || '';
};

/***/ }),

/***/ 5417:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ Color)
/* harmony export */ });
/* unused harmony export addHashToHex */
/* harmony import */ var _color_utils_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(998);
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Logic adapted from this Javascript Color class:
// https://github.com/moagrius/Color/blob/master/Color.js
//
// HSL to RGB logic (broken in Color class) taken from:
// http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript



// LRGB color blending taken from chroma-js:
// https://github.com/gka/chroma.js/blob/main/src/interpolator/lrgb.js

// ## Regular expressions ##
var rHex = /^#?([0-9a-f]{3,4}|[0-9a-f]{6,8})$/i;
var rRgb = /^rgba?\((\d{1,3}(?:\.\d+)?%?),\s*(\d{1,3}(?:\.\d+)?%?),\s*(\d{1,3}(?:\.\d+)?%?)(?:,\s*([01]?\.?\d*))?\)$/;
var rPercent = /^\d+(\.\d+)*%$/;
var hexBit = /([0-9a-f])/gi;
var p2v = function p2v(p) {
  if (rPercent.test(p)) {
    return parseFloat(p) * 2.55;
  }
  return p;
};
var hue2rgb = function hue2rgb(a, b, c) {
  if (c < 0) {
    c += 1;
  }
  if (c > 1) {
    c -= 1;
  }
  if (c < 1 / 6) {
    return a + (b - a) * 6 * c;
  }
  if (c < 1 / 2) {
    return b;
  }
  if (c < 2 / 3) {
    return a + (b - a) * (2 / 3 - c) * 6;
  }
  return a;
};
var Color = /*#__PURE__*/function () {
  // ## Constructor ##
  //
  // Construct our own color representation either from an
  // existing color, or a color string.
  function Color(input) {
    _classCallCheck(this, Color);
    if (input instanceof Color) {
      this.r = input.r;
      this.g = input.g;
      this.b = input.b;
      this.a = input.a;
    } else if (input) {
      this.parse(input);
    } else {
      this.r = this.g = this.b = 0;
      this.a = 1;
    }
  }

  // ## Parse ##
  //
  // Accept #RRGGBB, #RRGGBBAA, rgba(R,G,B), or rgba(R,G,B,A) formats
  // as well as [r, g, b, a].
  // The rgb formats also allows percents.
  return _createClass(Color, [{
    key: "parse",
    value: function parse(input) {
      if (Array.isArray(input)) {
        var _input$;
        this.r = input[0];
        this.g = input[1];
        this.b = input[2];
        this.a = (_input$ = input[3]) !== null && _input$ !== void 0 ? _input$ : 1;
      } else if (rHex.test(input)) {
        input = String(input);
        var stripped = input.replace(/^#/, '');
        if (stripped.length === 3 || stripped.length === 4) {
          stripped = stripped.replace(hexBit, '$1$1');
        }
        this.r = parseInt(stripped.substr(0, 2), 16);
        this.g = parseInt(stripped.substr(2, 2), 16);
        this.b = parseInt(stripped.substr(4, 2), 16);
        if (stripped.length === 8) {
          this.a = parseInt(stripped.substr(6, 2), 16) / 255;
        } else {
          this.a = 1;
        }
      } else if (rRgb.test(input)) {
        input = String(input);
        var parts = input.match(rRgb);
        this.r = parseFloat(p2v(parts[1]));
        this.g = parseFloat(p2v(parts[2]));
        this.b = parseFloat(p2v(parts[3]));
        if (parts[4]) {
          this.a = parseFloat(parts[4]);
        } else {
          this.a = 1;
        }
      }
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Color(this);
    }

    // Compute internal HSL values based on internal RGB values.
  }, {
    key: "_hslFromRgb",
    value: function _hslFromRgb() {
      var _rgbToHsl = (0,_color_utils_ts__WEBPACK_IMPORTED_MODULE_0__/* .rgbToHsl */ .K6)([this.r, this.g, this.b]),
        hue = _rgbToHsl.hue,
        saturation = _rgbToHsl.saturation,
        lightness = _rgbToHsl.lightness;
      this._h = hue;
      this._s = saturation;
      this._l = lightness;
      return this;
    }

    // Compute internal RGB values based on internal HSL values.
  }, {
    key: "_rgbFromHsl",
    value: function _rgbFromHsl() {
      var h = this._h / 360;
      var s = this._s / 100;
      var l = this._l / 100;
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      this.r = hue2rgb(p, q, h + 1 / 3) * 255;
      this.g = hue2rgb(p, q, h) * 255;
      this.b = hue2rgb(p, q, h - 1 / 3) * 255;
      return this;
    }

    // Do math to blend a channel with a different value. Alpha is
    // the strength of the blend.
  }, {
    key: "blendChannel",
    value: function blendChannel(channel, value, alpha, shouldUseLrgb) {
      if (shouldUseLrgb) {
        this[channel] = Math.sqrt(Math.pow(this[channel], 2) * (1 - alpha) + Math.pow(value, 2) * alpha);
        return this;
      }
      this[channel] = alpha * value + (1 - alpha) * this[channel];
      return this;
    }

    // Blend this color with another color by blending each RGB
    // channel individually.
  }, {
    key: "blend",
    value: function blend(color, alpha, shouldUseLrgb) {
      color = new Color(color);
      this.blendChannel('r', color.r, alpha, shouldUseLrgb);
      this.blendChannel('g', color.g, alpha, shouldUseLrgb);
      this.blendChannel('b', color.b, alpha, shouldUseLrgb);
      return this;
    }

    // background color can be a string or a Color
  }, {
    key: "getContrastRatio",
    value: function getContrastRatio(backgroundColor) {
      return (0,_color_utils_ts__WEBPACK_IMPORTED_MODULE_0__/* .getContrast */ .bJ)(this.toHexWithHash(), new Color(backgroundColor).toHexWithHash());
    }

    // background color can be a string or a Color
    // shape will be a key of colorContrastRatiosByShape
  }, {
    key: "hasAccessibleContrast",
    value: function hasAccessibleContrast(backgroundColor, shape) {
      return this.getContrastRatio(backgroundColor) >= _color_utils_ts__WEBPACK_IMPORTED_MODULE_0__/* .colorContrastRatiosByShape */ .s1[shape];
    }
  }, {
    key: "hue",
    value: function hue() {
      this._hslFromRgb();
      return this._h;
    }

    // Increase a channel by a fixed value, but within the [0,255] range.
  }, {
    key: "lightenChannel",
    value: function lightenChannel(channel, steps) {
      this[channel] += steps;
      if (this[channel] < 0) {
        this[channel] = 0;
      } else if (this[channel] > 255) {
        this[channel] = 255;
      }
      return this;
    }

    // Lighten this color by increasing each channel by a fixed value.
  }, {
    key: "lighten",
    value: function lighten(steps) {
      if (this.looksLikePercent(steps)) {
        this.lightness(this.lightness() + parseFloat(steps));
      } else {
        this.lightenChannel('r', steps);
        this.lightenChannel('g', steps);
        this.lightenChannel('b', steps);
      }
      return this;
    }
  }, {
    key: "darken",
    value: function darken(steps) {
      if (typeof steps === 'string') {
        return this.lighten("-".concat(steps));
      }
      return this.lighten(-steps);
    }
  }, {
    key: "looksLikePercent",
    value: function looksLikePercent(str) {
      return /^-?\d+(\.\d+)?%$/.test(str);
    }

    // Set the lightness of this color by modifying the L value in
    // HSL, then recomputing the RGB.
    //
    // No args gets the current lightness.
  }, {
    key: "lightness",
    value: function lightness(l) {
      this._hslFromRgb();
      if (l != null) {
        this._l = Math.max(0, Math.min(100, l));
        this._rgbFromHsl();
        return this;
      }
      return this._l;
    }

    // Set the saturation of this color by modifying the S value in
    // HSL, then recomputing the RGB.
    //
    // No args gets the current saturation.
  }, {
    key: "saturation",
    value: function saturation(s) {
      this._hslFromRgb();
      if (s != null) {
        this._s = Math.max(0, Math.min(100, s));
        this._rgbFromHsl();
        return this;
      }
      return this._s;
    }
  }, {
    key: "setHue",
    value: function setHue(hueValue) {
      this._hslFromRgb();
      if (hueValue != null) {
        this._h = Math.max(0, Math.min(360, hueValue));
        this._rgbFromHsl();
        return this;
      }
    }
  }, {
    key: "shade",
    value: function shade(percentage, shouldUseLrgb) {
      return this.blend('#000000', percentage, shouldUseLrgb);
    }

    // Gray level accounts for the strength of each individual channel.
    // This is more visually accurate than just averaging all the channels.
  }, {
    key: "grayLevel",
    value: function grayLevel() {
      return (0.299 * this.r + 0.587 * this.g + 0.114 * this.b) / 255;
    }
  }, {
    key: "tint",
    value: function tint(percentage, shouldUseLrgb) {
      return this.blend('#ffffff', percentage, shouldUseLrgb);
    }

    // The white level is basically paleness, and is determined by the
    // minimum of all the RGB channels.
  }, {
    key: "whiteLevel",
    value: function whiteLevel() {
      return Math.min(Math.min(this.r, this.g), this.b);
    }
  }, {
    key: "getRelativeLuminance",
    value: function getRelativeLuminance() {
      // For reference on calculating relative luminance: https://www.w3.org/WAI/GL/wiki/Relative_luminance
      var adjustChannel = function adjustChannel(givenVal) {
        var val = givenVal * 0.003921569; // 1 / 255 = 0.003921569; avoiding division
        if (val <= 0.03928) {
          return val / 12.92;
        }
        return Math.pow((val + 0.055) / 1.055, 2.4);
      };
      var rAdjusted = adjustChannel(this.r);
      var gAdjusted = adjustChannel(this.g);
      var bAdjusted = adjustChannel(this.b);
      return 0.2126 * rAdjusted + 0.7152 * gAdjusted + 0.0722 * bAdjusted;
    }
  }, {
    key: "isDark",
    value: function isDark(shouldUseRL) {
      if (shouldUseRL) {
        return this.getRelativeLuminance() < 0.15;
      }
      return this.grayLevel() <= 0.4;
    }
  }, {
    key: "isLight",
    value: function isLight(shouldUseRL) {
      if (shouldUseRL) {
        return this.getRelativeLuminance() >= 0.8;
      }
      return this.grayLevel() > 0.4;
    }
  }, {
    key: "isGrayscale",
    value: function isGrayscale() {
      return this.r === this.g && this.g === this.b;
    }
  }, {
    key: "distanceFrom",
    value: function distanceFrom(color) {
      return Math.sqrt(Math.pow(this.r - color.r, 2) + Math.pow(this.g - color.g, 2) + Math.pow(this.b - color.b, 2));
    }
  }, {
    key: "channelDominance",
    value: function channelDominance() {
      var _this = this;
      return ['r', 'g', 'b'].sort(function (a, b) {
        return _this[b] - _this[a];
      });
    }
  }, {
    key: "alpha",
    value: function alpha(a) {
      if (a != null) {
        this.a = a;
        return this;
      }
      return this.a;
    }
  }, {
    key: "red",
    value: function red(r) {
      if (r != null) {
        this.r = r;
        return this;
      }
      return this.r;
    }
  }, {
    key: "green",
    value: function green(g) {
      if (g != null) {
        this.g = g;
        return this;
      }
      return this.g;
    }
  }, {
    key: "blue",
    value: function blue(b) {
      if (b != null) {
        this.b = b;
        return this;
      }
      return this.b;
    }
  }, {
    key: "toHex",
    value: function toHex() {
      var r = Math.round(this.r).toString(16);
      var g = Math.round(this.g).toString(16);
      var b = Math.round(this.b).toString(16);
      if (r.length === 1) {
        r = "0".concat(r);
      }
      if (g.length === 1) {
        g = "0".concat(g);
      }
      if (b.length === 1) {
        b = "0".concat(b);
      }
      return "".concat(r).concat(g).concat(b);
    }
  }, {
    key: "toHexWithAlpha",
    value: function toHexWithAlpha() {
      var a = Math.round(this.a * 255).toString(16);
      if (a.length === 1) {
        a = "0".concat(a);
      }
      return "".concat(a).concat(this.toHex());
    }
  }, {
    key: "toHexWithHash",
    value: function toHexWithHash() {
      return "#".concat(this.toHex());
    }
  }, {
    key: "toRgb",
    value: function toRgb() {
      return "rgb(".concat(Math.round(this.r), ",").concat(Math.round(this.g), ",").concat(Math.round(this.b), ")");
    }
  }, {
    key: "toRgba",
    value: function toRgba() {
      return "rgba(".concat(Math.round(this.r), ",").concat(Math.round(this.g), ",").concat(Math.round(this.b), ",").concat(this.a, ")");
    }
  }, {
    key: "toRgbaOrHex",
    value: function toRgbaOrHex() {
      return this.toRgba();
    }
  }, {
    key: "toPercent",
    value: function toPercent() {
      return "rgba(".concat(this.r / 255 * 100, "%,").concat(this.g / 255 * 100, "%,").concat(this.b / 255 * 100, "%,").concat(this.a, ")");
    }

    // IE8 and below don't support RGBA, but we can use this gradient hack to
    // do the same thing. The catch is that it functions as a background image
    // instead of a color, and therefore overrides other background images in IE.
    //
    // This should go after a `filter` CSS property.
  }, {
    key: "toIeGradient",
    value: function toIeGradient() {
      return "progid:DXImageTransform.Microsoft.gradient(startColorStr='#".concat(this.toHexWithAlpha(), "', endColorStr='#").concat(this.toHexWithAlpha(), "')");
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toPercent();
    }
  }]);
}();

// @param {string} hex
// @return {string}
var addHashToHex = function addHashToHex(hex) {
  // return if already has hash
  if (hex.charAt(0) === '#') {
    return hex;
  }
  return "#".concat(hex);
};

/***/ }),

/***/ 5509:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ Wistia)
/* harmony export */ });
/* harmony import */ var _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8176);
var _objectHasOwn = function (object, property) {
  if (typeof object === 'undefined' || object === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
};
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable no-console */

if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia = {};
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._destructors == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._destructors = {};
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._initializers == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._initializers = {};
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._remoteData == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._remoteData = new Map();
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.api == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.api = function () {
    console.error('Accessed Wistia.api() before it was initialized');
    return null;
  };
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.defineControl == null) {
  // this will be overwritten in _async.coffee
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.defineControl = function () {
    console.error('Accessed Wistia.defineControl() before it was initialized');
    return null;
  };
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.EventShepherdManager == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.EventShepherdManager = {};
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.mixin == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.mixin = function (klass) {
    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Object.keys(obj).forEach(function (key) {
      if (_objectHasOwn(obj, key)) {
        // eslint-disable-next-line no-param-reassign
        klass[key] = obj[key];
      }
    });
  };
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.playlistMethods == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.playlistMethods = new Map();
}

// will be overwritten in _public_api.coffee
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.PublicApi == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.PublicApi = null;
}

// will be overwritten in _remote_data.js
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.uncacheMedia == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.uncacheMedia = function () {
    console.error('Accessed Wistia.uncacheMedia() before it was initialized');
    return null;
  };
}

// will be overwritten in _visitor_key.js
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.VisitorKey == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.VisitorKey = null;
}

// will be overwritten in _visitor_key.js
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.visitorKey == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.visitorKey = null;
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.wistia == null) {
  // will be overwritten in WistiaPlayer.tsx
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia.wistia = undefined;
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._mediaDataPromises == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._mediaDataPromises = {};
}
if (_utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._liveStreamPollingPromises == null) {
  _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia._liveStreamPollingPromises = {};
}
var Wistia = _utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.Wistia;

/***/ }),

/***/ 5510:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bp: () => (/* binding */ getAllApiHandles)
/* harmony export */ });
/* unused harmony exports getAllInitializedEmbedApiHandles, getAllIframeApiHandles, getOneApiHandle, getOneApiHandleFromHashedId, getAllApiHandlesByDomOrder */
/* harmony import */ var _wlog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6637);
/* harmony import */ var _wistiaData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3997);
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }



/**
 * Initialized embeds are API embeds that have a wistiaApi property set on the
 * container. container.wistiaApi is set on legacy embeds in _public_api.js
 * @returns {PublicApi[]}
 */
var getAllInitializedEmbedApiHandles = function getAllInitializedEmbedApiHandles() {
  if ((0,_wistiaData_js__WEBPACK_IMPORTED_MODULE_1__/* .wData */ .m)('video') === undefined) {
    return [];
  }
  return Object.values((0,_wistiaData_js__WEBPACK_IMPORTED_MODULE_1__/* .wData */ .m)('video'));
};

/**
 * Get all initialized instances of the iframe api
 * @returns {PublicApi[]}
 */
var getAllIframeApiHandles = function getAllIframeApiHandles() {
  if ((0,_wistiaData_js__WEBPACK_IMPORTED_MODULE_1__/* .wData */ .m)('iframe_api') === undefined) {
    return [];
  }
  return Object.values((0,_wistiaData_js__WEBPACK_IMPORTED_MODULE_1__/* .wData */ .m)('iframe_api'));
};

/**
 * Get all initialized instances of the API, inclusive of both
 * iframe API and regular embed public API
 * @returns {PublicApi[]}
 */
var getAllApiHandles = function getAllApiHandles() {
  return getAllInitializedEmbedApiHandles().concat(getAllIframeApiHandles());
};

/**
 * Get a single API handle by matcher
 * @param {Function | HTMLElement | number | string | undefined} matcher - The matcher
 * @returns {PublicApi | null}
 */
var getOneApiHandle = function getOneApiHandle(matcher
// fn?: MatcherFunction | undefined, // TODO: Handle the case where functions are provided
) {
  var _container, _container2;
  // If no matcher is provided, return the first api handle
  if (matcher === undefined) {
    var _getAllApiHandles$;
    return (_getAllApiHandles$ = getAllApiHandles()[0]) !== null && _getAllApiHandles$ !== void 0 ? _getAllApiHandles$ : null;
  }

  /* TODO: Handle the case where functions are provided to completely replicate
   * the original behavior of the `Wistia.api` function from _async.coffee
   * This will also require us to port over the Wistia.api.onFind function
   *
  // If a callback is provided, return the first api handle that matches
  if (fn !== undefined) {
    return onFindApiHandle(matcher, fn);
  }
   // If the matcher provided is a function, return the first api handle that matches
  if (typeof matcher === 'function') {
    return onFindApiHandle(matcher);
  }
   *
   * END TODO
   */

  var container = null;
  if (typeof matcher === 'string') {
    var _document$querySelect;
    var query = matcher;

    // Find by DOM ID
    // Prefer unique-id attribute over id attribute
    container = (_document$querySelect = document.querySelector("[unique-id='".concat(query, "']"))) !== null && _document$querySelect !== void 0 ? _document$querySelect : document.getElementById(query);

    // Or find by fuzzy match on hashed ID or container
    if (container === null) {
      var apiHandles = getAllApiHandles();
      var matchedHandle = apiHandles.find(function (handle) {
        var _handle$hashedId, _handle$container;
        // note: eslint flagged the logical OR below but it's intentional and necessary
        // see: https://github.com/wistia/player-modern/pull/2964#discussion_r1274876654

        if ((_handle$hashedId = handle.hashedId()) !== null && _handle$hashedId !== void 0 && _handle$hashedId.startsWith(query) || (_handle$container = handle.container) !== null && _handle$container !== void 0 && _handle$container.id.startsWith(query)) {
          return handle;
        }
        return null;
      });
      if (matchedHandle !== 'removed') {
        var _ref;
        container = (_ref = matchedHandle === null || matchedHandle === void 0 ? void 0 : matchedHandle.container) !== null && _ref !== void 0 ? _ref : null;
      }
    }
  } else if (typeof matcher === 'number') {
    var index = matcher;
    var _apiHandles = getAllApiHandles();
    // Allow negative indices to get from the end
    if (index < 0) {
      index = _apiHandles.length + index;
    }
    var apiHandle = _apiHandles[index];
    if (apiHandle !== undefined && apiHandle !== 'removed') {
      var _apiHandle$container;
      container = (_apiHandle$container = apiHandle.container) !== null && _apiHandle$container !== void 0 ? _apiHandle$container : null;
    }
  } else if (matcher instanceof HTMLElement) {
    container = matcher;
  } else {
    wlog.error('Unrecognized matcher', matcher);
  }

  // If our container is a wistia-player web component, it handles its own API
  // and we can just return it.
  if (((_container = container) === null || _container === void 0 ? void 0 : _container.tagName) === 'WISTIA-PLAYER') {
    // TODO: We need to call the PublicApi methods for now, but once WistiaPlayer
    // is more built out we should be able to just send that over directly
    return container.deprecatedApiDoNotUse;
  }

  // If the container has an API handle that isn't 'removed', return it
  // More on 'removed': https://github.com/wistia/player-modern/pull/1280
  if (((_container2 = container) === null || _container2 === void 0 ? void 0 : _container2.wistiaApi) !== undefined && container.wistiaApi !== 'removed') {
    return container.wistiaApi;
  }
  return null;
};

/**
 * Get a single API handle by ONLY hashed id, not by container id
 * @param {number | string | undefined} hashedId
 * @returns {PublicApi | null}
 */
var getOneApiHandleFromHashedId = function getOneApiHandleFromHashedId(hashedId) {
  var _container3, _container4;
  var container = null;
  var query = hashedId;

  // Find by fuzzy match on hashed ID
  var apiHandles = getAllApiHandles();
  var matchedHandle = apiHandles.find(function (handle) {
    var _handle$hashedId2;
    if ((_handle$hashedId2 = handle.hashedId()) !== null && _handle$hashedId2 !== void 0 && _handle$hashedId2.startsWith(query)) {
      return handle;
    }
    return null;
  });
  if (matchedHandle !== 'removed') {
    var _ref2;
    container = (_ref2 = matchedHandle === null || matchedHandle === void 0 ? void 0 : matchedHandle.container) !== null && _ref2 !== void 0 ? _ref2 : null;
  }

  // If our container is a wistia-player web component, it handles its own API
  // and we can just return it.
  if (((_container3 = container) === null || _container3 === void 0 ? void 0 : _container3.tagName) === 'WISTIA-PLAYER') {
    // TODO: We need to call the PublicApi methods for now, but once WistiaPlayer
    // is more built out we should be able to just send that over directly
    return container.deprecatedApiDoNotUse;
  }

  // If the container has an API handle that isn't 'removed', return it
  // More on 'removed': https://github.com/wistia/player-modern/pull/1280
  if (((_container4 = container) === null || _container4 === void 0 ? void 0 : _container4.wistiaApi) !== undefined && container.wistiaApi !== 'removed') {
    return container.wistiaApi;
  }
  return null;
};

/**
 * Get all (non-iframe) API handles in the order they appear in the DOM
 * @returns {PublicApi[]}
 */
var getAllApiHandlesByDomOrder = function getAllApiHandlesByDomOrder() {
  // Legacy embeds have a wistia_embed_initialized class added to the container
  // when their public api is initialized and set (container.wistiaApi)
  var legacyHandles = Array.from(getAllApiEmbedElements('wistia_embed_initialized')).reduce(function (accumulator, legacyContainer) {
    // Make sure the api has been initialized, set, and is not marked as 'removed'
    if (legacyContainer.wistiaApi !== undefined && legacyContainer.wistiaApi !== 'removed' && legacyContainer.wistiaApi !== null) {
      accumulator.push(legacyContainer.wistiaApi);
    }
    return accumulator;
  }, []);
  var wistiaPlayerHandles = Array.from(document.querySelectorAll('wistia-player')).reduce(function (accumulator, container) {
    if (container.deprecatedApiDoNotUse !== undefined && container.deprecatedApiDoNotUse !== 'removed' && container.deprecatedApiDoNotUse !== null) {
      accumulator.push(container.deprecatedApiDoNotUse);
    }
    return accumulator;
  }, []);
  return [].concat(_toConsumableArray(legacyHandles), _toConsumableArray(wistiaPlayerHandles));
};

/***/ }),

/***/ 5819:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ Thumbnail)
/* harmony export */ });
/* harmony import */ var utilities_image_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4635);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5181);
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(731);
/* harmony import */ var utilities_elem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7715);
/* harmony import */ var _translations_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4730);
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == typeof e || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }





(0,_translations_js__WEBPACK_IMPORTED_MODULE_4__/* .defineTranslations */ .Oj)('en-US', {
  THUMBNAIL_VIDEO_THUMBNAIL: 'Video Thumbnail'
});
var Thumbnail = /*#__PURE__*/function (_Component) {
  function Thumbnail(props) {
    var _this;
    _classCallCheck(this, Thumbnail);
    _this = _callSuper(this, Thumbnail, [props]);
    _this.initialState = _this.state = {
      isLoaded: false,
      isDisplaying: false
    };
    _this.onDisplay = _this.props.onDisplay;
    return _this;
  }
  _inherits(Thumbnail, _Component);
  return _createClass(Thumbnail, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.images !== this.props.images) {
        // clear the cache if we're changing which images to operate on.
        this._sortedImages = null;
        this.setState({
          isLoaded: false,
          isDisplaying: false
        });
      }
      if (!this.onDisplay && nextProps.onDisplay) {
        this.onDisplay = nextProps.onDisplay;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var altText = this.props.thumbnailAltText !== undefined ? this.props.thumbnailAltText : this.translate('VIDEO_THUMBNAIL');
      return (0,preact__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
        style: this.wrapperStyle(),
        class: "w-css-reset"
      }, (0,preact__WEBPACK_IMPORTED_MODULE_1__.h)("img", {
        class: "w-css-reset",
        srcset: this.props.images.length > 1 ? this.srcSet() : null,
        src: this.bestSrc(),
        style: this.imgStyle(),
        alt: altText,
        ref: function ref(e) {
          return _this2.imgElem = e;
        },
        "aria-hidden": this.props.ariaHidden ? 'true' : null
      }));
    }
  }, {
    key: "translate",
    value: function translate(key) {
      return (0,_translations_js__WEBPACK_IMPORTED_MODULE_4__/* .getTranslation */ .sC)(this.props.playerLanguage, "THUMBNAIL_".concat(key));
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setStateBasedOnImgStatus();
      this.maybeCallOnDisplay(this.initialState);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      this.setStateBasedOnImgStatus();
      this.maybeCallOnDisplay(prevState);
    }
  }, {
    key: "maybeCallOnDisplay",
    value: function maybeCallOnDisplay() {
      if (this.onDisplay && this.state.isDisplaying && !this.calledOnDisplay) {
        // There may be components outside the thumbnail that depend on this.
        // For example, we might not want to show controls until the thumbnail
        // is displayed.
        this.calledOnDisplay = true;
        this.onDisplay();
      }
    }
  }, {
    key: "setStateBasedOnImgStatus",
    value: function setStateBasedOnImgStatus() {
      var _this3 = this;
      var state = this.state;
      var imgElem = this.imgElem;
      if (state.isLoaded) {
        return;
      }
      if (!imgElem.onload) {
        imgElem.onload = function () {
          if ((0,utilities_elem_js__WEBPACK_IMPORTED_MODULE_3__/* .elemInDom */ .lj)(imgElem)) {
            _this3.setState({
              isLoaded: true,
              isDisplaying: true
            });
          }
        };
      }
      if (imgElem.complete) {
        this.setState({
          isLoaded: true,
          isDisplaying: true
        });
      }
    }
  }, {
    key: "wrapperStyle",
    value: function wrapperStyle() {
      var shouldShow = this.state.isDisplaying && this.props.isVisible;
      return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__/* .assign */ .kp)({}, this.props.wrapperStyle, {
        display: this.state.isLoaded && !shouldShow ? 'none' : 'block'
      });
    }
  }, {
    key: "baseStyle",
    value: function baseStyle() {
      var fitStrategy = this.props.fitStrategy;
      if (fitStrategy === 'cover') {
        return this.coverStyle();
      }
      if (fitStrategy === 'contain') {
        return this.containStyle();
      }
      if (fitStrategy === 'fill') {
        return this.fillStyle();
      }
      if (fitStrategy === 'naturalHeight') {
        return this.naturalHeightStyle();
      }
      return this.containStyle();
    }
  }, {
    key: "imgStyle",
    value: function imgStyle() {
      var shouldShow = this.state.isDisplaying && this.props.isVisible;
      return (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__/* .assign */ .kp)(this.baseStyle(), {
        // We use position/clip to hide/show the thumbnail until it has loaded
        // because the img may not try to load if it's not visible. But after
        // it's loaded, we use display: none/block to defeat over-aggressive css
        // that might do something like position: static !important.
        clip: shouldShow ? 'auto' : 'rect(0,0,0,0)',
        display: this.state.isLoaded && !shouldShow ? 'none' : 'block',
        borderRadius: "".concat(this.props.playerBorderRadius, "px")
      });
    }
  }, {
    key: "containStyle",
    value: function containStyle() {
      return {
        backgroundColor: this.props.backgroundColor || '#000',
        height: '100%',
        objectFit: 'contain',
        position: 'absolute',
        width: '100%',
        top: 0,
        left: 0
      };
    }
  }, {
    key: "coverStyle",
    value: function coverStyle() {
      // IE11 does not support objectFit. Screw em.
      return {
        height: '100%',
        objectFit: 'cover',
        position: 'absolute',
        width: '100%'
      };
    }
  }, {
    key: "fillStyle",
    value: function fillStyle() {
      // Though object-fit will be ignored, this will work in IE1 because the
      // default is to stretch the image.
      return {
        height: '100%',
        objectFit: 'fill',
        position: 'absolute',
        width: '100%'
      };
    }
  }, {
    key: "naturalHeightStyle",
    value: function naturalHeightStyle() {
      return {
        width: '100%',
        position: 'relative'
      };
    }
  }, {
    key: "bestSrc",
    value: function bestSrc() {
      return (0,utilities_image_js__WEBPACK_IMPORTED_MODULE_0__/* .bestImage */ .cd)(this.props.images, {
        videoWidth: this.props.videoWidth,
        videoHeight: this.props.videoHeight
      }).url;
    }
  }, {
    key: "srcSet",
    value: function srcSet() {
      var sortedImages = this.sortedImages();
      if (sortedImages.length === 0) {
        sortedImages = [(0,utilities_image_js__WEBPACK_IMPORTED_MODULE_0__/* .blankImage */ .YG)(this.props.videoWidth, this.props.videoHeight)];
      }
      return sortedImages.map(function (image) {
        return "".concat(image.url, " ").concat(image.width, "w");
      }).join(', ');
    }
  }, {
    key: "sortedImages",
    value: function sortedImages() {
      if (this._sortedImages) {
        return this._sortedImages;
      }
      this._sortedImages = (0,utilities_image_js__WEBPACK_IMPORTED_MODULE_0__/* .sortedImages */ .eZ)(this.props.images);
      return this._sortedImages;
    }
  }, {
    key: "stretchLimit",
    value: function stretchLimit() {
      var stretchLimit = this.props.stretchLimit;
      if (stretchLimit != null) {
        return stretchLimit;
      }
      return 10;
    }
  }]);
}(preact__WEBPACK_IMPORTED_MODULE_1__/* .Component */ .uA);

/***/ }),

/***/ 5833:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ getInitialMediaData)
/* harmony export */ });
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);
/* harmony import */ var _utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(159);
/* harmony import */ var _utilities_media_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1885);
/* harmony import */ var _utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5857);
/* harmony import */ var _utilities_media_data_transforms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3917);
/* harmony import */ var _utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3411);
/* harmony import */ var _utilities_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(959);
/* harmony import */ var _utilities_obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(731);
/* harmony import */ var _utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(3065);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }









// This file is designed to efficiently retrieve media data from multiple potential sources.
// The goal is to obtain the media data as quickly as possible.
// Our legacy embed scripts use JSONP and our new scripts use a JS module.
// It includes functions to check for the presence of these JSONP and JavaScript embed scripts in the DOM,
// which can provide the necessary media data.
// If they aren't there or don't load fast enough, we use server data.

var INTERVAL_TIME = 15;
var JS_LOAD_TIMEOUT = 30000; // 30 seconds
var SERVER_FETCH_FALLBACK_TIMEOUT = 15000; // 15 seconds

var doesJsonpExist = function doesJsonpExist(mediaId) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var url = (0,_utilities_media_data_js__WEBPACK_IMPORTED_MODULE_2__/* .mediaDataUrl */ .CC)(mediaId, options);
  // the mediaDataUrl above  ends with `json` and we're specifically looking for jsonp here
  // also, really old embed codes may have added query params to the end of the url, which we want to exclude
  var matchUrl = url.replace(/\.json(?!p)/, '.jsonp').replace(/&$/, '');
  var isJsonpScriptInDom = (0,_utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .findScriptInDomBySrc */ .Rb)(matchUrl, {
    ignoreProtocol: true,
    scriptRegex: (0,_utilities_media_data_js__WEBPACK_IMPORTED_MODULE_2__/* .mediaDataScriptRegExp */ .dq)(mediaId)
  });
  return Boolean(isJsonpScriptInDom);
};
var jsScriptUrl = function jsScriptUrl(mediaId) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var host = (0,_utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .mediaDataHost */ .Dd)(options);
  return "".concat((0,_utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .eV1Protocol */ .v9)(), "//").concat(host, "/embed/").concat(mediaId, ".js");
};
var doesJsMediaDataScriptExist = function doesJsMediaDataScriptExist(mediaId) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var url = jsScriptUrl(mediaId, options);
  var isJsScriptInDom = (0,_utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_1__/* .findScriptInDomBySrc */ .Rb)(url, {
    ignoreProtocol: true
  });
  return Boolean(isJsScriptInDom);
};
var pollForJsonp = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(mediaId, options) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            var poll = -1;

            // try looking once before the interval. This is especially useful for tests
            // since using jest.useFakeTimers() doesn't work with this function
            var checkForJsonp = function checkForJsonp() {
              var jsonp = window["wistiajsonp-/embed/medias/".concat(mediaId, ".jsonp")];
              if (jsonp) {
                if (jsonp.media) {
                  clearInterval(poll);

                  // Any data from speed demon scripts we know won't be localized, so we can
                  // cache it.
                  (0,_utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_5__/* .cacheMediaData */ .ry)(mediaId, jsonp.media);

                  // Still call fetchMediaData in case we need to get the localized version.
                  (0,_utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__/* .fetchMediaData */ .j)(mediaId, options).then(resolve).catch(function () {
                    reject(new Error('Failed to fetch media data via jsonp'));
                  });
                  return;
                }
                if ((0,_utilities_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_8__/* .isMediaDataError */ .V)(jsonp)) {
                  clearInterval(poll);
                  resolve(jsonp);
                }
              }
            };
            checkForJsonp();
            poll = window.setInterval(checkForJsonp, INTERVAL_TIME);
            setTimeout(function () {
              clearInterval(poll);
              reject(new Error('Timeout loading jsonp media data'));
            }, JS_LOAD_TIMEOUT);
          }));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function pollForJsonp(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var getJsScript = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(mediaId) {
    var options,
      url,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
          url = jsScriptUrl(mediaId, options);
          return _context2.abrupt("return", new Promise(function (resolve, reject) {
            setTimeout(function () {
              reject(new Error('Timeout loading js media data'));
            }, JS_LOAD_TIMEOUT);
            void import(/* webpackIgnore: true */url).then(function (module) {
              var mediaData = module.mediaData;

              // Any data from speed demon scripts we know won't be localized, so we can
              // cache it.
              (0,_utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_5__/* .cacheMediaData */ .ry)(mediaId, mediaData);
              (0,_utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__/* .fetchMediaData */ .j)(mediaId, options).then(resolve).catch(function () {
                reject(new Error('Failed to fetch media data via js script'));
              });
            }).catch(function () {
              reject(new Error('Failed to load js media data'));
            });
          }));
        case 3:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getJsScript(_x3) {
    return _ref2.apply(this, arguments);
  };
}();
var fetchMediaDataDelayed = function fetchMediaDataDelayed(mediaId) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var timeoutRef = {
    current: -1
  };
  var promise = new Promise(function (resolve, reject) {
    timeoutRef.current = window.setTimeout(function () {
      void (0,_utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__/* .fetchMediaData */ .j)(mediaId, options).then(resolve).catch(function (err) {
        reject(err instanceof Error ? err : new Error(String(err)));
      });
    }, SERVER_FETCH_FALLBACK_TIMEOUT);
  });
  return [promise, timeoutRef];
};
var getInitialMediaData = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(mediaId) {
    var _Wistia$_inlineMediaD;
    var options,
      mediaDataFromCache,
      inlineMediaData,
      clonedInlineMediaData,
      speedDemonPromises,
      mediaData,
      _fetchMediaDataDelaye,
      _fetchMediaDataDelaye2,
      delayedMediaDataPromise,
      delayedFetchTimeoutRef,
      _args3 = arguments;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
          // If the media data is already in the cache, no need to wait for everything
          // else.  Also, if we've cached from an external source like password
          // protected video, this lets us respect that value.
          mediaDataFromCache = (0,_utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_5__/* .getMediaDataFromCache */ .F2)(mediaId);
          if (!(mediaDataFromCache != null && options.skipCache !== true)) {
            _context3.next = 4;
            break;
          }
          return _context3.abrupt("return", (0,_utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__/* .fetchMediaData */ .j)(mediaId, options));
        case 4:
          inlineMediaData = (_Wistia$_inlineMediaD = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s._inlineMediaData) === null || _Wistia$_inlineMediaD === void 0 ? void 0 : _Wistia$_inlineMediaD[mediaId];
          if (!(inlineMediaData != null)) {
            _context3.next = 10;
            break;
          }
          // Any data from inline media data we know won't be localized, so we can
          // cache it.
          clonedInlineMediaData = (0,_utilities_obj_js__WEBPACK_IMPORTED_MODULE_6__/* .clone */ .o8)(inlineMediaData);
          (0,_utilities_media_data_transforms_js__WEBPACK_IMPORTED_MODULE_4__/* .mediaDataTransforms */ .M)(clonedInlineMediaData, options);
          (0,_utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_5__/* .cacheMediaData */ .ry)(mediaId, clonedInlineMediaData);
          // Still call fetchMediaData in case we need to get the localized version.
          return _context3.abrupt("return", (0,_utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__/* .fetchMediaData */ .j)(mediaId, options));
        case 10:
          speedDemonPromises = [];
          if (doesJsonpExist(mediaId, options)) {
            speedDemonPromises.push(pollForJsonp(mediaId, options));
          }
          if (doesJsMediaDataScriptExist(mediaId, options)) {
            speedDemonPromises.push(getJsScript(mediaId, options));
          }

          // eslint-disable-next-line @typescript-eslint/init-declarations
          if (!(speedDemonPromises.length === 0)) {
            _context3.next = 19;
            break;
          }
          _context3.next = 16;
          return (0,_utilities_fetchMediaData_ts__WEBPACK_IMPORTED_MODULE_7__/* .fetchMediaData */ .j)(mediaId, options);
        case 16:
          mediaData = _context3.sent;
          _context3.next = 24;
          break;
        case 19:
          _fetchMediaDataDelaye = fetchMediaDataDelayed(mediaId, options), _fetchMediaDataDelaye2 = _slicedToArray(_fetchMediaDataDelaye, 2), delayedMediaDataPromise = _fetchMediaDataDelaye2[0], delayedFetchTimeoutRef = _fetchMediaDataDelaye2[1];
          _context3.next = 22;
          return Promise.any([].concat(speedDemonPromises, [delayedMediaDataPromise]));
        case 22:
          mediaData = _context3.sent;
          clearTimeout(delayedFetchTimeoutRef.current);
        case 24:
          return _context3.abrupt("return", mediaData);
        case 25:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function getInitialMediaData(_x4) {
    return _ref3.apply(this, arguments);
  };
}();

/***/ }),

/***/ 5857:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CX: () => (/* binding */ cdnFastWistiaComHost),
/* harmony export */   Dd: () => (/* binding */ mediaDataHost),
/* harmony export */   KG: () => (/* binding */ PROD_FASTLY_SSL_HOST),
/* harmony export */   Qz: () => (/* binding */ metricsHost),
/* harmony export */   U4: () => (/* binding */ TAGGED_VERSION),
/* harmony export */   aY: () => (/* binding */ eV1HostWithPort),
/* harmony export */   bC: () => (/* binding */ eV1Host),
/* harmony export */   bF: () => (/* binding */ PROD_FAST_HOSTNAME_NET),
/* harmony export */   cu: () => (/* binding */ SSL_EMBED_HOST),
/* harmony export */   hk: () => (/* binding */ PROD_EMBED_HOST),
/* harmony export */   iD: () => (/* binding */ PROD_SSL_EMBED_HOST),
/* harmony export */   kh: () => (/* binding */ cdnFastWistiaNetHost),
/* harmony export */   pK: () => (/* binding */ EMBED_HOST),
/* harmony export */   pb: () => (/* binding */ PROD_FAST_HOSTNAME_COM),
/* harmony export */   v9: () => (/* binding */ eV1Protocol)
/* harmony export */ });
/* unused harmony exports CURRENT_SHA, deliveryHost, appHost, cdnFastProtectedWistiaComHost, cdnFastWistiaCanaryHost, eV1Url, VALID_FASTLY_HOSTS, forceValidFastWistiaHost, isEmbedOnACustomerPage */
/* harmony import */ var utilities_root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8176);
/* harmony import */ var utilities_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2671);
/* harmony import */ var _appHostname_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(787);



var APP_WISTIA_COM = (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_2__/* .appHostname */ .N)('app');
var CDN_FAST_PROTECTED_WISTIA_COM = (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_2__/* .appHostname */ .N)('fast-protected');
var CDN_FAST_WISTIA_COM = (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_2__/* .appHostname */ .N)('fast');
var CDN_FAST_WISTIA_CANARY = "fast-canary.wistia.net";
var EMBED_HOST = "embed.wistia.com";
var PROD_FAST_HOSTNAME_NET = 'fast.wistia.net';
var PROD_FAST_HOSTNAME_COM = 'fast.wistia.com';
var PROD_EMBED_HOST = 'embed.wistia.com';
var PROD_SSL_EMBED_HOST = 'embed-ssl.wistia.com';
var PROD_FASTLY_SSL_HOST = 'embed-fastly.wistia.com';
var SSL_EMBED_HOST = "embed-ssl.wistia.com";
var TAGGED_VERSION = "0.0.108" || 0;
var CURRENT_SHA = (/* unused pure expression or super */ null && ("037d6590001d4fac7b57aa4aeb943236320e084c" || 0));
var DEFAULT_PROTOCOL = function () {
  if (typeof window !== 'undefined' && utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z === window && utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.location) {
    return utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.location.protocol;
  }
  return 'https:';
}();
var sslOrNonSsl = function sslOrNonSsl(protocol, sslHost, nonSslHost) {
  return protocol === 'https:' ? sslHost : nonSslHost;
};
var deliveryHost = function deliveryHost() {
  var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_PROTOCOL;
  return sslOrNonSsl(protocol, SSL_EMBED_HOST, EMBED_HOST);
};
var appHost = function appHost() {
  return APP_WISTIA_COM;
};

/**
 * @param {string} embedHost
 * @returns {string}
 */
var cdnFastWistiaComHost = function cdnFastWistiaComHost() {
  var embedHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  if (embedHost) {
    return embedHost;
  }
  return CDN_FAST_WISTIA_COM;
};
var cdnFastProtectedWistiaComHost = function cdnFastProtectedWistiaComHost(assetHost) {
  if (assetHost) {
    return assetHost;
  }
  return CDN_FAST_PROTECTED_WISTIA_COM;
};
var cdnFastWistiaNetHost = function cdnFastWistiaNetHost() {
  var hostName =  false || "wistia.net";
  return "fast.".concat(hostName);
};
var cdnFastWistiaCanaryHost = function cdnFastWistiaCanaryHost() {
  return CDN_FAST_WISTIA_CANARY;
};
// We run this immediately because we'll be guaranteed that E-v1 is in the DOM
// when this is executing--unless we're loading a legacy thing like
// playlist-v1.js or embed-shepherd_v1.js. We can use the result to determine
// what host we should load other dynamic assets on.
var eV1Url = function () {
  var scripts = document.getElementsByTagName('script');
  for (var i = 0; i < scripts.length; i++) {
    var s = scripts[i];
    if (s.src) {
      var url = new utilities_url_js__WEBPACK_IMPORTED_MODULE_1__/* .Url */ .s0(s.src);

      // Check that this is definitely our script.
      var pathIsEv1 = /\/assets\/external\/E-v1?\.js$/.test(url.rawPath);
      var hasKnownHost = url.host === cdnFastWistiaComHost() || url.host === cdnFastWistiaNetHost() || url.host === cdnFastWistiaCanaryHost();

      // Check that the script's protocol is sensible for the page we're on.
      var usesHttpsIfRequired = location.protocol === 'https:' && url.protocol === 'https:';
      var isProtocolRelative = url.protocol === '' || url.protocol == null;
      var protoIsSane = usesHttpsIfRequired || isProtocolRelative || location.protocol === 'http:';

      // It's possible there are multiple versions of the script and one failed
      // to load. Let's use the domain that succeeded.
      var scriptHasLoaded = !s.readyState || /loaded|complete/.test(s.readyState);
      if (pathIsEv1 && hasKnownHost && protoIsSane && scriptHasLoaded) {
        return url;
      }
    }
  }

  // If we can't find an instance of E-v1 matching
  return new utilities_url_js__WEBPACK_IMPORTED_MODULE_1__/* .Url */ .s0("".concat((0,utilities_url_js__WEBPACK_IMPORTED_MODULE_1__/* .proto */ .ff)(), "//").concat(cdnFastWistiaNetHost(), "/E-v1.js"));
}();

/**
 * @returns { string } string of the host
 */
var eV1Host = function eV1Host() {
  return eV1Url.host;
};

/**
 * @returns { string } string of the host with port
 */
var eV1HostWithPort = function eV1HostWithPort() {
  if (eV1Url.port) {
    return "".concat(eV1Host(), ":").concat(eV1Url.port);
  }
  return eV1Host();
};

/**
 * @returns { string } string of the protocol
 */
var eV1Protocol = function eV1Protocol() {
  return eV1Url.protocol;
};
var mediaDataHost = function mediaDataHost() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // If embedHost is specified, just use that.
  if (options.embedHost) {
    return forceValidFastWistiaHost(options.embedHost);
  }

  // Try to match whatever host E-v1 is set to by default.
  return eV1HostWithPort();
};
var metricsHost = function metricsHost() {
  var hostname =  false ? 0 : "wistia.com";
  return "pipedream.".concat(hostname);
};
var VALID_PRODUCTION_HOSTS = ['wistia.net', 'wistia.com'];

// We have some non-production hosts in here to allow connecting to the player via ngrok - which
// is used for testing Live in VMA.
var VALID_FASTLY_HOSTS = [].concat(VALID_PRODUCTION_HOSTS, ['wistia.mx',
// ngrok hosts
'wistia.dev', 'wistia.tech', 'wistia.am', 'wistia.se', 'wistia.io',
// development
'wistia.st' // staging
]);
var VALID_FASTLY_HOSTS_R = new RegExp("(".concat(VALID_FASTLY_HOSTS.map(function (h) {
  return "\\.".concat(h.replace('.', '\\.'));
}).join('|'), ")$"));
var forceValidFastWistiaHost = function forceValidFastWistiaHost(host) {
  if (host && VALID_FASTLY_HOSTS_R.test(host)) {
    return host;
  }
  return eV1HostWithPort();
};

/**
 * Checks to see if the window location is a page that's hosted by wistia,
 * e.g., https://app.wistia.com, http://player.wistia.io, https://customer-name.wistia.com
 *
 * If so, return false.
 *
 * @returns boolean
 */
var isEmbedOnACustomerPage = function isEmbedOnACustomerPage() {
  return window.location.href.match(/^http(s)?:\/\/(\S)*.wistia.(io|test|st|com)/gi) === null;
};

/***/ }),

/***/ 6461:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* unused harmony exports getScriptTags, scriptTagsToRunScriptsInput, execScriptTags, removeScriptTags */
/* harmony import */ var utilities_script_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(159);

var getScriptTags = function getScriptTags(htmlStr) {
  return htmlStr.match(/<script.*?src[^>]*>\s*<\/script>|<script.*?>[\s\S]+?<\/script>/gi) || [];
};
var scriptTagsToRunScriptsInput = function scriptTagsToRunScriptsInput(scriptTags) {
  if (!scriptTags) {
    return [];
  }
  if (!(scriptTags instanceof Array)) {
    scriptTags = getScriptTags(scriptTags);
  }
  var hashes = [];
  var _loop = function _loop() {
    var scriptTag = scriptTags[i];
    var hash = {};
    var matches = scriptTag.match(/<script.*?>/i);
    if (matches) {
      matches = matches[0].match(/src="([^"]+)"/i);
      if (matches) {
        hash.src = matches[1];
        hash.async = /async/i.test(scriptTag.replace(hash.src, ''));
      }
    }
    if (!matches) {
      matches = scriptTag.match(/<script>([\s\S]+?)<\/script>/i);
      if (matches) {
        var src = matches[1];
        hash.fn = function () {
          // eslint-disable-next-line no-eval
          return eval(src);
        };
      }
    }
    hashes.push(hash);
  };
  for (var i = 0; i < scriptTags.length; i++) {
    _loop();
  }
  return hashes;
};
var execScriptTags = function execScriptTags(scriptTags, callback) {
  if (!scriptTags) {
    return null;
  }
  var hashes = scriptTagsToRunScriptsInput(scriptTags);
  return runScripts(hashes).then(callback);
};
var removeScriptTags = function removeScriptTags(htmlStr) {
  return htmlStr.replace(/<script.*?src[^>]*>\s*<\/script>|<script>[\s\S]+?<\/script>/g, '');
};

/***/ }),

/***/ 6462:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ PlayerDataHandler)
/* harmony export */ });
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8089);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8290);
/* harmony import */ var lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(731);
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _embedOptionOverrides = /*#__PURE__*/new WeakMap();
var _embedOptions = /*#__PURE__*/new WeakMap();
var _mediaData = /*#__PURE__*/new WeakMap();
var _sourceEmbedOptions = /*#__PURE__*/new WeakMap();
var _sourceMediaData = /*#__PURE__*/new WeakMap();
var _PlayerDataHandler_brand = /*#__PURE__*/new WeakSet();
var PlayerDataHandler = /*#__PURE__*/function () {
  function PlayerDataHandler() {
    _classCallCheck(this, PlayerDataHandler);
    /**
     * Merge the source embed options together to create a single source of truth of embed options
     * @private
     * @returns {void}
     */
    _classPrivateMethodInitSpec(this, _PlayerDataHandler_brand);
    // Embed options set after initialization which override the embed options
    // gathered from the source data
    _classPrivateFieldInitSpec(this, _embedOptionOverrides, {});
    // Merged embed options gathered from source data
    _classPrivateFieldInitSpec(this, _embedOptions, {});
    // Merged media data gathered from source data
    _classPrivateFieldInitSpec(this, _mediaData, {});
    // Source data which is used to create the final embed options
    _classPrivateFieldInitSpec(this, _sourceEmbedOptions, {
      domOptions: {},
      iframeOptions: {},
      mediaDataOptions: {},
      wistiaWindowOptions: {}
    });
    // Source data which is used to create the final media data
    _classPrivateFieldInitSpec(this, _sourceMediaData, {});
  }
  return _createClass(PlayerDataHandler, [{
    key: "embedOptions",
    get:
    /**
     * Returns the final embed options which are a merge of all the source data and the overrides
     * @returns {EmbedOptions}
     * @readonly
     */
    function get() {
      return _classPrivateFieldGet(_embedOptions, this);
    }

    /**
     * Returns the final media data which is a merge of all the source data
     * @returns {MediaData}
     * @readonly
     */
  }, {
    key: "mediaData",
    get: function get() {
      // Our embed options can be overridden after our initial source data fetches
      // Make sure the embed options within the media data are up to date
      _classPrivateFieldGet(_mediaData, this).embedOptions = _classPrivateFieldGet(_embedOptions, this);
      return _classPrivateFieldGet(_mediaData, this);
    }

    /**
     * Sets the source data for the embed options set on the <wistia-player> DOM element
     * @param {EmbedOptions} data
     * @returns {void}
     */
  }, {
    key: "setDomEmbedOptionSource",
    value: function setDomEmbedOptionSource(data) {
      _classPrivateFieldGet(_sourceEmbedOptions, this).domOptions = data;
      _assertClassBrand(_PlayerDataHandler_brand, this, _updatePlayerEmbedOptions).call(this);
    }

    /**
     * Sets the source data for the embed options from an iframe's url search params
     * @returns {void}
     */
  }, {
    key: "setIframeEmbedOptionSource",
    value: function setIframeEmbedOptionSource(data) {
      _classPrivateFieldGet(_sourceEmbedOptions, this).iframeOptions = data;
      _assertClassBrand(_PlayerDataHandler_brand, this, _updatePlayerEmbedOptions).call(this);
    }

    /**
     * Sets the source data for the media data
     * @param {MediaData} data
     * @returns {void}
     */
  }, {
    key: "setMediaDataSource",
    value: function setMediaDataSource(data) {
      var _cloneDeep;
      _classPrivateFieldSet(_sourceMediaData, this, data);
      _classPrivateFieldSet(_mediaData, this, (0,_utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__/* .cast */ .wg)(lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default()(_classPrivateFieldGet(_sourceMediaData, this))));
      // Sometimes the hashedId has no alpha characters, so cast() will convert it to a number.
      // Our api expects hashedId to be a string, so we need to convert it back.
      if (_classPrivateFieldGet(_mediaData, this).hashedId !== undefined) {
        _classPrivateFieldGet(_mediaData, this).hashedId = _classPrivateFieldGet(_mediaData, this).hashedId.toString();
      }
      _classPrivateFieldGet(_sourceEmbedOptions, this).mediaDataOptions = (_cloneDeep = lodash_clonedeep__WEBPACK_IMPORTED_MODULE_1___default()(_classPrivateFieldGet(_mediaData, this).embedOptions)) !== null && _cloneDeep !== void 0 ? _cloneDeep : {};
      _assertClassBrand(_PlayerDataHandler_brand, this, _updatePlayerEmbedOptions).call(this);
    }

    /**
     * Sets the source data for the embed options set on the window via wistiaOptions
     * @param {EmbedOptions} data
     * @returns {void}
     */
  }, {
    key: "setWistiaWindowEmbedOptionSource",
    value: function setWistiaWindowEmbedOptionSource(data) {
      _classPrivateFieldGet(_sourceEmbedOptions, this).wistiaWindowOptions = data;
      _assertClassBrand(_PlayerDataHandler_brand, this, _updatePlayerEmbedOptions).call(this);
    }

    /**
     * Updates the embed option overrides which will be merged with the source embed option data
     * This merge can happen more frequently than our finite source data sets, which is why it's separate.
     * That way we don't have to re-merge the source data every time we update the overrides.
     * @param {EmbedOptions} data
     * @returns {void}
     */
  }, {
    key: "updateEmbedOptionOverrides",
    value: function updateEmbedOptionOverrides(data) {
      _classPrivateFieldSet(_embedOptionOverrides, this, lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()(_classPrivateFieldGet(_embedOptionOverrides, this), data));
      _classPrivateFieldSet(_embedOptions, this, lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()(_classPrivateFieldGet(_embedOptions, this), _classPrivateFieldGet(_embedOptionOverrides, this)));
    }
  }]);
}();
function _updatePlayerEmbedOptions() {
  var _classPrivateFieldGet2 = _classPrivateFieldGet(_sourceEmbedOptions, this),
    mediaDataOptions = _classPrivateFieldGet2.mediaDataOptions,
    wistiaWindowOptions = _classPrivateFieldGet2.wistiaWindowOptions,
    domOptions = _classPrivateFieldGet2.domOptions,
    iframeOptions = _classPrivateFieldGet2.iframeOptions;

  // Merge the embed options together to create a single source of truth of embed options
  _classPrivateFieldSet(_embedOptions, this, (0,_utilities_obj_js__WEBPACK_IMPORTED_MODULE_2__/* .cast */ .wg)(lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()({}, mediaDataOptions !== null && mediaDataOptions !== void 0 ? mediaDataOptions : {}, wistiaWindowOptions !== null && wistiaWindowOptions !== void 0 ? wistiaWindowOptions : {}, domOptions !== null && domOptions !== void 0 ? domOptions : {}, iframeOptions !== null && iframeOptions !== void 0 ? iframeOptions : {}, _classPrivateFieldGet(_embedOptionOverrides, this))));

  // Make sure the embed options within the media data are up to date
  _classPrivateFieldGet(_mediaData, this).embedOptions = _classPrivateFieldGet(_embedOptions, this);
}

/***/ }),

/***/ 6633:
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;

/**
 * @description A module for parsing ISO8601 durations
 */
__webpack_unused_export__ = ({ value: true });
exports.fP = exports._N = exports.qg = exports.T1 = void 0;
/**
 * The pattern used for parsing ISO8601 duration (PnYnMnWnDTnHnMnS).
 */
// PnYnMnWnDTnHnMnS
var numbers = "\\d+";
var fractionalNumbers = "".concat(numbers, "(?:[\\.,]").concat(numbers, ")?");
var datePattern = "(".concat(numbers, "Y)?(").concat(numbers, "M)?(").concat(numbers, "W)?(").concat(numbers, "D)?");
var timePattern = "T(".concat(fractionalNumbers, "H)?(").concat(fractionalNumbers, "M)?(").concat(fractionalNumbers, "S)?");
var iso8601 = "P(?:".concat(datePattern, "(?:").concat(timePattern, ")?)");
var objMap = [
    "years",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
];
var defaultDuration = Object.freeze({
    years: 0,
    months: 0,
    weeks: 0,
    days: 0,
    hours: 0,
    minutes: 0,
    seconds: 0,
});
/**
 * The ISO8601 regex for matching / testing durations
 */
exports.T1 = new RegExp(iso8601);
/** Parse PnYnMnDTnHnMnS format to object */
var parse = function (durationString) {
    var matches = durationString.replace(/,/g, ".").match(exports.T1);
    if (!matches) {
        throw new RangeError("invalid duration: ".concat(durationString));
    }
    // Slice away first entry in match-array (the input string)
    var slicedMatches = matches.slice(1);
    if (slicedMatches.filter(function (v) { return v != null; }).length === 0) {
        throw new RangeError("invalid duration: ".concat(durationString));
    }
    // Check only one fraction is used
    if (slicedMatches.filter(function (v) { return /\./.test(v || ""); }).length > 1) {
        throw new RangeError("only the smallest unit can be fractional");
    }
    return slicedMatches.reduce(function (prev, next, idx) {
        prev[objMap[idx]] = parseFloat(next || "0") || 0;
        return prev;
    }, {});
};
exports.qg = parse;
/** Convert ISO8601 duration object to an end Date. */
var end = function (durationInput, startDate) {
    if (startDate === void 0) { startDate = new Date(); }
    var duration = Object.assign({}, defaultDuration, durationInput);
    // Create two equal timestamps, add duration to 'then' and return time difference
    var timestamp = startDate.getTime();
    var then = new Date(timestamp);
    then.setFullYear(then.getFullYear() + duration.years);
    then.setMonth(then.getMonth() + duration.months);
    then.setDate(then.getDate() + duration.days);
    // set time as milliseconds to get fractions working for minutes/hours
    var hoursInMs = duration.hours * 3600 * 1000;
    var minutesInMs = duration.minutes * 60 * 1000;
    then.setMilliseconds(then.getMilliseconds() + duration.seconds * 1000 + hoursInMs + minutesInMs);
    // Special case weeks
    then.setDate(then.getDate() + duration.weeks * 7);
    return then;
};
exports._N = end;
/** Convert ISO8601 duration object to seconds */
var toSeconds = function (durationInput, startDate) {
    if (startDate === void 0) { startDate = new Date(); }
    var duration = Object.assign({}, defaultDuration, durationInput);
    var timestamp = startDate.getTime();
    var now = new Date(timestamp);
    var then = (0, exports._N)(duration, now);
    // Account for timezone offset between start and end date
    var tzStart = startDate.getTimezoneOffset();
    var tzEnd = then.getTimezoneOffset();
    var tzOffsetSeconds = (tzStart - tzEnd) * 60;
    var seconds = (then.getTime() - now.getTime()) / 1000;
    return seconds + tzOffsetSeconds;
};
exports.fP = toSeconds;
__webpack_unused_export__ = {
    end: exports._N,
    toSeconds: exports.fP,
    pattern: exports.T1,
    parse: exports.qg,
};


/***/ }),

/***/ 6637:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ct: () => (/* binding */ wlog)
/* harmony export */ });
/* unused harmony exports ERROR, WARNING, NOTICE, INFO, DEBUG, LOG_LEVELS, Logger */
/* harmony import */ var utilities_globalBindAndTrigger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4271);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/* eslint no-console: "off" */
/*
 * wlog
 *
 * wlog seeks to give us flexibility and power.
 *
 * Basic usage:
 *
 *     import {Logger} from 'utilities/wlog.js';
 *     const logger = new Logger();
 *
 *     logger.error(exception); // this will print the message and stack nicely
 *     logger.error('an error');
 *     logger.info('informational');
 *     logger.warn('a warning');
 *     logger.debug('really high volume stuff');
 *
 * You can change the level:
 *
 *     logger.setLevel(LOG_LEVELS.INFO);
 *
 * You can change grep (include matching) and grepv (exclude matching):
 *
 *     logger.setGrep('include only lines matching this text');
 *     logger.setGrepv('exclude any lines matching this text');
 *
 * If you want loggers to share context--for example, all logs for the player
 * should send to the same first1000LogLines and last1000LogLines caches.
 *
 *     Wistia.wlog = Wistia.wlog || {};
 *     const logger = new Logger(Wistia.wlog);
 *
 * A more advanced case would be to return the context in a function. This is
 * helpful if your logger is initialized/configured in one point, but used in
 * others that don't need to know about that configuration. In fact, this is
 * how the `wlog` constant is setup at the bottom of this file.
 *
 * We often want to have a global logger, but prefix certain portions of it.
 *
 *     const myLogger = logger.getPrefixedFunctions('my prefix');
 *     myLogger.info('aha'); // outputs "my prefix aha"
 *
 * A prefix can be a string or an array of strings. It can also be a function
 * that returns a string or an array of strings.
 *
 * In the above example, `myLogger` is a simple Object with defined logging
 * functions and fixed `this` context:
 *
 *    {
 *      error: (...messages) => { ... },
 *      warn: (...messages) => { ... },
 *      info: (...messages) => { ... },
 *      etc...
 *    }
 *
 * So it can also be used as a mix-in for other objects, e.g.
 *
 *    import {Logger} from 'utilities/wlog.js';
 *    class MyThing {
 *      constructor () {
 *        this.logger = new Logger().getPrefixedFunctions(this.logPrefix);
 *        for (let k in this.logger) {
 *          this[k] = this.logger[k];
 *        }
 *        this.info('my mixed-in logger is setup!');
 *      }
 *
 *      logPrefix = () => {
 *        return [this.id, this.variable];
 *      }
 *    }
 */


var ERROR = 0;
var WARNING = 1;
var NOTICE = 2;
var INFO = 3;
var DEBUG = 4;
var LOG_LEVELS = {
  ERROR: ERROR,
  WARNING: WARNING,
  NOTICE: NOTICE,
  INFO: INFO,
  DEBUG: DEBUG,
  error: ERROR,
  warning: WARNING,
  notice: NOTICE,
  info: INFO,
  debug: DEBUG
};
var NOOP = function NOOP() {};
var Logger = function Logger(ctx) {
  var self = this;
  if (ctx == null) {
    ctx = {};
  }
  var construct = function construct() {
    self.ctx = ctx;
    if (!self.ctx.initializedAt) {
      self.reset();
    }
  };
  self.error = function () {
    for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
      messages[_key] = arguments[_key];
    }
    return self.log(ERROR, messages);
  };
  self.warn = function () {
    for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      messages[_key2] = arguments[_key2];
    }
    return self.log(WARNING, messages);
  };
  self.notice = function () {
    for (var _len3 = arguments.length, messages = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      messages[_key3] = arguments[_key3];
    }
    return self.log(WARNING, messages);
  };
  self.info = function () {
    for (var _len4 = arguments.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      messages[_key4] = arguments[_key4];
    }
    return self.log(INFO, messages);
  };
  self.debug = function () {
    for (var _len5 = arguments.length, messages = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      messages[_key5] = arguments[_key5];
    }
    return self.log(DEBUG, messages);
  };
  construct();
  return self;
};
var lproto = Logger.prototype;
lproto.reset = function () {
  this.ctx.level = ERROR;
  this.ctx.grep = null;
  this.ctx.grepv = null;
  this.ctx.first1000LogLines = [];
  this.ctx.last1000LogLines = [];
  this.ctx.initializedAt = new Date().getTime();
};
lproto.setLevel = function (level) {
  var logFunc = this.logFunc(INFO);
  if (LOG_LEVELS[level] != null) {
    this.ctx.level = LOG_LEVELS[level];
    logFunc("Log level set to \"".concat(level, "\" (").concat(LOG_LEVELS[level], ")"));
  } else {
    logFunc("Unknown log level \"".concat(level, "\""));
  }
};
lproto.setGrep = function (grep) {
  this.ctx.grep = grep;
};
lproto.setGrepv = function (grepv) {
  this.ctx.grepv = grepv;
};
lproto.first1000LogLines = function () {
  return this.ctx.first1000LogLines;
};
lproto.last1000LogLines = function () {
  return this.ctx.last1000LogLines;
};
lproto.matchedGrep = function (messages) {
  var matched = false;
  if (this.ctx.grep || this.ctx.grepv) {
    var messageStrings = [];
    for (var i = 0; i < messages.length; i++) {
      try {
        var message = messages[i];
        messageStrings.push(message.toString && message.toString());
      } catch (e) {
        messageStrings.push('');
      }
    }
    var fullLine = messageStrings.join(' ');
    var matchesGrep = !this.ctx.grep || fullLine.match(this.ctx.grep);
    var matchesGrepv = !this.ctx.grepv || !fullLine.match(this.ctx.grepv);
    matched = matchesGrep && matchesGrepv;
  } else {
    matched = true;
  }
  return matched;
};
lproto.now = function () {
  // IE9 has window.performance, but not performance.now
  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
    return performance.now().toFixed(3);
  }
  if (Date.now) {
    return Date.now() - this.ctx.initializedAt;
  }
  return new Date().getTime() - this.ctx.initializedAt;
};
lproto.messagesToLogLine = function (level, time, messages) {
  var logLine = [level, time];
  logLine = logLine.concat(messages);
  var cappedLine;
  try {
    cappedLine = logLine.join(' ') || '';
    if (cappedLine.length > 200) {
      cappedLine = cappedLine.slice(0, 200);
    }
  } catch (e1) {
    cappedLine = 'could not serialize';
  }
  return cappedLine;
};
lproto.persistLine = function (logLine) {
  if (this.ctx.first1000LogLines.length < 1000) {
    this.ctx.first1000LogLines.push(logLine);
  } else {
    if (this.ctx.last1000LogLines.length >= 1000) {
      this.ctx.last1000LogLines.shift();
    }
    this.ctx.last1000LogLines.push(logLine);
  }
};
lproto.log = function (level, messages) {
  var withinLevel = level <= this.ctx.level;
  var notDebug = level < DEBUG;
  var matched = (withinLevel || notDebug) && this.matchedGrep(messages);
  if (level === ERROR) {
    (0,utilities_globalBindAndTrigger_js__WEBPACK_IMPORTED_MODULE_0__/* .globalTrigger */ .mj)('problem', {
      type: 'error-logged',
      data: {
        messages: messages
      }
    });
  }
  var now;
  if (matched && (withinLevel || notDebug)) {
    // This is initialized conditionally as a micro-optimization. We call
    // this function _a lot_, and new Date().getTime() (used on older
    // browsers) is expensive.
    now = this.now();
  }

  // Don't store "debug" lines, but keep the first and last 1000 lines so we
  // can send it with problem reports.
  if (notDebug && matched) {
    var logLine = this.messagesToLogLine(level, now, messages);
    this.persistLine(logLine);
  }

  // Output that log to the console! Minus info that is distracting like the
  // timestamp and log level.
  if (withinLevel && matched) {
    var logFunc = this.logFunc(level);
    var e;
    if (messages.length === 1 && (e = messages[0]) instanceof Error) {
      logFunc(e.message);
      if (e.stack) {
        logFunc(e.stack);
      }
    } else {
      logFunc.apply(void 0, _toConsumableArray(messages));
    }
  }
};
var logError = function logError() {
  for (var _len6 = arguments.length, messages = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    messages[_key6] = arguments[_key6];
  }
  console.error.apply(console, messages);
};
var logWarn = function logWarn() {
  for (var _len7 = arguments.length, messages = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    messages[_key7] = arguments[_key7];
  }
  console.warn.apply(console, messages);
};
var logInfo = function logInfo() {
  for (var _len8 = arguments.length, messages = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    messages[_key8] = arguments[_key8];
  }
  console.info.apply(console, messages);
};
var logDebug = function logDebug() {
  for (var _len9 = arguments.length, messages = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    messages[_key9] = arguments[_key9];
  }
  console.debug.apply(console, messages);
};
var logLog = function logLog(messages) {
  console.log.apply(console, messages);
};
lproto.logFunc = function (level) {
  if (level == null) {
    level = this.level;
  }
  if (!console) {
    return NOOP;
  }
  var func;
  if (level === ERROR) {
    func = logError;
  } else if (level === WARNING) {
    func = logWarn;
  } else if (level === INFO) {
    func = logInfo;
  } else if (level === DEBUG) {
    func = logDebug;
  }
  if (!func) {
    func = logLog;
  }
  if (typeof func !== 'function') {
    // This should pretty much never happen, but if it does, we could only
    // tell by checking the value of logger.noConsoleLog.
    this.noConsoleLog = true;
    func = NOOP;
  }
  return func;
};
lproto.maybePrefix = function (prefix, messages) {
  if (prefix) {
    // prefix can be a fixed value, or a function that returns a value.
    if (typeof prefix === 'function') {
      try {
        prefix = prefix();
      } catch (e) {
        prefix = "prefix err \"".concat(e.message, "\"");
      }
    }
    if (prefix instanceof Array) {
      return prefix.concat(messages);
    }
    return [prefix].concat(messages);
  }
  return messages;
};

// Return a hash of functions so we can easily setup prefixes and mix in the
// results.
lproto.getPrefixedFunctions = function (prefix) {
  var _this = this;
  return {
    log: function log() {
      for (var _len10 = arguments.length, messages = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        messages[_key10] = arguments[_key10];
      }
      return _this.log(ERROR, _this.maybePrefix(prefix, messages));
    },
    error: function error() {
      for (var _len11 = arguments.length, messages = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        messages[_key11] = arguments[_key11];
      }
      return _this.log(ERROR, _this.maybePrefix(prefix, messages));
    },
    warn: function warn() {
      for (var _len12 = arguments.length, messages = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        messages[_key12] = arguments[_key12];
      }
      return _this.log(WARNING, _this.maybePrefix(prefix, messages));
    },
    notice: function notice() {
      for (var _len13 = arguments.length, messages = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        messages[_key13] = arguments[_key13];
      }
      return _this.log(WARNING, _this.maybePrefix(prefix, messages));
    },
    info: function info() {
      for (var _len14 = arguments.length, messages = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        messages[_key14] = arguments[_key14];
      }
      return _this.log(INFO, _this.maybePrefix(prefix, messages));
    },
    debug: function debug() {
      for (var _len15 = arguments.length, messages = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        messages[_key15] = arguments[_key15];
      }
      return _this.log(DEBUG, _this.maybePrefix(prefix, messages));
    }
  };
};

// This should work in either the browser or node.
if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s && _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.wlogCtx == null) {
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.wlogCtx = {};
}
var wlog = new Logger(_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.wlogCtx);

/***/ }),

/***/ 6906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fn: () => (/* binding */ BigPlayButton)
/* harmony export */ });
/* unused harmony exports BASE_BUTTON_WIDTH, BASE_BUTTON_HEIGHT */
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3817);
/* harmony import */ var _svgs_BigPlayButtonSVG_tsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7880);
/* harmony import */ var _shared_translations_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4730);
/* harmony import */ var _utilities_color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5417);
/* harmony import */ var _utilities_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1627);
/* harmony import */ var _utilities_detect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7231);
/* harmony import */ var _utilities_duration_ts__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1341);
/* harmony import */ var _utilities_interFontFamily_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8213);
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }









var detect = (0,_utilities_detect_js__WEBPACK_IMPORTED_MODULE_6__/* .cachedDetect */ .o1)();
var BASE_BUTTON_WIDTH = 125;
var BASE_BUTTON_HEIGHT = 80;
var BASE_FONT_SIZE = 18;
var BASE_LINE_HEIGHT = 30;
var ALPHA_MIX_BLEND_MODE = 0.7;
var ALPHA_NO_MIX_BLEND_MODE = 0.85;
var BigPlayButton = function BigPlayButton(_ref) {
  var backgroundGradientCss = _ref.backgroundGradientCss,
    _ref$baseHeight = _ref.baseHeight,
    baseHeight = _ref$baseHeight === void 0 ? BASE_BUTTON_HEIGHT : _ref$baseHeight,
    _ref$baseWidth = _ref.baseWidth,
    baseWidth = _ref$baseWidth === void 0 ? BASE_BUTTON_WIDTH : _ref$baseWidth,
    borderRadius = _ref.borderRadius,
    buttonTabIndex = _ref.buttonTabIndex,
    color = _ref.color,
    _ref$controlBarDistan = _ref.controlBarDistance,
    controlBarDistance = _ref$controlBarDistan === void 0 ? 0 : _ref$controlBarDistan,
    duration = _ref.duration,
    elemRef = _ref.elemRef,
    isLiveMedia = _ref.isLiveMedia,
    _ref$isLoading = _ref.isLoading,
    isLoading = _ref$isLoading === void 0 ? false : _ref$isLoading,
    isVisible = _ref.isVisible,
    _ref$leftNudgeFractio = _ref.leftNudgeFraction,
    leftNudgeFraction = _ref$leftNudgeFractio === void 0 ? 0 : _ref$leftNudgeFractio,
    _ref$noMixBlendMode = _ref.noMixBlendMode,
    noMixBlendMode = _ref$noMixBlendMode === void 0 ? false : _ref$noMixBlendMode,
    onClick = _ref.onClick,
    playerLanguage = _ref.playerLanguage,
    scale = _ref.scale,
    showBpbTime = _ref.showBpbTime,
    _ref$topNudgeFraction = _ref.topNudgeFraction,
    topNudgeFraction = _ref$topNudgeFraction === void 0 ? 0 : _ref$topNudgeFraction,
    videoName = _ref.videoName,
    videoWidth = _ref.videoWidth;
  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useState */ .J0)(false),
    _useState2 = _slicedToArray(_useState, 2),
    isFocused = _useState2[0],
    setIsFocused = _useState2[1];
  var scaledWidth = baseWidth * scale;
  var scaledHeight = baseHeight * scale;
  var translate = function translate(key) {
    return (0,_shared_translations_js__WEBPACK_IMPORTED_MODULE_3__/* .getTranslation */ .sC)(playerLanguage.code, "PLAY_BUTTON_".concat(key));
  };
  var unescapedVideoName = (0,_utilities_core_js__WEBPACK_IMPORTED_MODULE_5__/* .unescapeHtml */ .Uh)(videoName);
  var ariaLabel = "".concat(translate('TITLE_WHEN_NOT_PLAYING'), ": ").concat(unescapedVideoName);
  var wrapperStyle = {
    borderRadius: "".concat(borderRadius, "px"),
    display: isVisible ? 'block' : 'none',
    left: "calc(50% + ".concat((leftNudgeFraction || 0) * 100, "%)"),
    marginLeft: "-".concat(scaledWidth / 2, "px"),
    marginTop: "-".concat(scaledHeight / 2, "px"),
    overflow: 'hidden',
    position: 'absolute',
    top: "calc(50% + ".concat((topNudgeFraction || 0) * 100, "% - ").concat(controlBarDistance, "px)")
  };
  var buttonStyle = {
    backgroundColor: 'transparent',
    border: 0,
    cursor: 'pointer',
    height: "".concat(scaledHeight, "px"),
    boxShadow: 'none',
    width: "".concat(scaledWidth, "px")
  };
  var shouldMixBlendMode = !detect.edge && !noMixBlendMode;
  var blendColor = new _utilities_color_js__WEBPACK_IMPORTED_MODULE_4__/* .Color */ .Q(color !== null && color !== void 0 ? color : '#000').alpha(1);
  var blendStyle = {
    background: blendColor.toRgba(),
    display: shouldMixBlendMode ? 'block' : 'none',
    left: 0,
    height: "".concat(scaledHeight, "px"),
    mixBlendMode: 'darken',
    position: 'absolute',
    top: 0,
    width: "".concat(scaledWidth, "px")
  };
  var overlayColor = new _utilities_color_js__WEBPACK_IMPORTED_MODULE_4__/* .Color */ .Q(color !== null && color !== void 0 ? color : '#000');
  var overlayAlphaValue = shouldMixBlendMode ? ALPHA_MIX_BLEND_MODE : ALPHA_NO_MIX_BLEND_MODE;
  overlayColor.alpha(overlayAlphaValue);
  if (isFocused) {
    overlayColor.lighten('15%');
  }
  var shouldUseGradient = backgroundGradientCss != null;
  var gradientStyles = shouldUseGradient ? {
    background: backgroundGradientCss,
    backgroundSize: "".concat(videoWidth, "px 100%"),
    backgroundPositionX: 'center'
  } : {};
  var overlayStyle = _objectSpread(_objectSpread({
    backgroundColor: overlayColor.toRgba()
  }, gradientStyles), {}, {
    height: "".concat(scaledHeight, "px"),
    left: 0,
    position: 'absolute',
    top: 0,
    transition: 'background-color 150ms',
    width: "".concat(scaledWidth, "px")
  });
  var shouldDisplayDuration = showBpbTime && !isLiveMedia;
  var timeStyle = {
    background: 'rgba(0,0,0,.4)',
    color: '#fff',
    fontFamily: _utilities_interFontFamily_js__WEBPACK_IMPORTED_MODULE_8__/* .interNumbersSemiBold */ .w5,
    fontSize: "".concat(BASE_FONT_SIZE * scale, "px"),
    lineHeight: "".concat(BASE_LINE_HEIGHT * scale, "px"),
    pointerEvents: 'none',
    textAlign: 'center'
  };
  var handleIsFocused = function handleIsFocused() {
    setIsFocused(true);
  };
  var handleNotFocused = function handleNotFocused() {
    setIsFocused(false);
  };
  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    class: "w-bpb-wrapper w-css-reset w-css-reset-tree",
    ref: elemRef,
    style: wrapperStyle
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("button", {
    class: "w-big-play-button w-css-reset-button-important w-vulcan-v2-button",
    style: buttonStyle,
    onMouseEnter: handleIsFocused,
    onMouseLeave: handleNotFocused,
    onFocusIn: handleIsFocused,
    onFocusOut: handleNotFocused,
    onClick: onClick,
    "aria-label": ariaLabel,
    tabIndex: buttonTabIndex,
    type: "button"
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    style: blendStyle
  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    style: overlayStyle
  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_svgs_BigPlayButtonSVG_tsx__WEBPACK_IMPORTED_MODULE_2__/* .BigPlayButtonSVG */ .R, {
    width: baseWidth,
    height: baseHeight,
    scale: scale,
    isLoading: isLoading
  })), shouldDisplayDuration ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    class: "w-bpb-time",
    style: timeStyle
  }, (0,_utilities_duration_ts__WEBPACK_IMPORTED_MODULE_7__/* .flexibleDuration */ .G5)(duration)) : null);
};

/***/ }),

/***/ 7157:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ dynamicImport)
/* harmony export */ });
/* harmony import */ var _hosts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5857);
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }

var dynamicImport = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(filePath) {
    var _options$host;
    var options,
      host,
      taggedVersion,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          host = (_options$host = options.host) !== null && _options$host !== void 0 ? _options$host : (0,_hosts_js__WEBPACK_IMPORTED_MODULE_0__/* .eV1HostWithPort */ .aY)();
          taggedVersion = _hosts_js__WEBPACK_IMPORTED_MODULE_0__/* .TAGGED_VERSION */ .U4;
          if (!(taggedVersion !== '' && taggedVersion.length > 0 && options.mediaData !== true)) {
            _context.next = 5;
            break;
          }
          return _context.abrupt("return", import(/* webpackIgnore: true */"".concat((0,_hosts_js__WEBPACK_IMPORTED_MODULE_0__/* .eV1Protocol */ .v9)(), "//").concat(host, "/").concat(filePath, "@").concat(taggedVersion)));
        case 5:
          return _context.abrupt("return", import(/* webpackIgnore: true */"".concat((0,_hosts_js__WEBPACK_IMPORTED_MODULE_0__/* .eV1Protocol */ .v9)(), "//").concat(host, "/").concat(filePath)));
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function dynamicImport(_x) {
    return _ref.apply(this, arguments);
  };
}();

/***/ }),

/***/ 7209:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fi: () => (/* binding */ readyPublicMp4s),
/* harmony export */   Q0: () => (/* binding */ thumbnailAssets),
/* harmony export */   Wz: () => (/* binding */ stillUrl),
/* harmony export */   aF: () => (/* binding */ nonfailedPublicOver400),
/* harmony export */   n9: () => (/* binding */ readyPublicOver400),
/* harmony export */   o2: () => (/* binding */ readyPublicMp3s),
/* harmony export */   pb: () => (/* binding */ filter),
/* harmony export */   tt: () => (/* binding */ findClosestAssetByQuality),
/* harmony export */   x4: () => (/* binding */ readyPublicM3u8s),
/* harmony export */   yE: () => (/* binding */ READY)
/* harmony export */ });
/* unused harmony exports FAILED, QUEUED, PROCESSING, one, filterOver400, withinQualityRange, numericSizeSnapped, still, channelArtworkStill, getStillWidth, BAKERY_HOSTS, isBakeryUrl, onePublicReadyWithContainer, mp4, webm, m3u8, original, playable, videoAspect, originalAspect, iphone, smallestNormalMp4, urlWithCorrectHost, nearestOutsideRange, moveToFront */
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2671);
/* harmony import */ var utilities_detect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7231);
/* harmony import */ var utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5857);
/* harmony import */ var utilities_wlog_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6637);
/* harmony import */ var _appHostname_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(787);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }






var aps = Array.prototype.slice;
var FAILED = -1;
var QUEUED = 0;
var PROCESSING = 1;
var READY = 2;

// Advanced sorting and filtering so we can be expressive and concise when
// choosing assets.
var FILTER_KEYS = ['select', 'sortFn', 'sortBy', 'unique'];
var filter = function filter(assets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // there was an issues in the uploader + notPlayablePlayer flow where we
  // occasionally asked to filter assets when we didn't have any. If we
  // don't have assets just gtfo
  if (!assets) {
    return [];
  }
  // We started out passing the whole mediaData object here, but we only
  // operate on assets, and that's more convenient for filtering result sets
  // multiple times. This if continues to allow mediaData to be passed in.
  if (assets.assets) {
    assets = assets.assets;
  }

  // If qualityMin/qualityMax are specified, filtered the assets with those
  // before doing anything else. That's because those aren't set directly on
  // the assets; rather, it is a computed value for each asset.
  if (options.qualityMin != null || options.qualityMax != null) {
    assets = withinQualityRange(assets, options.qualityMin, options.qualityMax);
    options = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .except */ .iu)(options, ['qualityMin', 'qualityMax']);
  }
  var filterOptions = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .only */ .j6)(options, FILTER_KEYS);
  var selectFn = filterOptions.select || (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .except */ .iu)(options, FILTER_KEYS);
  if (selectFn) {
    filterOptions.select = selectFn;
  }
  var result = filterOptions.select ? (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .select */ .Lt)(assets, filterOptions.select) : (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .clone */ .o8)(assets);
  if (filterOptions.sortFn || filterOptions.sortBy) {
    result = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .sort */ .di)(result, filterOptions.sortFn || filterOptions.sortBy);
  }

  // If "unique" is given, it means we only want the first asset with that
  // property. We can leverage sortBy and select to meaningfully order the
  // assets, essentially letting us choose which one is unique.
  if (filterOptions.unique) {
    var uniqHash = {};
    for (var i = 0; i < result.length; i++) {
      var asset = result[i];
      var bucket = asset["".concat(filterOptions.unique)] || '__undefined__';
      if (!uniqHash[bucket]) {
        uniqHash[bucket] = asset;
      }
    }
    result = [];
    for (var k in uniqHash) {
      result.push(uniqHash[k]);
    }
  }
  return result;
};
var one = function one(assets, options) {
  return filter(assets, options)[0] || null;
};
var readyPublicMp3s = function readyPublicMp3s(assets) {
  return filter(assets, {
    ext: 'mp3',
    status: READY,
    public: true
  });
};
var readyPublicMp4s = function readyPublicMp4s(assets) {
  return filter(assets, {
    container: 'mp4',
    status: READY,
    public: true
  });
};
var readyPublicM3u8s = function readyPublicM3u8s(assets) {
  return filter(assets, {
    container: 'm3u8',
    status: READY,
    public: true
  });
};
var filterOver400 = function filterOver400(assets) {
  var result = [];
  for (var i = 0; i < assets.length; i++) {
    var a = assets[i];
    var vbitrateInRange = a.opt_vbitrate != null && a.opt_vbitrate >= 500 && a.opt_vbitrate <= 100000;
    var widthInRange = a.width != null && a.width > 400;
    if (vbitrateInRange || widthInRange) {
      result.push(a);
    }
  }
  return result;
};
var readyPublicOver400 = function readyPublicOver400(assets) {
  return filterOver400(filter(assets, {
    container: /mp4/,
    public: true,
    status: READY
  }));
};
var nonfailedPublicOver400 = function nonfailedPublicOver400(assets) {
  return filterOver400(filter(assets, {
    container: /mp4/,
    public: true,
    status: function status(s) {
      return s !== FAILED;
    }
  }));
};
var withinQualityRange = function withinQualityRange(assets) {
  var qualityMin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var qualityMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;
  return filter(assets, {
    select: function select(asset) {
      // quality is based on width * height, and given back in a format like
      // 720, 1080, 3840, etc.
      var quality = numericSizeSnapped(asset.width, asset.height);
      return qualityMin <= quality && quality <= qualityMax;
    }
  });
};
var numericSizeSnapped = function numericSizeSnapped(width, height) {
  if (height > width) {
    // let's mathematically rotate vertical videos when determining their
    // snapped size.
    var tmpWidth = width;
    width = height;
    height = tmpWidth;
  }
  var aspectRatio = width / height;

  // If given a square video, expand the width so we'll name it as if
  // it's 16:9 with the given height.
  if (aspectRatio < 1.05) {
    width = height * (16 / 9);
  }
  if (width >= 3740) {
    return 2160;
  }
  if (width >= 2460) {
    return 1440;
  }
  if (width >= 1820) {
    return 1080;
  }
  if (width >= 1180) {
    return 720;
  }
  if (width >= 860) {
    return 540;
  }
  if (width >= 540) {
    return 360;
  }
  return height;
};

// Expect that assets are a subset of assets that we are allowed to select.
// This function does not have any special logic to filter only selectable
// assets.
var findClosestAssetByQuality = function findClosestAssetByQuality(assets, quality) {
  var height;
  if (quality === '4k') {
    height = 2160;
  } else {
    // '360p' yields 360, '1080i' yields 1080, etc.
    height = parseInt(quality, 10);
  }
  var exactMatch = withinQualityRange(assets, height, height)[0];
  if (exactMatch) {
    return exactMatch;
  }
  var surroundingAssets = nearestOutsideRange(assets, height, height);
  if (surroundingAssets.length === 1) {
    return surroundingAssets[0];
  }
  var aspect = videoAspect(assets);
  var width = Math.round(aspect * height);
  var _surroundingAssets = _slicedToArray(surroundingAssets, 2),
    lowerAsset = _surroundingAssets[0],
    upperAsset = _surroundingAssets[1];
  var lowerDiff = Math.abs(lowerAsset.width - width);
  var upperDiff = Math.abs(upperAsset.width - width);
  if (lowerDiff < upperDiff) {
    return lowerAsset;
  }
  return upperAsset;
};
var still = function still(assets) {
  var stillAsset = one(assets, {
    type: /^still_image$/,
    sortBy: 'created_at desc'
  });

  // If no still is associated, check for channel artwork
  if (!stillAsset) {
    stillAsset = channelArtworkStill(assets);
  }

  // If no still or channel art is associated, generate from the first video asset
  // we can find.
  if (!stillAsset) {
    stillAsset = one(assets, {
      container: /mp4/,
      sortBy: 'width desc'
    });
  }
  return stillAsset;
};
var channelArtworkStill = function channelArtworkStill(assets) {
  return one(assets, {
    type: /^channel_still_image$/,
    sortBy: 'created_at desc'
  });
};
var thumbnailAssets = function thumbnailAssets(assets, options) {
  if (options.stillUrl) {
    return [{
      height: null,
      url: options.stillUrl,
      width: null
    }];
  }
  var stillAsset = still(assets);
  if (options.instantHlsStillAsset != null && (!stillAsset || /mp4/.test(stillAsset.container))) {
    return [options.instantHlsStillAsset];
  }
  if (options.originalFileStillAsset != null && (!stillAsset || /mp4/.test(stillAsset.container))) {
    return [options.originalFileStillAsset];
  }
  if (!stillAsset) {
    return [];
  }
  var stillAspect = stillAsset.width / stillAsset.height;
  return [320, 640, 960, 1280, 1920, 3840].map(function (width) {
    var height = Math.round(width / stillAspect);
    var url = stillUrl(assets, {
      videoWidth: width,
      videoHeight: height,
      playButton: false
    });
    return {
      height: height,
      url: url,
      width: width
    };
  });
};
var FAST_HOSTNAME = (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_5__/* .appHostname */ .N)('fast');
var stillUrl = function stillUrl(assets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var stillAsset = still(assets);

  // @TODO should this throw an error instead?
  if (!stillAsset) return;
  if (stillAsset.status !== READY) {
    // occasionally we might get a stillAsset that isn't ready, but its
    // channel art is for an audio! fallback to that first!
    var channelArtwork = channelArtworkStill();
    if (channelArtwork && channelArtwork.status === READY) {
      return channelArtwork.url;
    }
    return "//".concat(FAST_HOSTNAME, "/assets/images/blank.gif");
  }
  options = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .merge */ .h1)({
    aspect: stillAsset.width / stillAsset.height || 1,
    // default to square if we can't determine the aspect
    stillUrl: stillAsset.url,
    playButton: false,
    playerColor: options.playerColor || '636155',
    videoWidth: stillAsset.width || 640,
    videoHeight: stillAsset.height || 360,
    stillSnap: true
  }, options);
  var stillWidth = options.videoWidth;
  var stillHeight = options.videoHeight;
  var result = new utilities_url_js__WEBPACK_IMPORTED_MODULE_1__/* .Url */ .s0(options.stillUrl);
  if (options.retina) {
    result.params.image_play_button_size = '2x';
    stillWidth *= 2;
    stillHeight *= 2;
  }

  // By default, we snap to a pre-generated still size
  if (options.stillSnap) {
    stillWidth = getStillWidth({
      videoWidth: stillWidth,
      stillAssetWidth: stillAsset.width || 640 // there have been times where we fail to have proper width returned
    });
    stillHeight = Math.round(stillWidth / options.aspect);
  }

  // Don't do anything special if this is not a Wistia hosted image.
  if (!isBakeryUrl(options.stillUrl)) {
    return options.stillUrl;
  }
  if (options.protocol === 'https:') {
    result.protocol = 'https:';
    // Under normal circumstances, the host for assets should depend on the
    // environment  but if you're using the embedHost option to use non-prod
    // code with prod embeds, we force using a prod host.
    result.host = options.embedHost === utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .PROD_FAST_HOSTNAME_COM */ .pb || options.embedHost === utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .PROD_FAST_HOSTNAME_NET */ .bF ? utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .PROD_SSL_EMBED_HOST */ .iD : utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .SSL_EMBED_HOST */ .cu;
  }
  result.params.image_crop_resized = "".concat(stillWidth, "x").concat(stillHeight);
  if (options.playButton == null || options.playButton) {
    result.params.image_play_button_rounded = 1;
    result.params.image_play_button_color = "".concat("".concat(options.playerColor).replace(/^#+/, ''), "e0");
  }
  if (options.ext) {
    result.ext(options.ext);
  }

  // if the extension has not been transformed, default to a jpg
  if (result.ext() === 'bin') {
    result.ext('jpg');
  }
  return result.absolute();
};

// We only make three sizes of a thumbnail for a given video: 1280, 960, and
// 640 wide. We have logic on the server that matches this as well. The idea
// is that since we only use these three, we can generate them beforehand so
// they're always ready and automatic for the people.
var getStillWidth = function getStillWidth(options) {
  var potentialStillWidths = [640, 960, 1280, 1920, 3840];

  // We also have a still that's the exact width of the one they uploaded
  // or generated (so long as it is less than 3840px across)
  if (options.stillAssetWidth < 3840) {
    potentialStillWidths.push(options.stillAssetWidth);
  }

  // We don't create thumbnails that are larger than the stillAssetWidth,
  // so eliminate anything that's larger than that, because it's wasteful to
  // scale up an image past it's original size!
  var availableStillWidths = [];
  for (var i = 0; i < potentialStillWidths.length; i++) {
    var width = potentialStillWidths[i];
    if (width <= options.stillAssetWidth) {
      availableStillWidths.push(width);
    }
  }

  // sort the widths in place.
  availableStillWidths.sort(function (a, b) {
    return a - b;
  });

  // Use the still that's equal to or slightly larger than the size of the
  // video embed.
  for (var _i = 0; _i < availableStillWidths.length; _i++) {
    var _width = availableStillWidths[_i];
    if (options.videoWidth <= _width) {
      return _width;
    }
  }

  // Can't find one that fits? Let's use the biggest available width.
  return Math.max.apply(Math, availableStillWidths);
};
var BAKERY_HOSTS = [utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .EMBED_HOST */ .pK, utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .SSL_EMBED_HOST */ .cu, (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_5__/* .appHostname */ .N)('embed'), (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_5__/* .appHostname */ .N)('prime'), (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_5__/* .appHostname */ .N)('mixergy-cdn'), (0,_appHostname_js__WEBPACK_IMPORTED_MODULE_5__/* .appHostname */ .N)('embed-fastly'),
// XXX: akamai test
utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .PROD_EMBED_HOST */ .hk, utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .PROD_SSL_EMBED_HOST */ .iD, utilities_hosts_js__WEBPACK_IMPORTED_MODULE_3__/* .PROD_FASTLY_SSL_HOST */ .KG];

// Check if a given url is like embed.wistia.com, embed-ssl.wistia.com,
// prime.wistia.com, etc.
var isBakeryUrl = function isBakeryUrl(rawUrl) {
  if (rawUrl == null) {
    return false;
  }
  var url = new utilities_url_js__WEBPACK_IMPORTED_MODULE_1__/* .Url */ .s0(rawUrl);
  if (!url.host) {
    return false;
  }
  return BAKERY_HOSTS.join(',').indexOf(url.host) >= 0;
};
var onePublicReadyWithContainer = function onePublicReadyWithContainer(assets, type, options) {
  options = (0,utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__/* .merge */ .h1)({
    container: type,
    public: true,
    status: READY
  }, options);
  return one(assets, options);
};
var mp4 = function mp4(assets, options) {
  return onePublicReadyWithContainer(assets, 'mp4', options);
};
var webm = function webm(assets, options) {
  return onePublicReadyWithContainer(assets, 'webm', options);
};
var m3u8 = function m3u8(assets, options) {
  return onePublicReadyWithContainer(assets, 'm3u8', options);
};
var original = function original(assets) {
  return one(assets, {
    type: 'original'
  });
};

// If we support webm, prefer webm (since VP9 codec is better), otherwise
// use mp4 (h264)
var playable = function playable(assets, options) {
  var detect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cachedDetect();
  if (detect.video.webm) {
    return webm(assets, options) || mp4(assets, options);
  }
  return mp4(assets, options);
};
var videoAspect = function videoAspect(assets) {
  var asset = mp4(assets) || m3u8(assets) || webm(assets) || original(assets);
  if (asset && asset.height) {
    return asset.width / asset.height;
  }
  // no assets available; use default aspect 1.6667
  return 640 / 360;
};
var originalAspect = function originalAspect(assets) {
  var derivativeAspect = videoAspect(assets);
  var asset = original(assets);
  if (asset && asset.width && asset.height) {
    var candidateAspect = asset.width / asset.height;
    if (candidateAspect > 1 && derivativeAspect < 1 || candidateAspect < 1 && derivativeAspect > 1) {
      // the original is rotated relative to its derivatives
      return 1 / candidateAspect;
    }
    return candidateAspect;
  }
  return derivativeAspect;
};
var iphone = function iphone(assets, options) {
  var aspect = videoAspect(assets);
  if (aspect > 1) {
    options = merge({
      width: 640
    }, options);
    return mp4(assets, options) || smallestNormalMp4(assets, options);
  }
  var opt1 = merge({
    width: 320
  }, options);
  var opt2 = merge({
    width: 640
  }, options);
  return mp4(assets, opt1) || mp4(assets, opt2) || smallestNormalMp4(assets, options);
};
var smallestNormalMp4 = function smallestNormalMp4(assets, options) {
  options = merge({
    sortBy: 'width asc',
    width: [640, 1920]
  }, options);
  return mp4(assets, options);
};
var urlWithCorrectHost = function urlWithCorrectHost(assetUrl) {
  var proto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Hosts.eV1Protocol();
  var parsedUrl = new Url(assetUrl);
  if (isBakeryUrl(assetUrl)) {
    if (proto === 'https:') {
      parsedUrl.host = Hosts.deliveryHost(location.protocol);
      parsedUrl.protocol = 'https:';
    } else {
      parsedUrl.host = Hosts.deliveryHost(location.protocol);
      parsedUrl.protocol = 'http:';
    }
  }
  return parsedUrl.absolute();
};

// It is possible for our customers to give us quality ranges that are
// impossible to solve for a given video. In these cases, we want to instead
// use the assets that are closest to satisfying their constraints. For
// example, if they specify 4k and we only go up to 1080p, it'll use 1080p.
// Or if they specify a range _between_ two, say 800p to 900p, it'll use the
// two surrounding values: 720p and 1080p.
var nearestOutsideRange = function nearestOutsideRange(assets, lower, upper) {
  if (assets.length === 0) {
    return [];
  }
  var sortedAssets = aps.call(assets).sort(function (a, b) {
    return numericSizeSnapped(a.width, a.height) - numericSizeSnapped(b.width, b.height);
  });
  var lowerAsset;
  var upperAsset;
  for (var i = 0; i < sortedAssets.length; i++) {
    var asset = sortedAssets[i];
    var assetSize = numericSizeSnapped(asset.width, asset.height);
    if (assetSize < lower) {
      lowerAsset = asset;
    }
    if (assetSize >= upper) {
      upperAsset = asset;
      break;
    }
  }

  // get rid of nulls
  var result = [];
  if (lowerAsset) {
    result.push(lowerAsset);
  }
  if (upperAsset) {
    result.push(upperAsset);
  }

  // If somehow we didn't end up with any assets, don't fail completely, but
  // let us know.
  if (result.length === 0) {
    utilities_wlog_js__WEBPACK_IMPORTED_MODULE_4__/* .wlog */ .ct.error('nearestOutsideRange: no nearby assets found, using first in list', sortedAssets[0]);
    result.push(sortedAssets[0]);
  }
  return result;
};

// This operates on the array in-place
var moveToFront = function moveToFront(assets, toFront) {
  if (!toFront) {
    return assets;
  }
  var index = -1;
  for (var i = 0; i < assets.length; i++) {
    var asset = assets[i];
    if (asset.url === toFront.url) {
      index = i;
      break;
    }
  }

  // If it's -1, it wasn't found. If it's 0, it's already in front.
  if (index > 0) {
    assets.splice(index, 1);
    assets.unshift(toFront);
  }
  return assets;
};

/***/ }),

/***/ 7211:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ shouldEnableMux),
/* harmony export */   _: () => (/* binding */ MUX_PERCENTAGE_TO_ENABLE)
/* harmony export */ });
var MUX_PERCENTAGE_TO_ENABLE = 0.1;

/**
 * Determines if Mux should be enabled for an embed based on various conditions.
 * @param {PublicApi} video The embed mux should be enabled for.
 * @param {boolean} didWinCoinFlip Whether or not the embed won the coin flip which determines if Mux should be enabled.
 * @returns {boolean} True if Mux should be enabled, false otherwise.
 */
var shouldEnableMux = function shouldEnableMux(video, didWinCoinFlip) {
  var isMuxEnabledOnWindow = window.wistiaDisableMux !== true;
  var isMuxEnabledFromOpts = !video._opts || video._opts.mux !== false;
  var isMuxEnabledFromStandardEmbed = video.iframe == null;
  var isMuxEnabledFromCoinFlip = didWinCoinFlip;
  var isMuxEnabledFromLiveStream = !!(video._mediaData && video._mediaData.type === 'LiveStream');

  // Mux should be enabled if all of the following are true:
  // 1. Mux is not disabled on the window
  // 2. Mux is not disabled from the embed options
  // 3. Mux is not disabled from the video being an iframe embed
  // 4. Mux is not disabled from the coin flip OR the video is a live stream
  // (Live streams should always have Mux enabled, regardless of the coin flip result)
  return isMuxEnabledOnWindow && isMuxEnabledFromOpts && isMuxEnabledFromStandardEmbed && (isMuxEnabledFromCoinFlip || isMuxEnabledFromLiveStream);
};

/***/ }),

/***/ 7229:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ secondsToIso8601Duration)
/* harmony export */ });
/* harmony import */ var _duration_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1341);

var SECONDS_IN_MINUTE = 60;
var secondsToIso8601Duration = function secondsToIso8601Duration(totalSeconds) {
  var _secondsConverter = (0,_duration_ts__WEBPACK_IMPORTED_MODULE_0__/* .secondsConverter */ .ab)(totalSeconds, 'hms'),
    hours = _secondsConverter.hours,
    minutes = _secondsConverter.minutes,
    seconds = _secondsConverter.seconds;
  var result = '';
  if (hours) {
    result += "".concat(hours, "H");
  }
  if (minutes || totalSeconds > SECONDS_IN_MINUTE && seconds !== 0) {
    result += "".concat(minutes, "M");
  }
  if (seconds || totalSeconds === 0) {
    result += "".concat(seconds, "S");
  }
  return result;
};

/***/ }),

/***/ 7231:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GS: () => (/* binding */ detectIsMobile),
/* harmony export */   o1: () => (/* binding */ cachedDetect)
/* harmony export */ });
/* unused harmony exports callingPlayRequiresEventContext, webp, uncachedDetect, clearDetectCache */
/* harmony import */ var utilities_root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8176);
/* harmony import */ var _performance_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);


var na = navigator.userAgent;
var _playerDetectCache = null;

// ua regexes taken from http://code.jquery.com/jquery-1.6.4.js
var rwebkit = /(webkit)[ /]([^\s]+)/i;
var ropera = /OPR\/([^\s]+)/i;
var redge = /(edge)\/(\d+(?:\.\d+)?)/i;
var rmozilla = /(mozilla)(?:.*? rv:([^\s)]+))?/i;

// special platform regexes
var randroid = /(android) ([^;]+)/i;
var riphone = /(iphone)/i;
var rwinphone = /(Windows Phone OS (\d+(?:\.\d+)?))/;
var rios = /OS (\d+)_(\d+)/i;
var rfirefox = /(firefox)/i;
var rgearvr = /Mobile VR/i;

// Apple keeps their Safari version the same as their iOS version
// (with the exception being that they occasionally release the new safari
// slightly before the new iOS is available)
var riosVersion = /Version\/([^\s]+)/i;
var browser = function browser() {
  return (browserMatch()[1] || 'webkit').toLowerCase();
};
var browserVersion = function browserVersion() {
  return browserMatch()[2];
};
var browserMatch = function browserMatch() {
  var match;
  match = na.match(redge);
  if (match) {
    return match;
  }
  match = na.match(rwebkit);
  if (match) {
    return match;
  }
  match = na.match(ropera);
  if (match) {
    return match;
  }
  if (match) {
    if (document.documentMode != null) {
      match[2] = document.documentMode;
    }
    return match;
  }
  match = na.match(rmozilla);
  if (match) {
    return match;
  }
  return [];
};

// return false if not android, version info if android
var android = function android() {
  var matches = na.match(randroid);
  if (matches == null) {
    return false;
  }
  return {
    version: matches[2]
  };
};
var oldandroid = function oldandroid() {
  return android() && parseFloat(android().version) < 4.1;
};
var iphone = function iphone() {
  return riphone.test(na);
};
var touchScreen = function touchScreen() {
  return iosVersion() > 0 || android() || ipad();
};
var hoverIsNatural = function hoverIsNatural() {
  // The (hover: hover) query matches when two conditions are met:
  //
  // 1. hover is supported
  // 2. hover is easy to access for the user based on their primary input device
  //
  // So for example, when the users primary input is touch, this returns false
  // even though hover interactions are technically supported.
  //
  // If matchMedia is unsupported or the hover query is unsupported, we fall
  // back on returning the heuristic check for iOS or Android. If it is true,
  // we assume hover is not natural. This can produce false negatives and false
  // positives, but most agents support the hover query.
  //
  // This is an alternative to using touchScreen() when deciding whether to
  // attach enter/leave mouse event handlers based on hover capability.

  try {
    var mediaQueryList = matchMedia('(hover:hover)');
    if (mediaQueryList.media !== 'not all') {
      return mediaQueryList.matches;
    }
  } catch (err) {
    // feature detection: swallow errors.
  }
  return !touchScreen();
};
var retina = function retina() {
  return utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.devicePixelRatio != null && utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.devicePixelRatio > 1;
};
var ipad = function ipad() {
  return /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 1;
};
var safari = function safari() {
  return rwebkit.test(na) && !/chrome/i.test(na) && !ipad() && !iphone();
};
var chrome = function chrome() {
  if (/Chrome/.test(na) && /Google Inc/.test(navigator.vendor)) {
    return {
      version: chromeVersion()
    };
  }
  return false;
};
var silkVersion = function silkVersion() {
  var match = na.match(/\bSilk\/([^\s]+)/);
  return match && match[1];
};
var chromeVersion = function chromeVersion() {
  var match = na.match(/\bChrome\/([^\s]+)/);
  return match && match[1];
};
var opera = function opera() {
  return ropera.test(na);
};
var iosVersion = function iosVersion() {
  var iosMatch = na.match(rios);
  var versionMatch = na.match(riosVersion);
  if (iosMatch != null) {
    return parseFloat("".concat(iosMatch[1], ".").concat(iosMatch[2]));
  }
  if (versionMatch != null && versionMatch[1] && ipad()) {
    // to get the version of an ipad that is reporting as a Mac in its
    // user agent, we can rely on the Version part of the ua to be
    // fairly certain
    return parseFloat(versionMatch[1]);
  }
  return 0;
};
var windowsPhone = function windowsPhone() {
  return rwinphone.test(na);
};
var edge = function edge() {
  return redge.test(na);
};
var firefox = function firefox() {
  return rfirefox.test(na);
};
var gearvr = function gearvr() {
  return rgearvr.test(na);
};
var windows = function windows() {
  return /win/i.test(navigator.platform);
};
var mac = function mac() {
  return /mac/i.test(navigator.platform);
};

// modified slightly from http://www.modernizr.com/downloads/modernizr-2.0.6.js
var html5Video = function html5Video() {
  var elem = document.createElement('video');
  var result = false;

  // IE9 Running on Windows Server SKU can cause an exception to be thrown, bug #224
  try {
    if (elem.canPlayType) {
      result = {};
      // Workaround required for IE9, which doesn't report video support without audio codec specified.
      // bug 599718 @ msft connect
      var h264 = 'video/mp4; codecs="avc1.42E01E';
      result.h264 = !!elem.canPlayType("".concat(h264, "\"")) || !!elem.canPlayType("".concat(h264, ", mp4a.40.2\""));
      result.webm = !!elem.canPlayType('video/webm; codecs="vp9, vorbis"');
      result.nativeHls = !!elem.canPlayType('application/vnd.apple.mpegURL');
    }
  } catch (e) {
    result = {
      ogg: false,
      h264: false,
      webm: false,
      nativeHls: false
    };
  }
  return result;
};
var mediaSource = function mediaSource() {
  var h264 = 'video/mp4; codecs="avc1.42E01E';
  return utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.MediaSource && utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.MediaSource.isTypeSupported("".concat(h264, ", mp4a.40.2\""));
};
var nativeHls = function nativeHls() {
  return (iphone() || ipad() || safari()) && html5Video().nativeHls;
};
var localStorage = function localStorage() {
  try {
    return "localStorage" in utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z && utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z.localStorage != null;
  } catch (e) {
    return false;
  }
};
var fullscreenEnabled = function fullscreenEnabled() {
  return document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled;
};
var browserPrefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
var mutationObserver = function mutationObserver() {
  for (var i = 0; i < browserPrefixes.length; i++) {
    var prefix = browserPrefixes[i];
    var prop = "".concat(prefix, "MutationObserver");
    if (utilities_root_js__WEBPACK_IMPORTED_MODULE_0__/* .root */ .z[prop]) {
      return prop;
    }
  }
  return null;
};
var vulcanV2Support = function vulcanV2Support() {
  var modernBrowser = /webkit|mozilla|edge/.test(browser());
  if (iphone() || ipad() || android()) {
    return true;
  }
  return Boolean(modernBrowser && html5Video().h264 && Object.defineProperties);
};
var isPassiveSupported;
var passiveSupported = function passiveSupported() {
  if (isPassiveSupported != null) {
    return isPassiveSupported;
  }
  try {
    var options = Object.defineProperty({}, 'passive', {
      /* eslint-disable-next-line getter-return */get: function get() {
        isPassiveSupported = true;
      }
    });
    window.addEventListener('test', null, options);
  } catch (err) {
    isPassiveSupported = false;
  }
  return isPassiveSupported;
};
var callingPlayRequiresEventContext = function callingPlayRequiresEventContext() {
  return iosVersion() > 0 || android() || safari();
};

// https://caniuse.com/#search=webp
// use user-agent for browser and version webp detection
// we're opting for this over a feature detection mechanism so that our detection
// can be as fast and synchronous as possible. Doing an async feature detection
// occasionally resulted in false negatives.
var webp = function webp() {
  var chromeBrowser = chrome();
  var firefoxBrowser = firefox();
  var edgeBrowser = edge();
  var operaBrowser = opera();
  var isChromeDesktopSupported = chromeBrowser && browserVersion() >= 32;
  var isChromeAndroidSupported = chromeBrowser && browserVersion() >= 75 && android();
  var isFirefoxDesktopSupported = firefoxBrowser && browserVersion() >= 65;
  var isFirefoxAndroidSupported = firefoxBrowser && browserVersion() >= 67 && android();
  var isEdgeSupported = edgeBrowser && browserVersion() >= 18;
  var isOperaSupported = operaBrowser && browserVersion() >= 19;
  return isChromeDesktopSupported || isChromeAndroidSupported || isFirefoxDesktopSupported || isFirefoxAndroidSupported || isEdgeSupported || isOperaSupported;
};
var cachedDetect = function cachedDetect() {
  if (_playerDetectCache) {
    // Allow this to be cached globally so it's not executed once every time
    // it's imported.
    return _playerDetectCache;
  }
  _playerDetectCache = uncachedDetect();
  return _playerDetectCache;
};
var uncachedDetect = function uncachedDetect() {
  var result = {
    browser: {
      version: browserVersion()
    },
    edge: edge(),
    firefox: firefox(),
    gearvr: gearvr(),
    android: android(),
    oldandroid: oldandroid(),
    iphone: iphone(),
    ipad: ipad(),
    safari: safari(),
    chrome: chrome(),
    winphone: {
      version: windowsPhone()[2]
    },
    ios: {
      version: iosVersion()
    },
    windows: windows(),
    mac: mac(),
    retina: retina(),
    hoverIsNatural: hoverIsNatural(),
    touchScreen: touchScreen(),
    video: html5Video(),
    mediaSource: mediaSource(),
    nativeHls: nativeHls(),
    localstorage: localStorage(),
    fullscreenEnabled: fullscreenEnabled(),
    vulcanV2Support: vulcanV2Support(),
    mutationObserver: mutationObserver(),
    callingPlayRequiresEventContext: callingPlayRequiresEventContext(),
    passiveSupported: passiveSupported(),
    webp: webp(),
    performanceMeasure: (0,_performance_ts__WEBPACK_IMPORTED_MODULE_1__/* .hasPerformanceMeasureSupport */ .O)()
  };
  result.browser[browser()] = true;
  return result;
};
var clearDetectCache = function clearDetectCache() {
  _playerDetectCache = null;
};

// Starting a migration away from cachedDetect in the wistia-player web component
// Based on https://github.com/wistia/player-modern/blob/main/docs/ifaq.md#whats-the-deal-with-cacheddetect-and-why-do-we-also-assign-the-result-of-it
var detectIsMobile = function detectIsMobile() {
  var isAndroid = android();
  var isIPad = ipad();
  var isIPhone = iphone();
  return isAndroid || isIPad || isIPhone;
};

/***/ }),

/***/ 7323:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ didWinCoinFlip)
/* harmony export */ });
var MAX_RANDOM_VALUE = 0xffffffff;

/**
 * Simulates a coin flip with a given percentage to win
 * @param percentToWinCoinFlip - Number between 0 and 1 representing the percentage to win the coin flip
 * @returns boolean - True if the coin flip was won, false otherwise
 */
var didWinCoinFlip = function didWinCoinFlip(percentToWinCoinFlip) {
  var cryptoObj = window.crypto;
  if (typeof cryptoObj !== 'undefined') {
    var cryptoRandom = cryptoObj.getRandomValues(new Uint32Array(1));
    return cryptoRandom[0] / (MAX_RANDOM_VALUE + 1) < percentToWinCoinFlip;
  }
  var mathRandom = Math.random();
  return mathRandom >= percentToWinCoinFlip;
};

/***/ }),

/***/ 7350:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   b: () => (/* binding */ isGradient)
/* harmony export */ });
// [color, percentage]

// Gradients can get into this state if the hex code for the color is a numeric
// string and it gets casted to a number.

var isGradient = function isGradient(value) {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  var _ref = value,
    colors = _ref.colors,
    on = _ref.on;
  if (!on) {
    return true;
  }
  if (!Array.isArray(colors) || typeof on !== 'boolean') {
    return false;
  }
  if (colors.length === 0) {
    return false;
  }
  return colors.every(function (color) {
    return typeof color[0] === 'string' && typeof color[1] === 'number';
  });
};

/***/ }),

/***/ 7438:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hy: () => (/* binding */ getViewerPreferences)
/* harmony export */ });
/* unused harmony exports deleteViewerPreferences, getViewerPreference, setViewerPreference */
/* harmony import */ var utilities_namespacedLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2917);

var deleteViewerPreferences = function deleteViewerPreferences() {
  removeLocalStorage(getLocalStorageKey());
};
var getLocalStorageKey = function getLocalStorageKey() {
  return 'wistia-viewer-preferences';
};
var getViewerPreferences = function getViewerPreferences() {
  return (0,utilities_namespacedLocalStorage_js__WEBPACK_IMPORTED_MODULE_0__/* .getLocalStorage */ .Lg)(getLocalStorageKey());
};
var getViewerPreference = function getViewerPreference(preference) {
  var preferences = getViewerPreferences();
  if (!preferences) {
    return null;
  }
  return preferences[preference];
};
var setViewerPreference = function setViewerPreference(preference, value) {
  // delete the plugin property. fix for captions setting plugin.captions-v1 - which caused a bug
  // as when captions was getting enabled. This can be removed after a couple
  // of weeks or so
  updateLocalStorage(getLocalStorageKey(), function (obj) {
    if (obj.plugin) {
      delete obj.plugin;
    }
    obj[preference] = value;
  });
};

/***/ }),

/***/ 7715:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ev: () => (/* binding */ addInlineCss),
/* harmony export */   Rx: () => (/* reexport safe */ utilities_pageLoaded_js__WEBPACK_IMPORTED_MODULE_6__.R),
/* harmony export */   cG: () => (/* binding */ elemWidth),
/* harmony export */   lj: () => (/* binding */ elemInDom)
/* harmony export */ });
/* unused harmony exports elemHtml, getCssTags, execCssTags, removeCssTags, elemFromObject, elemToObject, elemClone, elemAppend, elemPrepend, elemBefore, elemAfter, elemRemove, elemRemoveClass, elemAddClass, elemHasClass, elemClasses, elemStyle, propsWithVendorPrefixes, getComputedStyle, elemHeight, elemContainsOffset, elemScrollOffset, elemIsHidden, elemIsDescendantOf, elemAncestorWithClass, elemAncestorHasClass, elemAncestors, elemIsInside, elemAnimate, elemBind, elemUnbind, elemUnbindAll, elemUnbindAllInside, elemBindKey, elemRebind, elemBindOnce, elemTrigger, fullscreenElement, elemRequestFullscreen, elemCancelFullscreen, elemStripEventAttributes, elemMutationObserver, docScrollTop, docScrollLeft, safeRequestAnimationFrame, formInputIsFocused, currentEventSource, inUserEventContext, getLastActiveEventAt */
/* harmony import */ var utilities_obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(731);
/* harmony import */ var utilities_pageLoaded_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9562);
/* harmony import */ var utilities_detect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7231);
/* harmony import */ var utilities_wlog_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6637);
/* harmony import */ var utilities_script_tags_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6461);
/* harmony import */ var utilities_seqid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1224);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5509);
var _objectHasOwn = function (object, property) {
  if (typeof object === 'undefined' || object === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
};









var W = (/* unused pure expression or super */ null && (Wistia));
var detect = (0,utilities_detect_js__WEBPACK_IMPORTED_MODULE_1__/* .cachedDetect */ .o1)();




var elemHtml = function elemHtml(elem, content) {
  var cssTags = getCssTags(content);
  var scriptTags = getScriptTags(content);
  content = removeCssTags(content);
  content = removeScriptTags(content);
  elem.innerHTML = content;
  execCssTags(cssTags, elem);

  // these script tags will be removed in short order as part of the script
  // loader
  return execScriptTags(scriptTags);
};
var getCssTags = function getCssTags(htmlStr) {
  return htmlStr.match(/<link.*?rel=['"]stylesheet['"][^>]*>|<style>[\s\S]+?<\/style>/gi) || [];
};
var execCssTags = function execCssTags(cssTags, parentElem) {
  if (!cssTags) {
    return null;
  }
  if (!isArray(cssTags)) {
    cssTags = getCssTags(cssTags);
  }
  var inserted = [];
  for (var i = 0; i < cssTags.length; i++) {
    var cssTag = cssTags[i];
    if (/<link.*?rel=['"]stylesheet['"][^>]*>/.test(cssTag)) {
      var matches = cssTag.match(/href=['"](.*?)['"]/i);
      if (matches) {
        var link = document.createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.setAttribute('href', matches[1]);
        link.className = 'wistia_injected_style';
        (parentElem || document.body || document.head).appendChild(link);
        inserted.push(link);
      }
    } else if (/<style>[\s\S]+?<\/style>/gi.test(cssTag)) {
      var _matches = cssTag.match(/<style>([\s\S]+?)<\/style>/i);
      if (_matches) {
        var style = addInlineCss(parentElem || document.body || document.head, _matches[1]);
        inserted.push(style);
      }
    }
  }
  return inserted;
};
var removeCssTags = function removeCssTags(htmlStr) {
  return htmlStr.replace(/<link.*?rel=['"]stylesheet['"][^>]*>|<style>[\s\S]+?<\/style>/gi, '');
};
var addInlineCss = function addInlineCss(domTarget, css) {
  var target = domTarget || document.body || document.head;
  var styleElem = document.createElement('style');
  styleElem.id = (0,utilities_seqid_js__WEBPACK_IMPORTED_MODULE_4__/* .seqId */ .h)('wistia_', '_style');
  styleElem.setAttribute('type', 'text/css');
  styleElem.className = 'wistia_injected_style';
  target.appendChild(styleElem, target.nextSibling);
  if (styleElem.styleSheet) {
    styleElem.styleSheet.cssText = css;
  } else {
    styleElem.appendChild(document.createTextNode(css));
  }
  return styleElem;
};
var _elemFromObject = function elemFromObject(obj) {
  if (isArray(obj)) {
    var result = [];
    for (var i = 0; i < obj.length; i++) {
      result.push(_elemFromObject(obj[i]));
    }
    return result;
  }
  var tagName = obj.tagName || 'div';
  var childNodes = obj.childNodes || [];
  if (!isArray(childNodes)) {
    childNodes = [childNodes];
  }
  var elem = document.createElement(tagName);
  for (var key in obj) {
    if (_objectHasOwn(obj, key)) {
      var val = obj[key];
      if (key !== 'childNodes' && key !== 'tagName' && key !== 'ref') {
        var dashedKey = key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        if (key === 'style') {
          if (isObject(val)) {
            for (var p in val) {
              elem.style[p] = val[p];
            }
          } else {
            // setAttribute('style', ...) only works in IE8+, so parse inline
            // styles if it's passed in as a string.
            var styles = val.split(';');
            for (var _i = 0; _i < styles.length; _i++) {
              var pair = styles[_i].split(/\s*:\s*/);
              var _p = pair[0];
              var v = pair[1];
              if (_p && v) {
                elem.style[_p] = v;
              }
            }
          }
        } else if (key === 'events') {
          for (var evt in val) {
            var callback = val[evt];
            elemBind(elem, evt, callback);
          }
        } else if (key === 'className' || key === 'class') {
          elem.className = val;
        } else if (key === 'innerHTML') {
          elem.innerHTML = val;
        } else if (key === 'innerText') {
          elem.innerText = val;
        } else if (val != null && typeof val.toString === 'function') {
          elem.setAttribute(dashedKey, val.toString());
        }
      }
    }
  }
  for (var _i2 = 0; _i2 < childNodes.length; _i2++) {
    var childObj = childNodes[_i2];
    if (isObject(childObj)) {
      var child = _elemFromObject(childObj);
      _elemAppend(elem, child);
    } else {
      var _child = document.createTextNode(childObj.toString());
      _elemAppend(elem, _child);
    }
  }
  if (typeof obj.ref === 'function') {
    obj.ref(elem);
  }
  return elem;
};

var _elemToObject = function elemToObject(elem) {
  if (isArray(elem)) {
    var _result = [];
    for (var i = 0; i < elem.length; i++) {
      _result.push(_elemToObject(elem[i]));
    }
  }
  var result = {};
  result.tagName = elem.tagName.toLowerCase();
  var elemKeys = Object.keys(elem);
  for (var _i3 = 0; _i3 < elemKeys.length; _i3++) {
    var attr = elemKeys[_i3];
    if (attr !== 'tagName' && attr !== 'childNodes' && attr !== 'nodeType' && attr !== 'nodeValue') {
      if (attr === 'style') {
        result.style = {};
        var styleKeys = Object.keys(elem.style);
        for (var j = 0; j < styleKeys.length; j++) {
          var prop = styleKeys[j];
          var val = elem.style[prop];
          if (val && !/^\d/.test(prop) && prop !== 'length') {
            result.style[prop] = val;
          }
        }
      } else {
        var value = elem.getAttribute(attr);
        if (value != null) {
          result[attr] = value;
        }
      }
    }
  }
  var children = [];
  for (var _i4 = 0; _i4 < elem.childNodes.length; _i4++) {
    var child = elem.childNodes[_i4];
    if (child.nodeType === 1) {
      children.push(_elemToObject(child));
    } else if (child.nodeType === 3) {
      children.push(child.nodeValue);
    }
  }
  if (children.length > 0) {
    result.childNodes = children;
  }
  return result;
};

var elemClone = function elemClone(elem) {
  var obj = _elemToObject(elem);
  return _elemFromObject(obj);
};
var _elemAppend = function elemAppend(par, elem) {
  if (isArray(elem)) {
    for (var i = 0; i < elem.length; i++) {
      _elemAppend(par, elem[i]);
    }
    return;
  }
  if (par.tagName.includes('-')) {
    par.shadowRoot.appendChild(elem, {
      wistiaGridCaller: true
    });
  } else {
    par.appendChild(elem, {
      wistiaGridCaller: true
    });
  }
};

var _elemPrepend = function elemPrepend(par, elem) {
  if (isArray(elem)) {
    for (var i = 0; i < elem.length; i++) {
      _elemPrepend(par, elem[i]);
    }
    return;
  }
  if (par.childNodes.length === 0) {
    return _elemAppend(par, elem);
  }
  return par.insertBefore(elem, par.childNodes[0]);
};

var _elemBefore = function elemBefore(sibling, elem) {
  if (isArray(elem)) {
    elem = elem.reverse();
    for (var i = 0; i < elem.length; i++) {
      _elemBefore(sibling, elem[i]);
    }
    return;
  }
  return sibling.parentNode.insertBefore(elem, sibling);
};

var _elemAfter = function elemAfter(sibling, elem) {
  if (isArray(elem)) {
    elem = elem.reverse();
    for (var i = 0; i < elem.length; i++) {
      _elemAfter(sibling, elem[i]);
    }
    return;
  }
  return sibling.parentNode.insertBefore(elem, sibling.nextSibling);
};

var _elemRemove = function elemRemove(elem) {
  if (isArray(elem) || window.NodeList && elem instanceof NodeList) {
    for (var i = 0; i < elem.length; i++) {
      _elemRemove(elem[i]);
    }
    return;
  }
  var par;
  if (elem != null && (elem.nodeType === 1 || elem.nodeType === 3) && (par = elem.parentNode)) {
    par.removeChild(elem);
    elem = null;
  }
};

var _elemRemoveClass = function elemRemoveClass(elem, klass) {
  if (isArray(elem) || window.NodeList && elem instanceof NodeList) {
    for (var i = 0; i < elem.length; i++) {
      _elemRemoveClass(elem[i], klass);
    }
    return;
  }
  if (!elemHasClass(elem, klass)) {
    return;
  }
  var className = elem.getAttribute('class');
  if (className) {
    var regexp = new RegExp("\\b".concat(klass, "\\b"), 'g');
    var newClassString = normalizeClassName(className.replace(regexp, ''));
    elem.setAttribute('class', newClassString);
  }
};

var _elemAddClass = function elemAddClass(elem, klass) {
  if (isArray(elem) || window.NodeList && elem instanceof NodeList) {
    for (var i = 0; i < elem.length; i++) {
      _elemAddClass(elem[i], klass);
    }
    return;
  }
  if (elemHasClass(elem, klass)) {
    return;
  }
  var className = elem.getAttribute('class');
  var newClassString;
  if (className) {
    _elemRemoveClass(elem, klass);
    newClassString = normalizeClassName("".concat(className, " ").concat(klass));
  } else {
    newClassString = klass;
  }
  elem.setAttribute('class', newClassString);
};

// Longer than ` ${elem.className} `.indexOf(` ${klass} `) >= 0, but doesn't
// cause JIT code deoptimization in Chrome.

var elemHasClass = function elemHasClass(elem, klass) {
  var className = elem != null && typeof elem.getAttribute === 'function' && elem.getAttribute('class');
  if (!className && elem && typeof elem.className === 'string') {
    className = elem.className;
  }
  if (!className) {
    return false;
  }
  var returnValue = false;
  eachIndexOf(className, klass, function (index) {
    var classBeginningFound = index === 0 || className.charAt(index - 1) === ' ';
    var endsWidthClass = index + klass.length === className.length;
    var classInMiddle = className.charAt(index + klass.length) === ' ';
    if (classBeginningFound && (endsWidthClass || classInMiddle)) {
      returnValue = true;
      return BREAK_IDENTIFIER;
    }
  });
  return returnValue;
};
var BREAK_IDENTIFIER = {};
var eachIndexOf = function eachIndexOf(str, needle, fn) {
  var i = -1;
  while ((i = str.indexOf(needle, i + 1)) != -1) {
    if (fn(i) === BREAK_IDENTIFIER) {
      break;
    }
  }
};
var elemClasses = function elemClasses(elem) {
  if (elem && typeof elem.className !== 'string') {
    // Sometimes, className doesn't return a string. Who knew?!
    // https://wistia.zendesk.com/agent/tickets/196879
    return [''];
  }
  return (elem && elem.className || '').split(/\s+/);
};
var normalizeClassName = function normalizeClassName(className) {
  return className.replace(/^\s+/g, '').replace(/\s+$/g, '').replace(/\s+/g, ' ');
};
var _elemStyle = function elemStyle(elem) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (isArray(elem) || window.NodeList && elem instanceof NodeList) {
    var result = [];
    for (var i = 0; i < elem.length; i++) {
      var node = elem[i];
      if (node.nodeType === 1) {
        result.push(_elemStyle.apply(void 0, [node].concat(args)));
      }
    }
    return result;
  }
  if (args.length === 2) {
    var prop = args[0];
    var val = args[1];
    elem.style[prop] = val;
  } else if (args.length === 1) {
    if (typeof args[0] === 'string') {
      var _prop = args[0];
      try {
        if (elem.currentStyle) {
          return elem.currentStyle[_prop];
        }
        if (window.getComputedStyle) {
          return window.getComputedStyle(elem, null).getPropertyValue(_prop);
        }
        return null;
      } catch (e) {
        wlog.notice(e);
      }
    } else {
      var props = propsWithVendorPrefixes(args[0]);
      for (var _prop2 in props) {
        var _val = props[_prop2];
        elem.style[_prop2] = _val;
      }
    }
  } else {
    wlog.apply(void 0, ['Unexpected args', elem].concat(args));
  }
};

var VENDORED_PROPERTIES = {
  borderImage: true,
  mixBlendMode: true,
  transform: true,
  transition: true,
  transitionDuration: true
};
var VENDOR_PREFIXES = (/* unused pure expression or super */ null && (['webkit', 'moz', 'o', 'ms']));
var propsWithVendorPrefixes = function propsWithVendorPrefixes(props) {
  if (detect.chrome) {
    return props;
  }
  var result = {};
  for (var prop in props) {
    var val = props[prop];
    result[prop] = val;
    if (VENDORED_PROPERTIES[prop]) {
      var prefixes = VENDOR_PREFIXES;
      for (var i = 0; i < prefixes.length; i++) {
        var prefix = prefixes[i];
        var prefixedProp = prefix + prop.charAt(0).toUpperCase() + prop.slice(1);
        if (!prop[prefixedProp]) {
          result[prefixedProp] = val;
        }
      }
    }
  }
  return result;
};
var getComputedStyle = function getComputedStyle(elem, prop) {
  if (!window.getComputedStyle) {
    return null;
  }
  var computed = window.getComputedStyle(elem, null);
  if (computed == null) {
    return null;
  }
  if (prop != null) {
    return computed[prop];
  }
  return computed;
};
var elemWidth = function elemWidth(elem) {
  if (elem === window) {
    if (window.innerWidth) {
      return window.innerWidth;
    }
    if (document.documentElement) {
      return document.documentElement.offsetWidth;
    }
    return document.body.offsetWidth;
  }
  if (elem === document) {
    var body = document.body;
    var html = document.documentElement;
    return Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
  }
  var val;
  if ((val = getComputedStyle(elem, 'width')) && val != null) {
    return parseFloat(val);
  }
  if (elem.currentStyle) {
    return elem.offsetWidth;
  }
  return -1;
};
var elemHeight = function elemHeight(elem) {
  if (elem === window) {
    if (window.innerHeight) {
      return window.innerHeight;
    }
    if (document.documentElement) {
      return document.documentElement.offsetHeight;
    }
    return document.body.offsetHeight;
  }
  if (elem === document) {
    var body = document.body;
    var html = document.documentElement;
    return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
  }
  var val;
  if ((val = getComputedStyle(elem, 'height')) && val != null) {
    return parseFloat(val);
  }
  if (elem.currentStyle) {
    return elem.offsetHeight;
  }
  return -1;
};
var elemContainsOffset = function elemContainsOffset(elem, left, top) {
  var offset = elemOffset(elem);
  offset.right = offset.left + elemWidth(elem);
  offset.bottom = offset.top + elemHeight(elem);
  return offset.left <= left && left < offset.right && offset.top <= top && top < offset.bottom;
};
var elemScrollOffset = function elemScrollOffset(elem) {
  var curLeft = 0;
  var curTop = 0;
  if (elem.parentNode) {
    while (elem && elem.offsetParent) {
      curTop += elem.scrollTop;
      curLeft += elem.scrollLeft;
      elem = elem.parentNode;
    }
  }
  return {
    left: curLeft,
    top: curTop
  };
};
var elemIsHidden = function elemIsHidden(elem) {
  while (elem && elem.nodeType === 1) {
    if (_elemStyle(elem, 'display') === 'none') {
      return true;
    }
    elem = elem.parentNode;
  }
  return false;
};
var elemInDom = function elemInDom(elem) {
  while (elem) {
    if (elem === document) {
      return true;
    }
    elem = elem.parentNode || elem.getRootNode().host;
  }
  return false;
};
var elemIsDescendantOf = function elemIsDescendantOf(elem, target) {
  var ancestors = elemAncestors(elem);
  for (var i = 0; i < ancestors.length; i++) {
    if (ancestors[i] === target) {
      return true;
    }
  }
  return false;
};
var elemAncestorWithClass = function elemAncestorWithClass(elem, klass) {
  var ancestors = elemAncestors(elem);
  for (var i = 0; i < ancestors.length; i++) {
    if (elemHasClass(ancestors[i], klass)) {
      return ancestors[i];
    }
  }
  return null;
};
var elemAncestorHasClass = function elemAncestorHasClass(elem, klass) {
  var ancestor = elemAncestorWithClass(elem, klass);
  return !!ancestor;
};
var elemAncestors = function elemAncestors(elem) {
  var current = elem;
  var result = [];
  while (current = current.parentNode) {
    result.push(current);
  }
  return result;
};
var elemIsInside = function elemIsInside(elem, ancestor) {
  return elem === ancestor || elemIsDescendantOf(elem, ancestor);
};
var getTransitionProp = function getTransitionProp(props, time, easing) {
  var result = [];
  for (var prop in props) {
    result.push("".concat(prop, " ").concat(time, "ms ").concat(easing));
  }
  return result.join(',');
};
var elemAnimate = function elemAnimate(elem) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  options = merge({
    time: 400,
    easing: 'ease'
  }, options);
  var transitions = getTransitionProp(props, options.time, options.easing);
  _elemStyle(elem, {
    transition: transitions
  });
  safeRequestAnimationFrame(function () {
    _elemStyle(elem, props);
    setTimeout(function () {
      _elemStyle(elem, {
        transition: ''
      });
      if (typeof options.callback === 'function') {
        options.callback();
      }
    }, options.time);
  });
};
var elemBind = function elemBind(elem, event, fn) {
  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var eventShim = function eventShim(e) {
    e = e || window.event;

    // Normalize pageX, pagey
    if (!e.pageX && !e.pageY && (e.clientX || e.clientY)) {
      e.pageX = e.clientX + docScrollLeft();
      e.pageY = e.clientY + docScrollTop();
    }

    // Normalize preventDefault
    if (!e.preventDefault) {
      e.preventDefault = function () {
        e.returnValue = false;
      };
    }

    // Normalize stopPropagation
    if (!e.stopPropagation) {
      e.stopPropagation = function () {
        e.cancelBubble = true;
      };
    }

    // Normalize `which`
    if (e.which == null) {
      e.which = e.charCode != null ? e.charCode : e.keyCode;
    }
    if (e.which == null && e.button != null) {
      if (e.button & 1) {
        e.which = 1; // left
      } else if (e.button & 2) {
        e.which = 3; // right
      } else if (e.button & 4) {
        e.which = 2; // middle
      } else {
        e.which = 0; // no button pressed
      }
    }

    // Normalize `target`
    if (e.target) {
      // perfect
    } else if (e.srcElement) {
      e.target = e.srcElement;
    }
    if (e.target && e.target.nodeType === 3) {
      e.target = e.target.parentNode;
    }

    // Actually call the function
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var result = fn.apply(e.target, [e].concat(args));

    // Sweet anonymous unbinding logic
    if (result === elemUnbind) {
      elemUnbind(elem, event, fn);
    }
    return result;
  };
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_5__/* .Wistia */ .s._elemBind = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_5__/* .Wistia */ .s._elemBind || {};
  var key = elemBindKey(elem, event, fn);
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_5__/* .Wistia */ .s._elemBind[key] = eventShim;

  // Set the elem/event property so we can unbind all for the elem
  eventShim.elem = elem;
  eventShim.event = event;
  elem.addEventListener(event, eventShim, useCapture);
  return function () {
    elemUnbind(elem, event, fn, useCapture);
  };
};
var elemUnbind = function elemUnbind(elem, event, fn) {
  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (!(elem != null && elem._wistiaElemId != null && fn != null && fn._wistiaBindId)) {
    return;
  }
  var key = elemBindKey(elem, event, fn);
  var eventShim = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_5__/* .Wistia */ .s._elemBind[key];
  if (eventShim) {
    elem.removeEventListener(event, eventShim, useCapture);
    eventShim.elem = null;
    eventShim.event = null;
  }
  return delete _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_5__/* .Wistia */ .s._elemBind[key];
};
var elemUnbindAll = function elemUnbindAll(elem) {
  for (var key in Wistia._elemBind) {
    var eventShim = Wistia._elemBind[key];
    if (eventShim && elem === eventShim.elem) {
      var event = eventShim.event;
      eventShim.elem.removeEventListener(event, eventShim, false);
      eventShim.elem = null;
      eventShim.event = null;
      delete Wistia._elemBind[key];
    }
  }
};
var elemUnbindAllInside = function elemUnbindAllInside(container) {
  var count = 0;
  for (var key in Wistia._elemBind) {
    var eventShim = Wistia._elemBind[key];
    if (eventShim && elemIsInside(eventShim.elem, container)) {
      var event = eventShim.event;
      eventShim.elem.removeEventListener(event, eventShim, false);
      eventShim.elem = null;
      eventShim.event = null;
      delete Wistia._elemBind[key];
      count += 1;
    }
  }
  return count;
};
var elemBindKey = function elemBindKey(elem, event, fn) {
  elem._wistiaElemId = elem._wistiaElemId || (0,utilities_seqid_js__WEBPACK_IMPORTED_MODULE_4__/* .seqId */ .h)('wistia_elem_');
  fn._wistiaBindId = fn._wistiaBindId || (0,utilities_seqid_js__WEBPACK_IMPORTED_MODULE_4__/* .seqId */ .h)('wistia_bind_');
  return "".concat(elem._wistiaElemId, ".").concat(event, ".").concat(fn._wistiaBindId);
};
var elemRebind = function elemRebind(elem, event, fn) {
  if (fn) {
    elemUnbind(elem, event, fn);
    return elemBind(elem, event, fn);
  }
};
var elemBindOnce = function elemBindOnce(elem, event, fn) {
  var wrap = function wrap() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    fn.apply(this, args);
    return elemUnbind;
  };
  return elemBind(elem, event, wrap);
};
var elemTrigger = function elemTrigger(elem, event) {
  for (var _len4 = arguments.length, customArguments = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    customArguments[_key4 - 2] = arguments[_key4];
  }
  if (elem.dispatchEvent) {
    var eventObj = document.createEvent('Events');
    eventObj.initEvent(event, true, false);
    if (event === 'click' || event === 'doubleclick') {
      eventObj.which = 1;
    } else if (event === 'rightclick') {
      eventObj.which = 2;
    }
    eventObj.customArguments = customArguments;
    return elem.dispatchEvent(eventObj);
  }
  if (elem.fireEvent) {
    var _eventObj = {
      customArguments: customArguments
    };
    return elem.fireEvent("on".concat(event), _eventObj);
  }
  wlog.error('neither dispatchEvent nor fireEvent is defined for', elem, event);
};
var fullscreenElement = function fullscreenElement() {
  return document.fullscreenElement || document.webkitFullscreenElement;
};
var elemRequestFullscreen = function elemRequestFullscreen(elem) {
  if (elem.requestFullscreen) {
    return elem.requestFullscreen();
  }
  if (elem.webkitEnterFullscreen) {
    return new Promise(function (resolve) {
      elem.webkitEnterFullscreen();
      resolve();
    });
  }
  wlog.notice('no requestFullscreen functionality detected');
  return Promise.resolve();
};
var elemCancelFullscreen = function elemCancelFullscreen(elem) {
  if (document.exitFullscreen) {
    return document.exitFullscreen();
  }
  if (elem && elem.webkitExitFullscreen) {
    return new Promise(function (resolve) {
      elem.webkitExitFullscreen();
      resolve();
    });
  }
  wlog.notice('no cancelFullscreen functionality detected');
  return Promise.resolve();
};
var _elemStripEventAttributes = function elemStripEventAttributes(elem) {
  var attributes = elem && elem.attributes || [];
  try {
    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];
      if (/^on.+/i.test(attr.name)) {
        elem[attr.name] = null;
        elem.removeAttribute(attr.name);
      }
    }
  } catch (e) {
    wlog.error(e);
  }
  if (elem.childNodes) {
    for (var _i5 = 0; _i5 < elem.childNodes.length; _i5++) {
      var child = elem.childNodes[_i5];
      if (child.nodeType === 1) {
        _elemStripEventAttributes(child);
      }
    }
  }
};

var elemMutationObserver = function elemMutationObserver(fn) {
  var klass = detect.mutationObserver;
  if (klass) {
    return new window[klass](fn);
  }
  return null;
};
var docScrollTop = function docScrollTop(t) {
  var docBody = document.body;
  var docElem = document.documentElement;
  if (t != null) {
    if (docBody) {
      docBody.scrollTop = t;
    }
    if (docElem) {
      docElem.scrollTop = t;
    }
  } else {
    return docElem && docElem.scrollTop || docBody && docBody.scrollTop || 0;
  }
};
var docScrollLeft = function docScrollLeft(t) {
  var docBody = document.body;
  var docElem = document.documentElement;
  if (t != null) {
    if (docBody) {
      docBody.scrollLeft = t;
    }
    if (docElem) {
      docElem.scrollLeft = t;
    }
  } else {
    return docElem && docElem.scrollLeft || docBody && docBody.scrollLeft || 0;
  }
};
var safeRequestAnimationFrame = function safeRequestAnimationFrame(fn) {
  var requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
    return setTimeout(callback, 1000 / 60);
  };
  return requestAnimFrame(fn);
};
var formInputIsFocused = function formInputIsFocused() {
  var activeElement = document.activeElement.tagName === 'WISTIA-PLAYER' ? document.activeElement.shadowRoot.activeElement : document.activeElement;
  return /^textarea|input|select$/i.test(activeElement.tagName) || activeElement.isContentEditable;
};
var currentEventSource = function currentEventSource() {
  return inUserEventContext() ? 'user-event' : 'non-user-event';
};
var inUserEventContext = function inUserEventContext() {
  return !!activeDOMEvent;
};
var getLastActiveEventAt = function getLastActiveEventAt() {
  return lastActiveEventAt;
};
var activeDOMEvent;
var lastActiveEventAt = (/* unused pure expression or super */ null && (-1));
var userEventsThatShowIntent = ['auxclick', 'click', 'contextmenu', 'dblclick', 'focus', 'keydown', 'keypress', 'keyup', 'mousedown', 'mouseup', 'reset', 'submit', 'touchend', 'touchstart'];
userEventsThatShowIntent.forEach(function (type) {
  var onEvent = function onEvent(e) {
    activeDOMEvent = e;
    lastActiveEventAt = Date.now();
    setTimeout(function () {
      if (activeDOMEvent === e) {
        // if some other event has triggered synchronously, let's not clobber it;
        // the last one to fire will set this to null.
        activeDOMEvent = undefined;
      }
    }, 0);
  };

  // We use capture = true because event.stopPropagation() would cause us to
  // miss this.
  elemBind(document, type, onEvent, detect.passiveSupported ? {
    capture: true,
    passive: true
  } : true);
});

/***/ }),

/***/ 7880:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ BigPlayButtonSVG)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
/* harmony import */ var _BigPlayButtonLoadingAnim_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4719);
/* harmony import */ var _utilities_svg_boilerplate_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1919);
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }



var ICON_WIDTH = 37;
var ICON_HEIGHT = 36;
var LOADING_ALPHA = 0.5;
var BigPlayButtonSVG = function BigPlayButtonSVG(_ref) {
  var width = _ref.width,
    height = _ref.height,
    scale = _ref.scale,
    _ref$isLoading = _ref.isLoading,
    isLoading = _ref$isLoading === void 0 ? false : _ref$isLoading;
  var scaledHeight = height * scale;
  var svgAttrs = (0,_utilities_svg_boilerplate_ts__WEBPACK_IMPORTED_MODULE_2__/* .standardSvgAttrs */ .I)({
    width: width,
    height: height,
    styleOverride: {
      position: 'absolute',
      height: "".concat(scaledHeight, "px")
    },
    ariaHidden: true
  });

  // Center the icon within the width and height of the button
  var iconXOffset = -(ICON_WIDTH / 2) + width / 2;
  var iconYOffset = -(ICON_HEIGHT / 2) + height / 2;
  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("svg", _extends({}, svgAttrs, {
    "aria-hidden": "true"
  }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    fill: "#FFFFFF",
    opacity: isLoading ? LOADING_ALPHA : 1,
    transform: "translate(".concat(iconXOffset, ", ").concat(iconYOffset, ")"),
    d: "M12.138 2.173C10.812 1.254 9 2.203 9 3.817v28.366c0 1.613 1.812 2.563 3.138 1.644l20.487-14.183a2 2 0 0 0 0-3.288L12.138 2.173Z"
  }), isLoading && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_BigPlayButtonLoadingAnim_tsx__WEBPACK_IMPORTED_MODULE_1__/* .BigPlayButtonLoadingAnim */ .e, null));
};

/***/ }),

/***/ 8089:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = merge;


/***/ }),

/***/ 8176:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ root)
/* harmony export */ });
var rootTest;
try {
  rootTest = self; // dom or web worker
  if (rootTest.self !== rootTest && typeof rootTest.self !== 'undefined' && typeof window !== 'undefined') {
    // Accidentally assigning `self` is a thing that websites do. But most of
    // these accidental assigns won't have a self property pointing at themselves.
    rootTest = window;
  }
} catch (err) {
  if (typeof globalThis !== 'undefined') {
    rootTest = globalThis; // es native in the future
  } else {
    // oh god, what's even happening
    rootTest = window;
  }
}
var root = rootTest;

/***/ }),

/***/ 8213:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w5: () => (/* binding */ interNumbersSemiBold)
/* harmony export */ });
/* unused harmony exports interBoldItalicFontFamily, interFontFamily, interSemiBoldFontFamily */
var interBoldItalicFontFamily = 'WistiaPlayerInterBoldItalic, Helvetica, Sans-Serif';
var interFontFamily = 'WistiaPlayerInter, Helvetica, Sans-Serif';
var interSemiBoldFontFamily = 'WistiaPlayerInterSemiBold, Helvetica, Sans-Serif';
var interNumbersSemiBold = 'WistiaPlayerInterNumbersSemiBold, Helvetica, Sans-Serif';

/***/ }),

/***/ 8290:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;


/***/ }),

/***/ 9025:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   k: () => (/* binding */ assign)
/* harmony export */ });
var _objectHasOwn = function (object, property) {
  if (typeof object === 'undefined' || object === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
};
// You wouldn't believe it, but IE11 does not support Object.assign(), so this
// is our non-polyfill replacement.

var assign = function assign(obj1) {
  for (var _len = arguments.length, objs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objs[_key - 1] = arguments[_key];
  }
  if (Object.assign) {
    return Object.assign.apply(Object, [obj1].concat(objs));
  }
  for (var i = 0; i < objs.length; i++) {
    assignOne(obj1, objs[i]);
  }
  return obj1;
};
var assignOne = function assignOne(obj1, obj2) {
  for (var k in obj2) {
    if (_objectHasOwn(obj2, k)) {
      obj1[k] = obj2[k];
    }
  }
  return obj1;
};

/***/ }),

/***/ 9061:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E0: () => (/* binding */ unbindAllInNamespace),
/* harmony export */   Nw: () => (/* binding */ unbind),
/* harmony export */   RX: () => (/* binding */ bindNamed),
/* harmony export */   _Z: () => (/* binding */ unbindNamed),
/* harmony export */   hZ: () => (/* binding */ trigger),
/* harmony export */   oI: () => (/* binding */ bind)
/* harmony export */ });
/* unused harmony exports rebind, once, initNamespace, bindify, Bindings */
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5509);
var _objectHasOwn = function (object, property) {
  if (typeof object === 'undefined' || object === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(Object(object), property);
};
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

var aps = Array.prototype.slice;
var bind = function bind(event, fn) {
  var self = this;
  if (!self._bindings) {
    self._bindings = {};
  }
  if (!self._bindings[event]) {
    self._bindings[event] = [];
  }
  self._bindings[event].push(fn);
  return function () {
    self.unbind(event, fn);
  };
};
var unbind = function unbind(event, fn) {
  if (!this._bindings) {
    return this;
  }
  if (!this._bindings[event]) {
    return this;
  }
  var bindings = [];
  for (var i = 0; i < this._bindings[event].length; i++) {
    var boundFn = this._bindings[event][i];
    if (boundFn !== fn) {
      bindings.push(boundFn);
    }
  }
  this._bindings[event] = bindings;
};
var rebind = function rebind(event, fn) {
  this.unbind(event, fn);
  this.bind(event, fn);
  return {
    event: event,
    fn: fn
  };
};
var trigger = function trigger(event) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (this._bindings && this._bindings.all != null) {
    triggerImpl.apply(this, ['all', event].concat(args));
  }
  return triggerImpl.apply(this, [event].concat(args));
};
var triggerImpl = function triggerImpl(event) {
  if (!this._bindings) {
    return this;
  }
  if (!this._bindings[event]) {
    return this;
  }
  var args = aps.call(arguments, 1);
  var unbinds;
  // memoize necessary to loop over all bindings if one of the bindings
  // unbinds a following binding
  var bindings = _toConsumableArray(this._bindings[event]);
  for (var i = 0; i < bindings.length; i++) {
    var fn = bindings[i];
    try {
      var ret = fn.apply(this, args);
      // special return value will unbind when triggered
      if (ret === this.unbind) {
        if (unbinds == null) {
          unbinds = [];
        }
        unbinds.push({
          event: event,
          fn: fn
        });
      }
    } catch (e) {
      if (this._throwTriggerErrors) {
        throw e;
      } else if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s.error) {
        _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_0__/* .Wistia */ .s.error(e);
      }
    }
  }
  if (unbinds) {
    for (var _i = 0; _i < unbinds.length; _i++) {
      var _unbind = unbinds[_i];
      this.unbind(_unbind.event, _unbind.fn);
    }
  }
  return this;
};
var once = function once(event, fn) {
  var wrappedFn = function wrappedFn() {
    fn.apply(this, aps.call(arguments, 0));
    return unbind;
  };
  return bind(event, wrappedFn);
};
var initNamespace = function initNamespace(ctx, namespace) {
  if (ctx._namedBindings == null) {
    ctx._namedBindings = {};
  }
  if (ctx._namedBindings[namespace] == null) {
    ctx._namedBindings[namespace] = {};
  }
};
var getNamedBinding = function getNamedBinding(ctx, namespace, fnKey) {
  initNamespace(ctx, namespace);
  return ctx._namedBindings[namespace][fnKey];
};
var setNamedBinding = function setNamedBinding(ctx, namespace, fnKey, event, fn) {
  initNamespace(ctx, namespace);
  ctx._namedBindings[namespace][fnKey] = {
    event: event,
    fn: fn
  };
};
var bindNamed = function bindNamed(namespace, fnKey, event, fn) {
  this.unbindNamed(namespace, fnKey);
  setNamedBinding(this, namespace, fnKey, event, fn);
  this.bind(event, fn);
  return function () {
    this.unbindNamed(namespace, fnKey);
  };
};
var unbindNamed = function unbindNamed(namespace, fnKey) {
  initNamespace(this, namespace);
  var entry = getNamedBinding(this, namespace, fnKey);
  if (entry) {
    var event = entry.event,
      fn = entry.fn;
    this.unbind(event, fn);
  }
  var namedBindings = this._namedBindings;
  delete namedBindings[namespace][fnKey];
  if (isEmpty(namedBindings[namespace])) {
    delete namedBindings[namespace];
  }
  return this;
};
var unbindAllInNamespace = function unbindAllInNamespace(namespace) {
  var bindings = this._namedBindings && this._namedBindings[namespace];
  if (bindings == null) {
    return this;
  }
  for (var fnKey in bindings) {
    if (_objectHasOwn(bindings, fnKey)) {
      this.unbindNamed(namespace, fnKey);
    }
  }
};
var isEmpty = function isEmpty(obj) {
  for (var k in obj) {
    if (_objectHasOwn(obj, k)) {
      return false;
    }
  }
  return true;
};
var bindify = function bindify(prototype) {
  prototype.bind = bind;
  prototype.unbind = unbind;
  prototype.on = bind;
  prototype.off = unbind;
  prototype.rebind = rebind;
  prototype.trigger = trigger;
  prototype.bindNamed = bindNamed;
  prototype.unbindNamed = unbindNamed;
  prototype.unbindAllInNamespace = unbindAllInNamespace;
  return prototype;
};

// If you don't want to mix in state with an existing object, you can use this
// as a proxy, for example:
//
// var bindings = new Bindings();
// bindings.bind('hello', function(name) {
//   console.log('hi', name);
//   return bindings.unbind;
// });
// bindings.trigger('hello', 'Max');
var Bindings = function Bindings() {};
bindify(Bindings.prototype);

/***/ }),

/***/ 9128:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ normalizeChapters)
/* harmony export */ });
/* harmony import */ var _wistia_type_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4586);
// chapters has two ways of being defined in embed options.
// The current way is as an object inside `embedOptions.plugin`
// The old way was as root embed options like `chaptersOn` and `chapterList`.
// This function normalizes the old root embed option format to an object
// like the current model


var normalizeChapters = function normalizeChapters(embedOptions) {
  var plugin = embedOptions.plugin,
    chaptersOn = embedOptions.chaptersOn,
    chapterList = embedOptions.chapterList;
  if (plugin !== null && plugin !== void 0 && plugin.chapters) {
    return plugin.chapters;
  }
  var areChaptersOn = chaptersOn === true || chaptersOn === 'true';
  if ((0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_0__/* .isNotNil */ .n9)(chapterList) || areChaptersOn) {
    var hasChapters = (0,_wistia_type_guards__WEBPACK_IMPORTED_MODULE_0__/* .isNotNil */ .n9)(chapterList) && chapterList.length > 0;
    var list = hasChapters ? chapterList : [];
    return {
      on: chaptersOn,
      chapterList: list
    };
  }
  return undefined;
};

/***/ }),

/***/ 9376:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ makeWbindable)
/* harmony export */ });
/* harmony import */ var utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9061);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5509);
/* harmony import */ var _eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2694);




// This is an adaptation on top of bindify that is intended to provide both
// legacy functionality (returning `this` instead of an "unbind" function) and
// and functionality for "crosstime" and "betweentimes", which are
// "composite" bindings that do not have normal event signatures, as they take additional arguments.
//
// If you're setting up on/off/trigger for any new things, you should use
// bindify directly instead.

if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.bindable) {
  if (!_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager) {
    _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager = {};
  }
  _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.bindable = {
    bind: function bind(event, callback) {
      if (event === 'crosstime' && this.crossTime) {
        this.crossTime.addBinding(arguments[1], arguments[2]);
        return this;
      }
      if (event === 'betweentimes' && this.betweenTimes) {
        this.betweenTimes.addBinding(arguments[1], arguments[2], arguments[3]);
        return this;
      }
      var embedElement = this.embedElement || this.container;
      if (Object.keys(_eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__/* .convertedEventNames */ .h).includes(event) && embedElement) {
        var id = identifierFromEmbedElement(embedElement);
        if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id] === undefined) {
          _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id] = new _eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__/* .EventShepherd */ .S();
        }
        _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id].addListener(event, embedElement, callback);
        return this;
      }
      if (callback) {
        utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .bind */ .oI.call(this, event, callback);
        return this;
      }
      if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.warn) {
        _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.warn(this.constructor.name, 'bind', 'falsey value passed in as callback:', callback);
      }
    },
    // unbind the matching callback and event for this video
    unbind: function unbind(event, callback) {
      if (event === 'crosstime' && this.crossTime) {
        if (!callback) {
          this.crossTime.removeAllBindings();
        } else {
          this.crossTime.removeBinding(arguments[1], arguments[2]);
        }
        return this;
      }
      if (event === 'betweentimes' && this.betweenTimes) {
        if (!callback) {
          this.betweenTimes.removeAllBindings();
        } else {
          this.betweenTimes.removeBinding(arguments[1], arguments[2], arguments[3]);
        }
        return this;
      }
      var embedElement = this.embedElement || this.container;
      if (Object.keys(_eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__/* .convertedEventNames */ .h).includes(event) && embedElement) {
        var id = identifierFromEmbedElement(embedElement);
        // return early if the EventShepherd for the hashedId is not defined
        if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id] === undefined) {
          return this;
        }
        _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id].removeListener(event, embedElement, callback);
        return this;
      }
      if (callback) {
        utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .unbind */ .Nw.call(this, event, callback);
      } else if (this._bindings) {
        // no callback passed in, so clear all callbacks for this event
        this._bindings[event] = [];
      }

      // null/delete the event keys if they have no events
      if (this._bindings && this._bindings[event] && !this._bindings[event].length) {
        this._bindings[event] = null;
        delete this._bindings[event];
      }
      return this;
    },
    on: function on(event, fn) {
      var _arguments = arguments,
        _this = this;
      if (event === 'crosstime' && this.crossTime) {
        this.crossTime.addBinding(arguments[1], arguments[2]);
        return function () {
          _this.crossTime.removeBinding(_arguments[1], _arguments[2]);
        };
      }
      if (event === 'betweentimes' && this.betweenTimes) {
        this.betweenTimes.addBinding(arguments[1], arguments[2], arguments[3]);
        return function () {
          _this.betweenTimes.removeBinding(_arguments[1], _arguments[2], _arguments[3]);
        };
      }
      var embedElement = this.embedElement || this.container;
      if (Object.keys(_eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__/* .convertedEventNames */ .h).includes(event) && embedElement) {
        var id = identifierFromEmbedElement(embedElement);
        if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id] === undefined) {
          _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id] = new _eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__/* .EventShepherd */ .S(embedElement);
        }
        _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id].addListener(event, embedElement, fn);
        return function () {
          _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id].removeListener(event, embedElement, fn);
        };
      }
      return utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .bind */ .oI.call(this, event, fn);
    },
    off: function off(event, fn) {
      if (event === 'crosstime' && this.crossTime) {
        return this.crossTime.removeBinding(arguments[1], arguments[2]);
      }
      if (event === 'betweentimes' && this.betweenTimes) {
        return this.betweenTimes.removeBinding(arguments[1], arguments[2], arguments[3]);
      }
      var embedElement = this.embedElement || this.container;
      if (Object.keys(_eventShepherd_ts__WEBPACK_IMPORTED_MODULE_2__/* .convertedEventNames */ .h).includes(event) && embedElement) {
        var id = identifierFromEmbedElement(embedElement);
        // return early if the EventShepherd for the hashedId is not defined
        if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id] === undefined) {
          return function () {};
        }
        return _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.EventShepherdManager[id].removeListener(event, embedElement, fn);
      }
      return utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .unbind */ .Nw.call(this, event, fn);
    },
    rebind: function rebind(event, callback) {
      this.unbind(event, callback);
      this.bind(event, callback);
      return this;
    },
    // fire an event trigger on the video. for play/pause/ended callbacks.
    trigger: function trigger(event) {
      var _bindify$trigger;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      (_bindify$trigger = utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .trigger */ .hZ).call.apply(_bindify$trigger, [this, event].concat(args));
      return this;
    },
    bindNamed: function bindNamed() {
      return utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .bindNamed */ .RX.apply(this, arguments);
    },
    unbindNamed: function unbindNamed() {
      return utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .unbindNamed */ ._Z.apply(this, arguments);
    },
    unbindAllInNamespace: function unbindAllInNamespace() {
      return utilities_bindify_js__WEBPACK_IMPORTED_MODULE_0__/* .unbindAllInNamespace */ .E0.apply(this, arguments);
    }
  };
}
var makeWbindable = function makeWbindable(obj) {
  for (var k in _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.bindable) {
    var v = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_1__/* .Wistia */ .s.bindable[k];
    if (!obj[k]) {
      obj[k] = v;
    }
  }
};
var identifierFromEmbedElement = function identifierFromEmbedElement(embedElement) {
  if (embedElement !== null && embedElement !== void 0 && embedElement.mediaId) {
    return embedElement.mediaId;
  }
  if (embedElement !== null && embedElement !== void 0 && embedElement.id) {
    return embedElement.id;
  }
};

/***/ }),

/***/ 9392:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C: () => (/* binding */ getWistiaOptions)
/* harmony export */ });
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8089);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_0__);

var getWistiaOptions = function getWistiaOptions(mediaId) {
  var _window$wistiaOptions, _window$wistiaOptions2;
  if (!window.wistiaOptions) {
    return {};
  }
  var globalOptions = (_window$wistiaOptions = window.wistiaOptions._all) !== null && _window$wistiaOptions !== void 0 ? _window$wistiaOptions : {};
  var mediaOptions = (_window$wistiaOptions2 = window.wistiaOptions[mediaId]) !== null && _window$wistiaOptions2 !== void 0 ? _window$wistiaOptions2 : {};
  return lodash_merge__WEBPACK_IMPORTED_MODULE_0___default()(globalOptions, mediaOptions);
};

/***/ }),

/***/ 9562:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ pageLoaded)
/* harmony export */ });
var pageLoaded = function pageLoaded(fn) {
  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4000;
  var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
  var win = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;
  if (/loaded|complete/.test(doc.readyState)) {
    setTimeout(fn, 0);
  } else {
    var unbind = function unbind() {
      win.removeEventListener('load', onPageLoad, false);
    };
    var onPageLoad = function onPageLoad() {
      clearTimeout(onLoadTimeout);
      unbind();
      fn();
    };
    win.addEventListener('load', onPageLoad, false);
    var onLoadTimeout = setTimeout(function () {
      unbind();
      fn();
    }, timeout);
  }
};

/***/ }),

/***/ 9804:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ PreloadThumbnail)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3817);
/* harmony import */ var _hooks_usePlayerData_tsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2721);
/* harmony import */ var _utilities_constants_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1512);
/* harmony import */ var _media_players_vulcanV2Player_shared_ui_components_BigPlayButton_tsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6906);
/* harmony import */ var _shared_ProgressiveThumbnail_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3164);
/* harmony import */ var _shared_translations_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4730);
/* harmony import */ var _utilities_assets_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7209);
/* harmony import */ var _utilities_fit_control_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4309);
/* harmony import */ var _utilities_roundedPlayerDefaults_ts__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(3123);
/* harmony import */ var _utilities_gradients_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(4372);
/* harmony import */ var _types_gradient_ts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7350);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/* eslint-disable jsx-a11y/no-static-element-interactions */
/* eslint-disable jsx-a11y/click-events-have-key-events */












var MAX_SCALE = 1.3;
var MIN_SCALE = 0.3;
var DEFAULT_LOWER_CUTOFF_WIDTH = 640;
var DEFAULT_UPPER_CUTOFF_WIDTH = 960;
var PreloadThumbnail = function PreloadThumbnail(_ref) {
  var _ref2, _ref3, _getGradientColor;
  var isPlayPending = _ref.isPlayPending,
    mediaId = _ref.mediaId,
    playerType = _ref.playerType,
    playerWidth = _ref.playerWidth;
  var _useState = (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useState */ .J0)(false),
    _useState2 = _slicedToArray(_useState, 2),
    isLoading = _useState2[0],
    setIsLoading = _useState2[1];
  (0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__/* .useEffect */ .vJ)(function () {
    if (isPlayPending) {
      setIsLoading(true);
    }
  }, [isPlayPending]);
  var _usePlayerData = (0,_hooks_usePlayerData_tsx__WEBPACK_IMPORTED_MODULE_2__/* .usePlayerData */ .$)(),
    embedOptions = _usePlayerData.embedOptions,
    mediaData = _usePlayerData.mediaData;
  var aspect = embedOptions.aspect,
    bigPlayButton = embedOptions.bigPlayButton,
    bpbTime = embedOptions.bpbTime,
    bigPlayButtonBorderRadius = embedOptions.bigPlayButtonBorderRadius,
    controlBarBorderRadius = embedOptions.controlBarBorderRadius,
    controlsVisibleOnLoad = embedOptions.controlsVisibleOnLoad,
    floatingControlBar = embedOptions.floatingControlBar,
    noMixBlendMode = embedOptions.noMixBlendMode,
    playButton = embedOptions.playButton,
    playerBorderRadius = embedOptions.playerBorderRadius,
    playerColor = embedOptions.playerColor,
    playerColorGradient = embedOptions.playerColorGradient,
    playerLanguage = embedOptions.playerLanguage,
    roundedPlayer = embedOptions.roundedPlayer,
    thumbnailAltText = embedOptions.thumbnailAltText,
    transparentLetterbox = embedOptions.transparentLetterbox;
  var aspectRatio = mediaData.aspectRatio,
    assets = mediaData.assets,
    duration = mediaData.duration,
    mediaType = mediaData.mediaType,
    name = mediaData.name;
  var height = playerWidth / ((_ref2 = aspect !== null && aspect !== void 0 ? aspect : aspectRatio) !== null && _ref2 !== void 0 ? _ref2 : _utilities_constants_ts__WEBPACK_IMPORTED_MODULE_9__/* .DEFAULT_ASPECT */ .R);
  var scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, (0,_utilities_fit_control_js__WEBPACK_IMPORTED_MODULE_7__/* .controlMultiplierEstimatedByWidth */ .wt)(playerWidth, [DEFAULT_LOWER_CUTOFF_WIDTH, DEFAULT_UPPER_CUTOFF_WIDTH])));
  var calculatedControlsVisibleOnLoad = controlsVisibleOnLoad && playerType === 'vulcan-v2';
  var defaultControlBarDistance = (0,_utilities_roundedPlayerDefaults_ts__WEBPACK_IMPORTED_MODULE_10__/* .getDefaultControlBarDistance */ .Ru)({
    controlBarBorderRadius: controlBarBorderRadius,
    floatingControlBar: floatingControlBar,
    roundedPlayer: roundedPlayer
  });
  var calculatedControlBarDistance = calculatedControlsVisibleOnLoad ? (_utilities_constants_ts__WEBPACK_IMPORTED_MODULE_9__/* .CONTROL_BAR_HEIGHT */ .E / 2 + defaultControlBarDistance) * scale : defaultControlBarDistance * scale;
  var calculatedBigPlayButtonBorderRadius = (0,_utilities_roundedPlayerDefaults_ts__WEBPACK_IMPORTED_MODULE_10__/* .getDefaultBigPlayButtonBorderRadius */ .gl)({
    bigPlayButtonBorderRadius: bigPlayButtonBorderRadius,
    roundedPlayer: roundedPlayer
  }) * scale;
  var calculatedPlayerBorderRadius = (0,_utilities_roundedPlayerDefaults_ts__WEBPACK_IMPORTED_MODULE_10__/* .getDefaultPlayerBorderRadius */ .JA)({
    playerBorderRadius: playerBorderRadius,
    roundedPlayer: roundedPlayer
  }) * scale;
  var backgroundColor = transparentLetterbox === true || calculatedPlayerBorderRadius > 0 ? 'transparent' : undefined;
  var thumbnailAssets = (0,_utilities_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .thumbnailAssets */ .Q0)(assets, {});
  var calculatedPlayerLanguage = (_ref3 = (0,_shared_translations_js__WEBPACK_IMPORTED_MODULE_5__/* .getLanguage */ .Z0)(playerLanguage)) !== null && _ref3 !== void 0 ? _ref3 : (0,_shared_translations_js__WEBPACK_IMPORTED_MODULE_5__/* .getLanguage */ .Z0)('en-US');
  var shouldShowBigPlayButton = bigPlayButton !== false && playButton !== false;
  var shouldShowBpbTime = bpbTime === true || bpbTime === 'true';
  var backgroundGradientCss = playerColorGradient !== null && playerColorGradient !== void 0 && playerColorGradient.on ? (0,_utilities_gradients_ts__WEBPACK_IMPORTED_MODULE_8__/* .getCssGradient */ .qN)(playerColorGradient) : undefined;

  // if the gradient is enabled and valid, use the first color in the gradient as the player color,
  // otherwise, just use the player color like normal
  var playerColorOrGradientColor = playerColorGradient !== null && playerColorGradient !== void 0 && playerColorGradient.on && (0,_types_gradient_ts__WEBPACK_IMPORTED_MODULE_11__/* .isGradient */ .b)(playerColorGradient) ? (_getGradientColor = (0,_utilities_gradients_ts__WEBPACK_IMPORTED_MODULE_8__/* .getGradientColor */ .yz)(playerColorGradient)) !== null && _getGradientColor !== void 0 ? _getGradientColor : playerColor : playerColor;
  var handleClick = function handleClick() {
    setIsLoading(true);
  };
  return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */ .FK, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    class: "w-css-reset",
    style: {
      cursor: 'pointer',
      width: '100%',
      height: "".concat(height, "px")
    },
    onClick: handleClick,
    tabIndex: shouldShowBigPlayButton ? -1 : 0
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ProgressiveThumbnail_jsx__WEBPACK_IMPORTED_MODULE_4__/* .ProgressiveThumbnail */ .E, {
    backgroundColor: backgroundColor,
    images: thumbnailAssets,
    isVisible: true,
    hashedId: mediaId,
    playerBorderRadius: calculatedPlayerBorderRadius,
    swatchEnabled: false,
    uiHasRendered: false,
    thumbnailAltText: thumbnailAltText !== null && thumbnailAltText !== void 0 ? thumbnailAltText : '',
    height: "".concat(height, "px")
  })), shouldShowBigPlayButton && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_media_players_vulcanV2Player_shared_ui_components_BigPlayButton_tsx__WEBPACK_IMPORTED_MODULE_3__/* .BigPlayButton */ .Fn, {
    borderRadius: calculatedBigPlayButtonBorderRadius,
    buttonTabIndex: 0,
    color: playerColorOrGradientColor,
    controlBarDistance: calculatedControlBarDistance,
    duration: duration !== null && duration !== void 0 ? duration : 0,
    isLiveMedia: mediaType === 'LiveStream',
    isLoading: isLoading,
    isVisible: true,
    noMixBlendMode: noMixBlendMode,
    onClick: handleClick,
    playerLanguage: calculatedPlayerLanguage,
    scale: scale,
    showBpbTime: shouldShowBpbTime,
    videoName: name !== null && name !== void 0 ? name : '',
    videoWidth: playerWidth,
    backgroundGradientCss: backgroundGradientCss
  }));
};

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/node module decorator */
/******/ (() => {
/******/ 	__webpack_require__.nmd = (module) => {
/******/ 		module.paths = [];
/******/ 		if (!module.children) module.children = [];
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ WistiaPlayer),
/* harmony export */   A: () => (/* binding */ wistiaSwatchElement)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5181);
/* harmony import */ var _utilities_gradients_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4372);
/* harmony import */ var _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5509);
/* harmony import */ var _components_PreloadThumbnail_tsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9804);
/* harmony import */ var _hooks_usePlayerData_tsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2721);
/* harmony import */ var _utilities_constants_ts__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(1512);
/* harmony import */ var _utilities_PlayerDataHandler_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6462);
/* harmony import */ var _appHostname_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(787);
/* harmony import */ var _utilities_assets_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7209);
/* harmony import */ var _utilities_coinFlip_ts__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(7323);
/* harmony import */ var _utilities_detect_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7231);
/* harmony import */ var _utilities_dynamicImport_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7157);
/* harmony import */ var _utilities_embedOptionStore_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3280);
/* harmony import */ var _utilities_elem_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7715);
/* harmony import */ var _utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(2760);
/* harmony import */ var _utilities_extractEmailFromParams_ts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(3832);
/* harmony import */ var _utilities_hosts_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(5857);
/* harmony import */ var _utilities_inferPageUrl_ts__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(5393);
/* harmony import */ var _utilities_judy_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(438);
/* harmony import */ var _utilities_roundedPlayerDefaults_ts__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(3123);
/* harmony import */ var _utilities_runScript_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1248);
/* harmony import */ var _utilities_seqid_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1224);
/* harmony import */ var _utilities_shouldEnableMux_ts__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(7211);
/* harmony import */ var _utilities_simpleMetrics_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1161);
/* harmony import */ var _utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(4755);
/* harmony import */ var _utilities_url_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(2671);
/* harmony import */ var _utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(4997);
/* harmony import */ var _utilities_wistiaOptions_ts__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(9392);
/* harmony import */ var _utilities_wistiaQueue_ts__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(541);
/* harmony import */ var _utilities_wlog_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(6637);
/* harmony import */ var _utilities_injectJsonLd_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(2147);
/* harmony import */ var _utilities_getInitialMediaData_ts__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(5833);
/* harmony import */ var _utilities_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(959);
/* harmony import */ var _utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(3411);
/* harmony import */ var _utilities_camelCaseToKebabCase_ts__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(4989);
/* harmony import */ var _types_gradient_ts__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(7350);
var _WistiaPlayer;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == typeof e || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }





































// The component will not run without these attributes.
var requiredAttributes = ['media-id'];

// Optional attributes surfaced in documentation to our customers.
var optionalPublicAttributes = ['aspect', 'audio-description-control', 'autoplay', 'big-play-button', 'branding', 'controls-visible-on-load', 'copy-link-and-thumbnail', 'current-time', 'do-not-track', 'email', 'end-video-behavior', 'fullscreen-control', 'language', 'muted', 'playback-rate-control', 'play-bar-control', 'player-color', 'playlist-links', 'playlist-loop', 'play-pause-control', 'play-pause-notifier', 'popover-animate-thumbnail', 'popover-animation', 'popover-border-color', 'popover-border-radius', 'popover-border-width', 'popover-box-shadow', 'popover-caption', 'popover-caption-container', 'popover-content', 'popover-disable-autoplay', 'popover-overlay-color', 'popover-overlay-opacity', 'popover-prevent-scroll', 'popover-show-on-load', 'poster', 'preload', 'quality-control', 'quality-max', 'quality-min', 'resumable', 'rounded-player', 'seo', 'settings-control', 'silent-autoplay', 'transparent-letterbox', 'video-quality', 'volume', 'volume-control', 'wistia-popover'];

// Optional attributes used by Wistia developers.
var optionalPrivateAttributes = ['big-play-button-border-radius', 'control-bar-border-radius', 'embed-host', 'hls', 'page-url', 'player-border-radius', 'player-force', 'stats-url', 'swatch', 'unique-id', 'use-web-component'];
var defaultEmbedOptions = {
  audioDescriptionControl: false,
  autoplay: false,
  bigPlayButton: true,
  bigPlayButtonBorderRadius: undefined,
  controlBarBorderRadius: undefined,
  controlsVisibleOnLoad: true,
  copyLinkAndThumbnail: true,
  currentTime: 0,
  doNotTrack: false,
  endVideoBehavior: 'default',
  fullscreenControl: true,
  hls: true,
  playBarControl: true,
  playerBorderRadius: undefined,
  playerColor: '636155',
  playPauseControl: true,
  playPauseNotifier: true,
  playbackRateControl: true,
  playlistLinks: '',
  playlistLoop: false,
  popoverAnimateThumbnail: false,
  popoverAnimation: 'slide',
  popoverBorderColor: 'ffffff',
  popoverBorderRadius: 0,
  popoverBorderWidth: 0,
  popoverBoxShadow: true,
  popoverCaption: '',
  popoverCaptionContainer: '',
  popoverContent: undefined,
  popoverDisableAutoplay: false,
  popoverOverlayColor: '000000',
  popoverOverlayOpacity: 0.5,
  popoverPreventScroll: false,
  popoverShowOnLoad: false,
  poster: '',
  qualityControl: true,
  qualityMax: undefined,
  qualityMin: undefined,
  resumable: 'auto',
  roundedPlayer: undefined,
  seo: true,
  settingsControl: true,
  silentAutoplay: false,
  state: 'beforeplay',
  statsUrl: null,
  transparentLetterbox: false,
  volume: 1,
  volumeControl: true,
  wistiaPopover: false
};

/**
 * Returns the swatch url for a given mediaId
 * @param {string} mediaId
 * @param {string} embedHost
 * @returns {string}
 */
var getSwatchUrl = function getSwatchUrl(mediaId) {
  var embedHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var fastHost = (0,_utilities_hosts_js__WEBPACK_IMPORTED_MODULE_12__/* .cdnFastWistiaComHost */ .CX)(embedHost);
  return "https://".concat(fastHost, "/embed/medias/").concat(mediaId, "/swatch");
};
var _api = /*#__PURE__*/new WeakMap();
var _eventListeners = /*#__PURE__*/new WeakMap();
var _fullscreenState = /*#__PURE__*/new WeakMap();
var _impl = /*#__PURE__*/new WeakMap();
var _internals = /*#__PURE__*/new WeakMap();
var _jsonLdId = /*#__PURE__*/new WeakMap();
var _judyContext = /*#__PURE__*/new WeakMap();
var _logger = /*#__PURE__*/new WeakMap();
var _oldEngine = /*#__PURE__*/new WeakMap();
var _playerData = /*#__PURE__*/new WeakMap();
var _playerType = /*#__PURE__*/new WeakMap();
var _removeEventListeners = /*#__PURE__*/new WeakMap();
var _cachedRemapTime = /*#__PURE__*/new WeakMap();
var _hasElementConnectedToDOM = /*#__PURE__*/new WeakMap();
var _paddingTop = /*#__PURE__*/new WeakMap();
var _playPending = /*#__PURE__*/new WeakMap();
var _preactRoot = /*#__PURE__*/new WeakMap();
var _preloadThumbnailRoot = /*#__PURE__*/new WeakMap();
var _publicApiScript = /*#__PURE__*/new WeakMap();
var _resizeObserver = /*#__PURE__*/new WeakMap();
var _WistiaPlayer_brand = /*#__PURE__*/new WeakSet();
var _handleAfterReplace = /*#__PURE__*/new WeakMap();
var _handleBeforeReplace = /*#__PURE__*/new WeakMap();
var _handlePreloadThumbnailClick = /*#__PURE__*/new WeakMap();
var WistiaPlayer = /*#__PURE__*/function (_HTMLElement) {
  /**
   * Represents one embedded Wistia media player.
   * @constructor
   */
  function WistiaPlayer() {
    var _this2;
    _classCallCheck(this, WistiaPlayer);
    _this2 = _callSuper(this, WistiaPlayer);
    _classPrivateMethodInitSpec(_this2, _WistiaPlayer_brand);
    // can be null when doing document.createElement and referencing an attribute/property
    // before being injected into the dom
    _classPrivateFieldInitSpec(_this2, _api, void 0);
    _classPrivateFieldInitSpec(_this2, _eventListeners, {});
    // private internal fullscreen state of the video. Stored as a property on the web component
    // for easy transfer to another web component during replace if necessary.
    _classPrivateFieldInitSpec(_this2, _fullscreenState, {
      heightBeforeFullscreen: undefined,
      inFullscreen: false,
      nativeFullscreen: false,
      widthBeforeFullscreen: undefined
    });
    _classPrivateFieldInitSpec(_this2, _impl, void 0);
    _classPrivateFieldInitSpec(_this2, _internals, void 0);
    _classPrivateFieldInitSpec(_this2, _jsonLdId, void 0);
    _classPrivateFieldInitSpec(_this2, _judyContext, null);
    _classPrivateFieldInitSpec(_this2, _logger, void 0);
    // private value used during the replace flow to pass along the old engine.
    _classPrivateFieldInitSpec(_this2, _oldEngine, void 0);
    _classPrivateFieldInitSpec(_this2, _playerData, void 0);
    _classPrivateFieldInitSpec(_this2, _playerType, void 0);
    _classPrivateFieldInitSpec(_this2, _removeEventListeners, []);
    _classPrivateFieldInitSpec(_this2, _cachedRemapTime, undefined);
    _classPrivateFieldInitSpec(_this2, _hasElementConnectedToDOM, false);
    _classPrivateFieldInitSpec(_this2, _paddingTop, '0px');
    _classPrivateFieldInitSpec(_this2, _playPending, false);
    _classPrivateFieldInitSpec(_this2, _preactRoot, null);
    _classPrivateFieldInitSpec(_this2, _preloadThumbnailRoot, null);
    _classPrivateFieldInitSpec(_this2, _publicApiScript, (0,_utilities_runScript_js__WEBPACK_IMPORTED_MODULE_14__/* .runScript */ .j)("".concat((0,_utilities_url_js__WEBPACK_IMPORTED_MODULE_18__/* .proto */ .ff)(), "//").concat((0,_appHostname_js__WEBPACK_IMPORTED_MODULE_26__/* .appHostname */ .N)('fast'), "/assets/external/publicApi.js")));
    _classPrivateFieldInitSpec(_this2, _resizeObserver, null);
    _classPrivateFieldInitSpec(_this2, _handleAfterReplace, function () {
      _assertClassBrand(_WistiaPlayer_brand, _this2, _maybeInjectJsonLd).call(_this2);
      (0,_utilities_embedOptionStore_ts__WEBPACK_IMPORTED_MODULE_9__/* .setEmbedOptionStore */ .gY)("__".concat(_this2.uniqueId, "_dom_options__"), _classPrivateFieldGet(_playerData, _this2).embedOptions);
    });
    _classPrivateFieldInitSpec(_this2, _handleBeforeReplace, function (event) {
      /**
       * Since the public API reads embed options assigned to the DOM container,
       * we need to make sure the DOM container ID/uniqueId is updated before
       * the public API starts gathering options in replaceWithMediaDataQueuable.
       */
      _this2.mediaId = event.detail.mediaId;
      _this2.uniqueId = _assertClassBrand(_WistiaPlayer_brand, _this2, _generateUniqueId).call(_this2, event.detail.mediaId);

      // When we replace, we're getting new media data, and the function we return
      // is based of the current media data.
      _classPrivateFieldSet(_cachedRemapTime, _this2, undefined);
    });
    _classPrivateFieldInitSpec(_this2, _handlePreloadThumbnailClick, function () {
      if (_classPrivateFieldGet(_playerType, _this2) !== 'carouselHardWall' && _classPrivateFieldGet(_playerType, _this2) !== 'notplayable' && _classPrivateFieldGet(_playerType, _this2) !== 'passwordprotected') {
        _classPrivateFieldSet(_playPending, _this2, true);
      }
      _assertClassBrand(_WistiaPlayer_brand, _this2, _renderPreloadThumbnail).call(_this2);
    });
    if ('attachInternals' in HTMLElement.prototype && 'states' in ElementInternals.prototype) {
      _classPrivateFieldSet(_internals, _this2, _this2.attachInternals());
      _classPrivateFieldGet(_internals, _this2).states.add('--initializing');
    }
    _this2.attachShadow({
      mode: 'open'
    });
    _this2.dispatchEvent(new CustomEvent('load-start'));
    _this2.paddingTop = getComputedStyle(_this2).paddingTop;

    // Set up a prefixed logger
    _classPrivateFieldSet(_logger, _this2, _utilities_wlog_js__WEBPACK_IMPORTED_MODULE_22__/* .wlog */ .ct.getPrefixedFunctions('WistiaPlayer'));
    _classPrivateFieldSet(_playerData, _this2, new _utilities_PlayerDataHandler_ts__WEBPACK_IMPORTED_MODULE_5__/* .PlayerDataHandler */ .I());

    // Wistia global setup if this is the first time we've seen a Wistia player
    if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.wistia === undefined) {
      _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.wistia = Date.now();
    }
    return _this2;
  }

  // --------------------------------------------------
  // Public properties
  // --------------------------------------------------

  /**
   * Return an array of the attributes that we want to observe for changes.
   * If one of these attributes changes, the attributeChangedCallback will be called.
   * @returns {string[]}
   */
  _inherits(WistiaPlayer, _HTMLElement);
  return _createClass(WistiaPlayer, [{
    key: "_fullscreenState",
    get:
    /**
     * @returns {FullscreenState} private fullscreenState of the video.
     */
    function get() {
      return _classPrivateFieldGet(_fullscreenState, this);
    }

    /**
     * @param {FullscreenState} state private fullscreenState of the video.
     */,
    set: function set(state) {
      _classPrivateFieldSet(_fullscreenState, this, state);
    }

    /**
     * @deprecated The method should not be used
     * @returns {object | null |undefined }  private - old engine being transferred.
     */
  }, {
    key: "_oldEngine",
    get: function get() {
      return _classPrivateFieldGet(_oldEngine, this);
    }

    /**
     * @deprecated The method should not be used
     * @param {object | null | undefined} engine private old engine to be transferred of the video.
     */,
    set: function set(engine) {
      _classPrivateFieldSet(_oldEngine, this, engine);
    }

    /**
     * Returns the aspect ratio (width / height) of the originally uploaded video or given aspect ratio.
     * @returns {number}
     */
  }, {
    key: "aspect",
    get: function get() {
      var _ref, _ref2, _classPrivateFieldGet2, _classPrivateFieldGet3;
      var fallbackAspect = !Number.isNaN(this.offsetWidth / this.offsetHeight) && Number.isFinite(this.offsetWidth / this.offsetHeight) ? this.offsetWidth / this.offsetHeight : _utilities_constants_ts__WEBPACK_IMPORTED_MODULE_27__/* .DEFAULT_ASPECT */ .R;
      return (_ref = (_ref2 = (_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.aspect()) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : this.embedOptions.aspect) !== null && _ref2 !== void 0 ? _ref2 : _assertClassBrand(_WistiaPlayer_brand, this, _getValueFromAttribute).call(this, 'aspect')) !== null && _ref !== void 0 ? _ref : fallbackAspect;
    }

    /**
     * Sets the aspect ratio (width / height) of the video.
     * @param {number} newAspect
     * @returns {void}
     */,
    set: function set(newAspect) {
      var _classPrivateFieldGet4;
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'aspect', newAspect);

      // By re-setting width to the same value, we trigger the aspect ratio to be recalculated.
      (_classPrivateFieldGet4 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.width((0,_utilities_elem_js__WEBPACK_IMPORTED_MODULE_10__/* .elemWidth */ .cG)(this), {
        constrain: true
      });
    }

    /**
     * Returns whether the Audio Description control in the control bar is enabled.
     * @returns {boolean}
     */
  }, {
    key: "audioDescriptionControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'audioDescriptionControl');
    }

    /**
     * Enable or disable the Audio Description control in the control bar. Note: Even if set to `true`, this control will
     * only appear if the video has an Audio Description track.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet5;
      (_classPrivateFieldGet5 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.audioDescriptionControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'audioDescriptionControl', shouldDisplay);
    }

    /**
     * sets the authorization property to be used for authorized asset delivery
     * @param {Authorization}
     * @returns {void}
     */
  }, {
    key: "authorization",
    set: function set(auth) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'authorization', auth);
    }

    /**
     * Returns if the player should attempt to autoplay as soon as it's ready.
     * @returns {boolean}
     */
  }, {
    key: "autoplay",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'autoplay');
    }

    /**
     * Sets the attribute to enable/disable autoplay.
     * @param {boolean} shouldSetAutoplay
     * @returns {void}
     */,
    set: function set(shouldSetAutoplay) {
      // This method is called a second time when the attribute value (string | null)
      // is set on the element. Checking for typeof boolean here prevents us from
      // saving that second value to the api.
      if (typeof shouldSetAutoplay !== 'boolean') {
        return;
      }
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'autoplay', shouldSetAutoplay);

      // Sync the element's autoplay attribute with this property
      // This matches the behavior of the native <video> element
      if (shouldSetAutoplay) {
        this.setAttribute('autoplay', '');
      } else {
        this.removeAttribute('autoplay');
      }
    }

    /**
     * Returns if the big play button control will appear in the center of the video before play.
     * @returns {boolean}
     */
  }, {
    key: "bigPlayButton",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'bigPlayButton');
    }

    /**
     * Sets if the big play button control will appear in the center of the video before play.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet6;
      (_classPrivateFieldGet6 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.bigPlayButtonEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'bigPlayButton', shouldDisplay);
    }

    /**
     * Returns the border radius of the big play button.
     * @returns {number}
     */
  }, {
    key: "bigPlayButtonBorderRadius",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'bigPlayButtonBorderRadius');
    }

    /**
     * Sets the border radius of the big play button.
     * @param {number} radius
     * @returns {void}
     */,
    set: function set(radius) {
      var _classPrivateFieldGet7;
      (_classPrivateFieldGet7 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.setBigPlayButtonBorderRadius(Number(radius));
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'bigPlayButtonBorderRadius', radius);
    }
  }, {
    key: "branding",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'branding');
    }

    /**
     * This can only be used to enable the wistia logo for players
     * that might not otherwise require it. We don't want to introduce
     * the ability to easily hide the wistia logo for players where it's required.
     */,
    set: function set(value) {
      if (value === 'true' || value === true) {
        _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'branding', true);
      }
    }

    /**
     * Returns a new static normalized TimeRanges object that represents the ranges of the media resource,
     * if any, that the user agent has buffered at the moment the buffered property is accessed.
     * @returns {TimeRanges}
     */
  }, {
    key: "buffered",
    get: function get() {
      var _classPrivateFieldGet8, _classPrivateFieldGet9;
      return (_classPrivateFieldGet8 = (_classPrivateFieldGet9 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet9 === void 0 ? void 0 : _classPrivateFieldGet9.getStandardBuffered()) !== null && _classPrivateFieldGet8 !== void 0 ? _classPrivateFieldGet8 : {};
    }

    /**
     * Returns the border radius of the control bar.
     * @returns {number}
     */
  }, {
    key: "controlBarBorderRadius",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'controlBarBorderRadius');
    }

    /**
     * Sets the border radius of the control bar.
     * @param {number} radius
     * @returns {void}
     */,
    set: function set(radius) {
      var _classPrivateFieldGet10;
      (_classPrivateFieldGet10 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet10 === void 0 ? void 0 : _classPrivateFieldGet10.setControlBarBorderRadius(Number(radius));
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'controlBarBorderRadius', radius);
    }

    /**
     * Getter. Returns all defined controls.
     * @returns {ControlInstances} returns object of defined controls. Please note this may return an
     * empty object if not controls have yet been defined.
     */
  }, {
    key: "controls",
    get: function get() {
      if (_classPrivateFieldGet(_impl, this)) {
        // We don't want customers modifying this object (adding/deleting what is already here).
        // But they may need to interact/modify the existing ones, so we only use `seal`.
        return Object.seal(_objectSpread({}, _classPrivateFieldGet(_impl, this).controls));
      }
      return {};
    }

    /**
     * Returns whether or not to hide the controls on load.
     * @returns {boolean}
     */
  }, {
    key: "controlsVisibleOnLoad",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'controlsVisibleOnLoad');
    }

    /**
     * Sets whether or not to hide the controls on load.
     * @param {boolean} shouldHide
     * @returns {void}
     */,
    set: function set(shouldHide) {
      var _classPrivateFieldGet11;
      (_classPrivateFieldGet11 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet11 === void 0 ? void 0 : _classPrivateFieldGet11.renderUI();
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'controlsVisibleOnLoad', shouldHide);
    }

    /**
     * Returns whether or the copy link and thumbnail option from the context menu
     * is available.
     * @returns {boolean}
     */
  }, {
    key: "copyLinkAndThumbnail",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'copyLinkAndThumbnail');
    }

    /**
     * Enable or disable the copy link and thumbnail option from the context menu.
     * @param {boolean} enabled
     * @returns {void}
     */,
    set: function set(enabled) {
      var prevVal = this.copyLinkAndThumbnail;
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'copyLinkAndThumbnail', enabled);
      if (prevVal !== enabled) {
        this.dispatchEvent(new CustomEvent('copy-link-and-thumbnail-change', {
          detail: {
            copyLinkAndThumbnail: enabled
          }
        }));
      }
    }

    /**
     * Returns the current time of the video as a decimal in seconds.
     * @returns {number}
     */
  }, {
    key: "currentTime",
    get: function get() {
      var _ref3, _ref4, _classPrivateFieldGet12;
      return (_ref3 = (_ref4 = (_classPrivateFieldGet12 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet12 === void 0 ? void 0 : _classPrivateFieldGet12.time()) !== null && _ref4 !== void 0 ? _ref4 : this.embedOptions.currentTime) !== null && _ref3 !== void 0 ? _ref3 : 0;
    }

    /**
     * Sets the current time of the video as a decimal in seconds.
     * @param {number} newTime
     * @returns {void}
     */,
    set: function set(newTime) {
      var _classPrivateFieldGet13;
      void ((_classPrivateFieldGet13 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet13 === void 0 ? void 0 : _classPrivateFieldGet13.time(newTime));
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'currentTime', newTime);
    }

    /**
     * @returns {object} helpful object for debugging
     */
  }, {
    key: "debug",
    get: function get() {
      var _classPrivateFieldGet14;
      return {
        impl: _classPrivateFieldGet(_impl, this),
        engine: (_classPrivateFieldGet14 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet14 === void 0 ? void 0 : _classPrivateFieldGet14.engine
      };
    }

    /**
     * Returns the public api instance.
     * @deprecated this is a deprecated method and should not be used.
     * @returns {PublicApi | null}
     */
  }, {
    key: "deprecatedApiDoNotUse",
    get: function get() {
      return _classPrivateFieldGet(_api, this);
    }

    /**
     * Returns the status of the do not track embed option that controls whether the player
     * sends tracking pings.
     * @returns {boolean}
     */
  }, {
    key: "doNotTrack",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'doNotTrack');
    }

    /**
     * When present the player will not send tracking events for stats.
     * Note that this must be set at the time of embed to have any impact.
     * @param {boolean} dontTrack
     * @returns {void}
     */,
    set: function set(dontTrack) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'doNotTrack', dontTrack);
    }

    /**
     * Returns the duration of the video in seconds.
     * @returns {number}
     */
  }, {
    key: "duration",
    get: function get() {
      var _classPrivateFieldGet15, _classPrivateFieldGet16;
      return (_classPrivateFieldGet15 = (_classPrivateFieldGet16 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet16 === void 0 ? void 0 : _classPrivateFieldGet16.duration()) !== null && _classPrivateFieldGet15 !== void 0 ? _classPrivateFieldGet15 : 0;
    }

    /**
     * Returns the email associated with this viewing session.
     * If no email is associated, it will return undefined.
     * NOTE: This attribute will impact the entire page and is not scoped to the player.
     * @returns {string | undefined}
     */
  }, {
    key: "email",
    get: function get() {
      var _ref5, _ref6, _extractEmailFromPara, _classPrivateGetter2;
      return (_ref5 = (_ref6 = (_extractEmailFromPara = (0,_utilities_extractEmailFromParams_ts__WEBPACK_IMPORTED_MODULE_11__/* .extractEmailFromParams */ .i)(_classPrivateGetter(_WistiaPlayer_brand, this, _get_pageUrl))) !== null && _extractEmailFromPara !== void 0 ? _extractEmailFromPara : (_classPrivateGetter2 = (0,_utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_19__/* .getWistiaLocalStorage */ .y1)()[_classPrivateGetter(_WistiaPlayer_brand, this, _get_pageUrl)]) === null || _classPrivateGetter2 === void 0 ? void 0 : _classPrivateGetter2.trackEmail) !== null && _ref6 !== void 0 ? _ref6 : this.embedOptions.email) !== null && _ref5 !== void 0 ? _ref5 : undefined;
    }

    /**
     * Associates the view of this media with the given email value.
     * This email will appear in stats for the video.
     * NOTE: This attribute will impact the entire page and is not scoped to the player.
     * @param {string} newEmail
     * @returns {void}
     */,
    set: function set(newEmail) {
      if (this.email === newEmail) {
        return;
      }
      _assertClassBrand(_WistiaPlayer_brand, this, _updateEmail).call(this, newEmail);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'email', newEmail);
    }

    /**
     * Returns the overridding embed host for the player.
     * Internal use only.
     * @returns {string | null | undefined}
     */
  }, {
    key: "embedHost",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'embedHost');
    }

    /**
     * Sets the overridding embed host for the player.
     * Internal use only.
     * @param {string} newEmbedHost
     * @returns {void}
     */,
    set: function set(newEmbedHost) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'embedHost', newEmbedHost);
    }

    /**
     * Returns all the embed options being set on the WistiaPlayer from attributes and mediaData json
     * @returns {EmbedOptions }
     */
  }, {
    key: "embedOptions",
    get: function get() {
      return _classPrivateFieldGet(_playerData, this).embedOptions;
    }

    /**
     * Returns whether the video has ended playback.
     * @returns {boolean}
     */
  }, {
    key: "ended",
    get: function get() {
      var _classPrivateFieldGet17;
      return ((_classPrivateFieldGet17 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet17 === void 0 ? void 0 : _classPrivateFieldGet17.state()) === 'ended';
    }

    /**
     * Returns the current end video behavior value
     * @returns {string}
     */
  }, {
    key: "endVideoBehavior",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'endVideoBehavior');
    }

    /**
     * Sets the behavior for what the video should do when it ends.
     * @param {'default' | 'loop' | 'reset'} behavior
     * @returns {void}
     */,
    set: function set(behavior) {
      // loop is a slightly odd option, as it's set as an attribute directly on the
      // underlying <video /> element. So we must do more than just change the _impl._attrs
      // for it to be updated.
      if (behavior === 'loop') {
        var _classPrivateFieldGet18;
        (_classPrivateFieldGet18 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet18 === void 0 ? void 0 : _classPrivateFieldGet18.addLoopBehavior();
      } else {
        var _classPrivateFieldGet19;
        (_classPrivateFieldGet19 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet19 === void 0 ? void 0 : _classPrivateFieldGet19.removeLoopBehavior();
      }
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'endVideoBehavior', behavior);
    }

    /**
     * Returns the embed's event key if it exists.
     * @returns {string | undefined}
     */
  }, {
    key: "eventKey",
    get: function get() {
      var _classPrivateFieldGet20;
      return (_classPrivateFieldGet20 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet20 === void 0 ? void 0 : _classPrivateFieldGet20.eventKey();
    }

    /**
     * Returns if the fullscreen button control will appear in the control bar.
     * @returns {boolean}
     */
  }, {
    key: "fullscreenControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'fullscreenControl');
    }

    /**
     * Sets if the fullscreen button control is enabled in the control bar.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet21;
      (_classPrivateFieldGet21 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet21 === void 0 ? void 0 : _classPrivateFieldGet21.fullscreenControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'fullscreenControl', shouldDisplay);
    }

    /**
     * Returns if the video should use HLS playback.
     * Internal only.
     * @returns {boolean}
     */
  }, {
    key: "hls",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'hls');
    }

    /**
     * Sets if the video should use HLS playback.
     * Internal only.
     * @param {boolean} shouldUseHls
     * @returns {void}
     */,
    set: function set(shouldUseHls) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'hls', shouldUseHls);
    }

    /**
     * Returns whether the video is currently in fullscreen
     * @returns {boolean}
     */
  }, {
    key: "inFullscreen",
    get: function get() {
      var _classPrivateFieldGet22, _classPrivateFieldGet23;
      return (_classPrivateFieldGet22 = (_classPrivateFieldGet23 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet23 === void 0 ? void 0 : _classPrivateFieldGet23.inFullscreen()) !== null && _classPrivateFieldGet22 !== void 0 ? _classPrivateFieldGet22 : false;
    }
  }, {
    key: "inputContext",
    get: function get() {
      var _classPrivateFieldGet24;
      return (_classPrivateFieldGet24 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet24 === void 0 ? void 0 : _classPrivateFieldGet24.getInputContext();
    }

    /**
     * Returns whether instantHLS is enabled for the video.
     * @returns {boolean}
     */
  }, {
    key: "instantHls",
    get: function get() {
      var _classPrivateFieldGet25, _classPrivateFieldGet26;
      return (_classPrivateFieldGet25 = (_classPrivateFieldGet26 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet26 === void 0 ? void 0 : _classPrivateFieldGet26.isInstantHls()) !== null && _classPrivateFieldGet25 !== void 0 ? _classPrivateFieldGet25 : false;
    }
  }, {
    key: "language",
    get: function get() {
      var _assertClassBrand$cal;
      if (_classPrivateFieldGet(_playerData, this).mediaData.ietfLanguageTag == null) {
        return _assertClassBrand(_WistiaPlayer_brand, this, _defaultLocalization).call(this);
      }
      return (_assertClassBrand$cal = _assertClassBrand(_WistiaPlayer_brand, this, _findLocalizationByLanguage).call(this, _classPrivateFieldGet(_playerData, this).mediaData.ietfLanguageTag)) !== null && _assertClassBrand$cal !== void 0 ? _assertClassBrand$cal : _assertClassBrand(_WistiaPlayer_brand, this, _defaultLocalization).call(this);
    },
    set: function set(language) {
      var localization = _assertClassBrand(_WistiaPlayer_brand, this, _findLocalizationByLanguage).call(this, language);
      if (localization == null) {
        // eslint-disable-next-line no-console
        console.error("Language ".concat(language, " not found. Available languages for ").concat(this.mediaId, ": ").concat(JSON.stringify(this.languages.map(function (loc) {
          return loc.iso6392LanguageCode;
        }))));
        return;
      }
      var replaceOptions = {
        language: localization.iso6392LanguageCode
      };
      var wasPlaying = this.state === 'playing';
      var wasBeforePlay = this.state === 'beforeplay';
      var time = this.currentTime;
      if (!wasBeforePlay) {
        replaceOptions.time = time;
      }
      if (wasPlaying) {
        replaceOptions.autoPlay = true;
      }
      void this.replaceWithMedia(localization.hashedId, replaceOptions);
    }
  }, {
    key: "languages",
    get: function get() {
      var _classPrivateFieldGet27;
      var result = (_classPrivateFieldGet27 = _classPrivateFieldGet(_playerData, this).mediaData.localizations) !== null && _classPrivateFieldGet27 !== void 0 ? _classPrivateFieldGet27 : [];
      if (result.length === 0) {
        result.push(_assertClassBrand(_WistiaPlayer_brand, this, _defaultLocalization).call(this));
      }
      return result;
    }

    /**
     * Returns all the mediaData set on the WistiaPlayer
     * @returns {MediaData }
     */
  }, {
    key: "mediaData",
    get: function get() {
      return _classPrivateFieldGet(_playerData, this).mediaData;
    }

    /**
     * Returns the hashed id of the media.
     * @returns {string}
     */
  }, {
    key: "mediaId",
    get: function get() {
      var _this$getAttribute;
      return (_this$getAttribute = this.getAttribute('media-id')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : '';
    }

    /**
     * Replaces the content of the current video with the video identified by the given mediaId.
     * @param {string} newMediaId
     * @returns {void}
     */,
    set: function set(newMediaId) {
      var prevMediaId = this.mediaId;
      if (prevMediaId === newMediaId) {
        return;
      }
      _classPrivateFieldGet(_logger, this).info('set mediaId', newMediaId);

      // Sync the element's media-id attribute with this property
      // This is the most important and only required attribute on the element
      // and won't change frequently, so it shouldn't cost too much to keep in sync
      this.setAttribute('media-id', newMediaId);
    }

    /**
     * Returns if player is currently muted
     * @returns {boolean}
     */
  }, {
    key: "muted",
    get: function get() {
      var _ref7, _classPrivateFieldGet28, _classPrivateFieldGet29;
      return (_ref7 = (_classPrivateFieldGet28 = (_classPrivateFieldGet29 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet29 === void 0 ? void 0 : _classPrivateFieldGet29.isMuted()) !== null && _classPrivateFieldGet28 !== void 0 ? _classPrivateFieldGet28 : this.embedOptions.muted) !== null && _ref7 !== void 0 ? _ref7 : false;
    }

    /**
     * Change player muted state
     * @param {boolean} shouldMute
     */,
    set: function set(shouldMute) {
      if (_classPrivateFieldGet(_impl, this)) {
        if (shouldMute) {
          void _classPrivateFieldGet(_impl, this).mute();
        } else {
          void _classPrivateFieldGet(_impl, this).unmute();
        }
      }
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'muted', shouldMute);
    }

    /**
     * Returns the name of the media as it is in the Wistia application.
     * Returns undefined until media data is loaded.
     * @returns {string | undefined}
     */
  }, {
    key: "name",
    get: function get() {
      var _ref8, _classPrivateFieldGet30, _classPrivateFieldGet31, _classPrivateFieldGet32;
      return (_ref8 = (_classPrivateFieldGet30 = _classPrivateFieldGet(_playerData, this).mediaData.name) !== null && _classPrivateFieldGet30 !== void 0 ? _classPrivateFieldGet30 : (_classPrivateFieldGet31 = _classPrivateFieldGet(_api, this)) === null || _classPrivateFieldGet31 === void 0 ? void 0 : (_classPrivateFieldGet32 = _classPrivateFieldGet31._mediaData) === null || _classPrivateFieldGet32 === void 0 ? void 0 : _classPrivateFieldGet32.name) !== null && _ref8 !== void 0 ? _ref8 : undefined;
    }
  }, {
    key: "paddingTop",
    get: function get() {
      return _classPrivateFieldGet(_paddingTop, this);
    },
    set: function set(paddingTop) {
      _classPrivateFieldSet(_paddingTop, this, paddingTop);
    }

    /**
     * Returns a boolean that indicates whether the video is paused.
     * @returns {boolean}
     */
  }, {
    key: "paused",
    get: function get() {
      var _classPrivateFieldGet33;
      return ((_classPrivateFieldGet33 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet33 === void 0 ? void 0 : _classPrivateFieldGet33.state()) === 'paused';
    }

    /**
     * Returns the percent of the video that has been watched as a decimal between 0 and 1.
     * @returns {number}
     */
  }, {
    key: "percentWatched",
    get: function get() {
      var _classPrivateFieldGet34, _classPrivateFieldGet35;
      return (_classPrivateFieldGet34 = (_classPrivateFieldGet35 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet35 === void 0 ? void 0 : _classPrivateFieldGet35.percentWatched()) !== null && _classPrivateFieldGet34 !== void 0 ? _classPrivateFieldGet34 : 0;
    }

    /**
     * Returns the playback rate of the video.
     * @returns {number}
     */
  }, {
    key: "playbackRate",
    get: function get() {
      var _ref9, _classPrivateFieldGet36, _classPrivateFieldGet37;
      return (_ref9 = (_classPrivateFieldGet36 = (_classPrivateFieldGet37 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet37 === void 0 ? void 0 : _classPrivateFieldGet37.playbackRate()) !== null && _classPrivateFieldGet36 !== void 0 ? _classPrivateFieldGet36 : this.embedOptions.playbackRate) !== null && _ref9 !== void 0 ? _ref9 : 1;
    }

    /**
     * Set the playback rate of the video.
     * @param {number} rate
     * @returns {void}
     */,
    set: function set(rate) {
      var _classPrivateFieldGet38;
      (_classPrivateFieldGet38 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet38 === void 0 ? void 0 : _classPrivateFieldGet38.playbackRate(rate);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playbackRate', rate);
    }

    /**
     * If set to true, the playback rate control will appear in the setting control.
     * @returns {boolean}
     */
  }, {
    key: "playbackRateControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playbackRateControl');
    }

    /**
     * enable or disable the playback rate control in the settings control.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet39;
      (_classPrivateFieldGet39 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet39 === void 0 ? void 0 : _classPrivateFieldGet39.playbackRateControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playbackRateControl', shouldDisplay);
    }

    /**
     * Returns if the playbar - which includes the playhead, current time, and scrubbing functionality - will be available.
     * @returns {boolean}
     */
  }, {
    key: "playBarControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playBarControl');
    }

    /**
     * Sets if the playbar - which includes the playhead, current time, and scrubbing functionality - will be available.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet40;
      (_classPrivateFieldGet40 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet40 === void 0 ? void 0 : _classPrivateFieldGet40.playbarControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playBarControl', shouldDisplay);
    }

    /**
     * Returns the border radius of the player.
     * @returns {number}
     */
  }, {
    key: "playerBorderRadius",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playerBorderRadius');
    }

    /**
     * Sets the border radius of the player.
     * @param {number} radius
     * @returns {void}
     */,
    set: function set(radius) {
      var _classPrivateFieldGet41;
      (_classPrivateFieldGet41 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet41 === void 0 ? void 0 : _classPrivateFieldGet41.setPlayerBorderRadius(Number(radius));
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playerBorderRadius', radius);
    }

    /**
     * Returns the base color of the player.
     * @returns {string}
     */
  }, {
    key: "playerColor",
    get: function get() {
      var _this$playerColorGrad;
      if ((_this$playerColorGrad = this.playerColorGradient) !== null && _this$playerColorGrad !== void 0 && _this$playerColorGrad.on) {
        var _getGradientColor;
        return (_getGradientColor = (0,_utilities_gradients_ts__WEBPACK_IMPORTED_MODULE_1__/* .getGradientColor */ .yz)(this.playerColorGradient)) !== null && _getGradientColor !== void 0 ? _getGradientColor : _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playerColor');
      }
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playerColor');
    }

    /**
     * Changes the base color of the player.
     * Expects a hexadecimal rgb string like "ff0000" (red), "000000" (black), "ffffff" (white), or "0000ff" (blue).
     * @param {string} newColor
     * @returns {void}
     */,
    set: function set(newColor) {
      var _classPrivateFieldGet42;
      (_classPrivateFieldGet42 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet42 === void 0 ? void 0 : _classPrivateFieldGet42.playerColor(newColor);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playerColor', newColor);
    }

    /**
     * Returns the player color gradient object.
     * @returns {Gradient | undefined}
     */
  }, {
    key: "playerColorGradient",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playerColorGradient');
    }

    /**
     * Sets the player color gradient object.
     * @param {Gradient} gradient
     * @returns {void}
     */,
    set: function set(gradient) {
      var _classPrivateFieldGet43;
      if (!(0,_types_gradient_ts__WEBPACK_IMPORTED_MODULE_28__/* .isGradient */ .b)(gradient)) {
        throw new Error('playerColorGradient must be a valid gradient object');
      }
      (_classPrivateFieldGet43 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet43 === void 0 ? void 0 : _classPrivateFieldGet43.playerColorGradient(gradient);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playerColorGradient', gradient);
    }

    /**
     * Returns the overridding player.
     * Internal use only.
     * @returns {Players | undefined}
     */
  }, {
    key: "playerForce",
    get: function get() {
      var _ref10;
      return (_ref10 = this.getAttribute('player-force')) !== null && _ref10 !== void 0 ? _ref10 : undefined;
    }

    /**
     * Sets the overridding player.
     * Internal use only.
     * @param {string} newPlayer
     * @returns {void}
     */,
    set: function set(newPlayer) {
      _classPrivateFieldGet(_logger, this).info('set playerForce', newPlayer);
      this.setAttribute('player-force', newPlayer);
    }

    /**
     * Returns the strategy for associating specially crafted links on a page with a video, turning them into a playlist.
     * auto: For each video on the page, look for links after the video, until we come to another Wistia video.
     * manual: Given each link element, look at its 'container' option to determine which video it should connect to.
     * "container": For all embed links in a container whose id matches this given string, connect them to this specific video.
     * @returns {'auto' | 'manual' | string}
     */
  }, {
    key: "playlistLinks",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playlistLinks');
    }

    /**
     * Sets the strategy for associating specially crafted links on a page with a video, turning them into a playlist.
     * @param {'auto' | 'manual' | string} newStrategy
     * @returns {void}
     */,
    set: function set(newStrategy) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playlistLinks', newStrategy);
    }

    /**
     * When present or set to true and this video has a playlist, it will loop back to
     * the first video and replay it once the last video has finished.
     * @returns {boolean}
     */
  }, {
    key: "playlistLoop",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playlistLoop');
    }

    /**
     * When present or set to true and this video has a playlist, it will loop back to
     * the first video and replay it once the last video has finished.
     * @param {boolean} shouldLoop
     * @returns {void}
     */,
    set: function set(shouldLoop) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playlistLoop', shouldLoop);
    }

    /**
     * If set to true, the small play button control will be available.
     * @returns {boolean}
     */
  }, {
    key: "playPauseControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playPauseControl');
    }

    /**
     * If set to true, the small play button control will be available.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet44;
      (_classPrivateFieldGet44 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet44 === void 0 ? void 0 : _classPrivateFieldGet44.playPauseControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playPauseControl', shouldDisplay);
    }

    /**
     * By default, pausing a video will display a brief animation of the pause symbol
     * and resuming the video will display an animation of the play symbol.
     * Setting this embed option to false will remove those animations.
     * @returns {boolean}
     */
  }, {
    key: "playPauseNotifier",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'playPauseNotifier');
    }

    /**
     * By default, pausing a video will display a brief animation of the pause symbol
     * and resuming the video will display an animation of the play symbol.
     * Setting this embed option to false will remove those animations.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet45;
      (_classPrivateFieldGet45 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet45 === void 0 ? void 0 : _classPrivateFieldGet45.playPauseNotifierEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'playPauseNotifier', shouldDisplay);
    }

    /**
     * Getter. Returns all defined plugins.
     * @returns {PluginInstances} returns object of defined plugins. Please note this may return an
     * empty object if not plugins have yet been defined.
     */
  }, {
    key: "plugins",
    get: function get() {
      if (_classPrivateFieldGet(_impl, this)) {
        // We don't want customers modifying this object (adding/deleting what is already here).
        // But they may need to interact/modify the existing ones, so we only use `seal`.
        return Object.seal(_objectSpread({}, _classPrivateFieldGet(_impl, this).plugin));
      }
      return {};
    }

    /**
     * Returns if the play button will expand to cover the thumbnail on hover,
     * while also displaying the duration of the video.
     * @returns {boolean}
     */
  }, {
    key: "popoverAnimateThumbnail",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverAnimateThumbnail');
    }

    /**
     * Sets if the play button will expand to cover the thumbnail on hover,
     * while also displaying the duration of the video.
     * @param {boolean} shouldAnimate
     * @returns {void}
     */,
    set: function set(shouldAnimate) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverAnimateThumbnail', shouldAnimate);
    }

    /**
     * Returns the current state of the video.
     * @returns {PopoverAnimation}
     */
  }, {
    key: "popoverAnimation",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverAnimation');
    }

    /**
     * Sets if the play button will expand to cover the thumbnail on hover,
     * while also displaying the duration of the video.
     * @param {PopoverAnimation} newAnimation
     * @returns {void}
     */,
    set: function set(newAnimation) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverAnimation', newAnimation);
    }

    /**
     * Returns the border color of the popover.
     * @returns {string}
     */
  }, {
    key: "popoverBorderColor",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverBorderColor');
    }

    /**
     * Sets the border color of the popover.
     * @param {string} newColor
     * @returns {void}
     */,
    set: function set(newColor) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverBorderColor', newColor);
    }

    /**
     * Returns the border radius of the popover.
     * @returns {number}
     */
  }, {
    key: "popoverBorderRadius",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverBorderRadius');
    }

    /**
     * Sets the border radius of the popover.
     * @param {number} newRadius
     * @returns {void}
     */,
    set: function set(newRadius) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverBorderRadius', newRadius);
    }

    /**
     * Returns the border width of the popover.
     * @returns {number}
     */
  }, {
    key: "popoverBorderWidth",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverBorderWidth');
    }

    /**
     * Sets the border width of the popover.
     * @param {number} newWidth
     * @returns {void}
     */,
    set: function set(newWidth) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverBorderWidth', newWidth);
    }

    /**
     * Returns if the popover should be displayed with a box shadow.
     * @returns {boolean}
     */
  }, {
    key: "popoverBoxShadow",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverBoxShadow');
    }

    /**
     * Sets if the popover should be displayed with a box shadow.
     * @param {boolean} shouldDisplayBoxShadow
     * @returns {void}
     */,
    set: function set(shouldDisplayBoxShadow) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverBoxShadow', shouldDisplayBoxShadow);
    }

    /**
     * Returns text set to be displayed directly below the popover.
     * @returns {string}
     */
  }, {
    key: "popoverCaption",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverCaption');
    }

    /**
     * Sets text set to be displayed directly below the popover.
     * @param {string} newCaption
     * @returns {void}
     */,
    set: function set(newCaption) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverCaption', newCaption);
    }

    /**
     * Returns the id of the dom element which will be moved beneath the popover.
     * @returns {string}
     */
  }, {
    key: "popoverCaptionContainer",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverCaptionContainer');
    }

    /**
     * Sets the id of the dom element which will be moved beneath the popover.
     * @param {string} newCaptionContainer
     * @returns {void}
     */,
    set: function set(newCaptionContainer) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverCaptionContainer', newCaptionContainer);
    }

    /**
     * Returns how the popover content will render.
     * @returns {PopoverContentSettings | string | undefined}
     */
  }, {
    key: "popoverContent",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverContent');
    }

    /**
     * Sets how the popover content will render.
     * @param {PopoverContentSettings} newContentType
     * @returns {void}
     */,
    set: function set(newContentType) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverContent', newContentType);
    }

    /**
     * Returns if embed should override the behavior for the autoplay option in Customize for
     * a popover specifically, so that launching the popover doesn't also play the video.
     * @returns {boolean}
     */
  }, {
    key: "popoverDisableAutoplay",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverDisableAutoplay');
    }

    /**
     * Sets if embed should override the behavior for the autoplay option in Customize for
     * a popover specifically, so that launching the popover doesn't also play the video.
     * @param {boolean} shouldDisable
     * @returns {void}
     */,
    set: function set(shouldDisable) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverDisableAutoplay', shouldDisable);
    }

    /**
     * Returns the overlay's background color in RGB hexadecimal.
     * @returns {string}
     */
  }, {
    key: "popoverOverlayColor",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverOverlayColor');
    }

    /**
     * Sets the overlay's background color in RGB hexadecimal.
     * @param {string} newColor
     * @returns {void}
     */,
    set: function set(newColor) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverOverlayColor', newColor);
    }

    /**
     * Returns the overlay's opacity. Expects a decimal value between 0 and 1.
     * @returns {number}
     */
  }, {
    key: "popoverOverlayOpacity",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverOverlayOpacity');
    }

    /**
     * Sets the overlay's opacity. Expects a decimal value between 0 and 1.
     * @param {number} newOpacity
     * @returns {void}
     */,
    set: function set(newOpacity) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverOverlayOpacity', newOpacity);
    }

    /**
     * Returns if scrolling should be prevented when the popover is open.
     * @returns {boolean}
     */
  }, {
    key: "popoverPreventScroll",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverPreventScroll');
    }

    /**
     * Sets if scrolling should be prevented when the popover is open.
     * @param {boolean} shouldPreventScroll
     * @returns {void}
     */,
    set: function set(shouldPreventScroll) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverPreventScroll', shouldPreventScroll);
    }

    /**
     * Returns if popover should immediately open as if it was clicked.
     * @returns {boolean}
     */
  }, {
    key: "popoverShowOnLoad",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'popoverShowOnLoad');
    }

    /**
     * Sets if popover should immediately open as if it was clicked.
     * @param {boolean} shouldShow
     * @returns {void}
     */,
    set: function set(shouldShow) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'popoverShowOnLoad', shouldShow);
    }

    /**
     * Overrides the thumbnail image that appears before the video plays.
     * Expects an absolute URL to an image.
     * @returns {string}
     */
  }, {
    key: "poster",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'poster');
    }

    /**
     * Overrides the thumbnail image that appears before the video plays.
     * Expects an absolute URL to an image.
     * @param {string} newUrl
     * @returns {void}
     */,
    set: function set(newUrl) {
      // This method is called a second time when the attribute value
      // is set on the element. Checking for the same value here prevents
      // us from running that second redundant set.
      var prevVal = this.poster;
      if (prevVal === newUrl) {
        return;
      }
      var prevUrl = this.poster;
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'poster', newUrl);

      // Sync the element's autoplay attribute with this property
      // This matches the behavior of the native <video> element
      this.setAttribute('poster', newUrl);
      if (prevUrl !== newUrl) {
        this.dispatchEvent(new CustomEvent('thumbnailchange'));
      }
    }

    /**
     * Returns the preload setting for the player.
     * @returns {string | undefined}
     * undefined is allowed as a return type because there may be situations
     * where the player and/or engine has not loaded and we don't know what
     * preload setting will be used
     */
  }, {
    key: "preload",
    get: function get() {
      var _ref11, _classPrivateFieldGet46, _classPrivateFieldGet47;
      return (_ref11 = (_classPrivateFieldGet46 = (_classPrivateFieldGet47 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet47 === void 0 ? void 0 : _classPrivateFieldGet47.preloadValue()) !== null && _classPrivateFieldGet46 !== void 0 ? _classPrivateFieldGet46 : this.embedOptions.preload) !== null && _ref11 !== void 0 ? _ref11 : undefined;
    }

    /**
     * sets the preload value for the player. Note that changing this option
     * after player initialization has no impact.
     * @param {'auto'| 'metadata' | 'none'} preloadValue
     * @returns {void}
     */,
    set: function set(preloadValue) {
      // This method is called a second time when the attribute value
      // is set on the element. Checking for the same value here prevents
      // us from running that second redundant set.
      var prevVal = this.preload;
      if (prevVal === preloadValue) {
        return;
      }
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'preload', preloadValue);

      // Sync the element's autoplay attribute with this property
      // This matches the behavior of the native <video> element
      this.setAttribute('preload', preloadValue);
    }

    /**
     * If set to true, the quality control will appear in the setting control.
     * @returns {boolean}
     */
  }, {
    key: "qualityControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'qualityControl');
    }

    /**
     * enable or disable the quality control in the settings control.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet48;
      (_classPrivateFieldGet48 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet48 === void 0 ? void 0 : _classPrivateFieldGet48.qualityControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'qualityControl', shouldDisplay);
    }

    /**
     * Return the max quality allowed for the 'Auto' asset in HLS playback
     * @returns {number | undefined}
     */
  }, {
    key: "qualityMax",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'qualityMax');
    }

    /**
     * Set the max quality to be used for "Auto" in the HLS stream.
     * @param {number} quality
     * @returns {void}
     */,
    set: function set(quality) {
      var _classPrivateFieldGet49;
      (_classPrivateFieldGet49 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet49 === void 0 ? void 0 : _classPrivateFieldGet49.qualityMax(quality);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'qualityMax', quality);
    }

    /**
     * Return the min quality allowed for the 'Auto' asset in HLS playback
     * @returns {number}
     */
  }, {
    key: "qualityMin",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'qualityMin');
    }

    /**
     * Set the min quality to be used for "Auto" in the HLS stream.
     * @param {number} quality
     * @returns {void}
     */,
    set: function set(quality) {
      var _classPrivateFieldGet50;
      (_classPrivateFieldGet50 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet50 === void 0 ? void 0 : _classPrivateFieldGet50.qualityMin(quality);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'qualityMin', quality);
    }

    /**
     * Returns the readyState of the inner video HTML element.
     * @returns {number}
     */
  }, {
    key: "readyState",
    get: function get() {
      var _classPrivateFieldGet51, _classPrivateFieldGet52;
      return (_classPrivateFieldGet51 = (_classPrivateFieldGet52 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet52 === void 0 ? void 0 : _classPrivateFieldGet52.getReadyState()) !== null && _classPrivateFieldGet51 !== void 0 ? _classPrivateFieldGet51 : 0;
    }

    /**
     * Returns the current resumable status of the video.
     * @returns {'auto' | boolean}
     */
  }, {
    key: "resumable",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'resumable');
    }

    /**
     * set the resumable state of the video to 'auto' | true | false.
     * note that this can be changed 'beforeplay', however changing the
     * value after play will have no effect
     * @param {'auto' | boolean} resumableState
     * @returns {void}
     */,
    set: function set(resumableState) {
      var _classPrivateFieldGet53;
      (_classPrivateFieldGet53 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet53 === void 0 ? void 0 : _classPrivateFieldGet53.setResumable(resumableState);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'resumable', resumableState);
    }

    /**
     * Returns a value which controls all rounded corners of the player.
     * @returns {number}
     */
  }, {
    key: "roundedPlayer",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'roundedPlayer');
    }

    /**
     * Returns the value which controls all rounded corners of the player.
     * @param {number} radius
     * @returns {void}
     */,
    set: function set(radius) {
      var _classPrivateFieldGet54;
      (_classPrivateFieldGet54 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet54 === void 0 ? void 0 : _classPrivateFieldGet54.setRoundedPlayer(Number(radius));
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'roundedPlayer', radius);
    }

    /**
     * Returns the number of unique seconds that have been watched for the video.
     * This does not include seconds that have been skipped by seeking.
     * @returns {number}
     */
  }, {
    key: "secondsWatched",
    get: function get() {
      var _classPrivateFieldGet55, _classPrivateFieldGet56;
      return (_classPrivateFieldGet55 = (_classPrivateFieldGet56 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet56 === void 0 ? void 0 : _classPrivateFieldGet56.secondsWatched()) !== null && _classPrivateFieldGet55 !== void 0 ? _classPrivateFieldGet55 : 0;
    }

    /**
     * Returns an array where each index represents the number of times the viewer has watched each second of the video.
     * @returns {number[]}
     */
  }, {
    key: "secondsWatchedVector",
    get: function get() {
      var _classPrivateFieldGet57, _classPrivateFieldGet58;
      return (_classPrivateFieldGet57 = (_classPrivateFieldGet58 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet58 === void 0 ? void 0 : _classPrivateFieldGet58.secondsWatchedVector()) !== null && _classPrivateFieldGet57 !== void 0 ? _classPrivateFieldGet57 : [];
    }

    /**
     * Returns whether JSON+LD seo data will be injected.
     * @returns {boolean}
     */
  }, {
    key: "seo",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'seo');
    }

    /**
     * Set whether JSON+LD seo data will be injected.
     * Note that changing this value after embed has no impact as JSON+LD needs
     * to be injected as soon as possible.
     * @param {boolean} val
     * @returns {void}
     */,
    set: function set(val) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'seo', val);
    }

    /**
     * If set to true, the settings control will appear in the control bar.
     * @returns {boolean}
     */
  }, {
    key: "settingsControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'settingsControl');
    }

    /**
     * enable or disable the settings control in the control bar.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet59;
      (_classPrivateFieldGet59 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet59 === void 0 ? void 0 : _classPrivateFieldGet59.settingsControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'settingsControl', shouldDisplay);
    }

    /**
     * This option allows videos to autoplay in a muted state in contexts where normal autoplay
     * is blocked or not supported (e.g. iOS, Safari 11+, Chrome 66+).
     * allow: The video will default to normal autoplay, with silent autoplay as a fallback if needed.
     * false: The video will not autoplay silently.
     * true: The video will default to autoplaying silently.
     * @returns {boolean | 'allow'}
     */
  }, {
    key: "silentAutoplay",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'silentAutoplay');
    }

    /**
     * This option allows videos to autoplay in a muted state in contexts where normal autoplay
     * is blocked or not supported (e.g. iOS, Safari 11+, Chrome 66+).
     * @param {boolean | 'allow'} silentAutoplayValue
     * @returns {void}
     */,
    set: function set(silentAutoplayValue) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'silentAutoplay', silentAutoplayValue);
    }
  }, {
    key: "sourceLanguage",
    get: function get() {
      var _classPrivateFieldGet60;
      return (_classPrivateFieldGet60 = _classPrivateFieldGet(_playerData, this).mediaData.localizations) === null || _classPrivateFieldGet60 === void 0 ? void 0 : _classPrivateFieldGet60.find(function (loc) {
        return loc.sourceLanguage;
      });
    }

    /**
     * Returns the source media id for the player. If a player has different localized versions,
     * each will have a different mediaId, but the same sourceMediaId.
     * @returns {string}
     */
  }, {
    key: "sourceMediaId",
    get: function get() {
      var _this$mediaData$sourc;
      return (_this$mediaData$sourc = this.mediaData.sourceHashedId) !== null && _this$mediaData$sourc !== void 0 ? _this$mediaData$sourc : this.mediaId;
    }

    /**
     * Returns the current state of the video.
     * @returns {PlayerState}
     */
  }, {
    key: "state",
    get: function get() {
      var _classPrivateFieldGet61, _classPrivateFieldGet62;
      return (_classPrivateFieldGet61 = (_classPrivateFieldGet62 = _classPrivateFieldGet(_api, this)) === null || _classPrivateFieldGet62 === void 0 ? void 0 : _classPrivateFieldGet62.state()) !== null && _classPrivateFieldGet61 !== void 0 ? _classPrivateFieldGet61 : defaultEmbedOptions.state;
    }

    /**
     * Returns the stats url for the player.
     * @returns {string | null}
     */
  }, {
    key: "statsUrl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'statsUrl');
    }

    /**
     * Sets the stats url for the player.
     * @param {string} url
     * @returns {void}
     */,
    set: function set(url) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'statsUrl', url);
    }

    /**
     * Returns if a swatch should be shown before the player renders.
     * Internal use only.
     * @returns {boolean | undefined}
     */
  }, {
    key: "swatch",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'swatch');
    }

    /**
     * Sets if a swatch should be shown before the player renders.
     * Internal use only.
     * @param {boolean} shouldShowSwatch
     * @returns {void}
     */,
    set: function set(shouldShowSwatch) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'swatch', shouldShowSwatch);
    }

    /**
     * If present, the background behind the video player will be transparent
     * allowing the page color to show through instead of black.
     * @returns {boolean}
     */
  }, {
    key: "transparentLetterbox",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'transparentLetterbox');
    }

    /**
     * Sets the letterbox to be transparent or not.
     * @param {boolean} shouldSetTransparentLetterbox
     * @returns {void}
     */,
    set: function set(shouldSetTransparentLetterbox) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'transparentLetterbox', shouldSetTransparentLetterbox);
    }

    /**
     * Returns the unique id of this embed
     * Expected format is `wistia-mediaId-index`
     * @returns {string}
     */
  }, {
    key: "uniqueId",
    get: function get() {
      var _this$getAttribute2;
      return (_this$getAttribute2 = this.getAttribute('unique-id')) !== null && _this$getAttribute2 !== void 0 ? _this$getAttribute2 : '';
    }

    /**
     * Sets the unique id of this embed.
     * Expected format is `wistia-mediaId-index`
     * @returns {string}
     */,
    set: function set(id) {
      this.setAttribute('unique-id', id);
    }

    /**
     * Returns if this custom element was created from a legacy translated embed.
     * Internal use only.
     * @returns {boolean}
     */
  }, {
    key: "useWebComponent",
    get: function get() {
      return this.getAttribute('use-web-component') === 'true';
    }

    /**
     * Set if this custom element was created from a legacy translated embed.
     * Internal use only.
     * @param {boolean} val
     * @returns {void}
     */,
    set: function set(val) {
      if (val) {
        this.setAttribute('use-web-component', String(val));
      } else {
        this.removeAttribute('use-web-component');
      }
    }

    /**
     * Returns the current video quality.
     * @returns {number | 'auto'}
     */
  }, {
    key: "videoQuality",
    get: function get() {
      var _ref12, _classPrivateFieldGet63, _classPrivateFieldGet64;
      return (_ref12 = (_classPrivateFieldGet63 = (_classPrivateFieldGet64 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet64 === void 0 ? void 0 : _classPrivateFieldGet64.getVideoQuality()) !== null && _classPrivateFieldGet63 !== void 0 ? _classPrivateFieldGet63 : this.embedOptions.videoQuality) !== null && _ref12 !== void 0 ? _ref12 : 'auto';
    }

    /**
     * Sets the video quality.
     * @param {number | 'auto'} quality
     * @returns {void}
     */,
    set: function set(quality) {
      var _classPrivateFieldGet65;
      (_classPrivateFieldGet65 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet65 === void 0 ? void 0 : _classPrivateFieldGet65.setVideoQuality(quality);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'videoQuality', quality);
    }

    /**
     * Returns the visitor_key of the viewer of this player.
     * @returns {string | null | undefined}
     */
  }, {
    key: "visitorKey",
    get: function get() {
      var _Wistia$visitorKey;
      return (_Wistia$visitorKey = _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.visitorKey) === null || _Wistia$visitorKey === void 0 ? void 0 : _Wistia$visitorKey.value();
    }

    /**
     * Returns the current volume set on the player
     * @returns {number}
     */
  }, {
    key: "volume",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'volume');
    }

    /**
     * Set the current volume set on the player
     * @param {number} level - a Number from 0 - 1
     * @returns {void}
     */,
    set: function set(level) {
      var _classPrivateFieldGet66;
      (_classPrivateFieldGet66 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet66 === void 0 ? void 0 : _classPrivateFieldGet66.volume(level);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'volume', level);
    }

    /**
     * If set to true, the volume control will appear in the control bar.
     * Note that on mobile, we never show a volume control, as the device
     * volume is used.
     * @returns {boolean}
     */
  }, {
    key: "volumeControl",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'volumeControl');
    }

    /**
     * enable or disable the volume control in the control bar.
     * @param {boolean} shouldDisplay
     * @returns {void}
     */,
    set: function set(shouldDisplay) {
      var _classPrivateFieldGet67;
      (_classPrivateFieldGet67 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet67 === void 0 ? void 0 : _classPrivateFieldGet67.volumeControlEnabled(shouldDisplay);
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'volumeControl', shouldDisplay);
    }

    /**
     * Returns if the player embed is a popover.
     * @returns {boolean}
     */
  }, {
    key: "wistiaPopover",
    get: function get() {
      return _assertClassBrand(_WistiaPlayer_brand, this, _getSyncedEmbedOption).call(this, 'wistiaPopover');
    }

    /**
     * Sets if the player embed is a popover.
     * @param {boolean} shouldBePopover
     * @returns {void}
     */,
    set: function set(shouldBePopover) {
      _assertClassBrand(_WistiaPlayer_brand, this, _setSyncedEmbedOption).call(this, 'wistiaPopover', shouldBePopover);
    }
  }, {
    key: "addEventListener",
    value:
    // --------------------------------------------------
    // Public api methods
    // --------------------------------------------------

    /**
     * Adds an event listener to the player.
     * @param {string} eventName - The name of the event to listen for.
     * @param {EventListenerOrEventListenerObject} listener - The function to call when the event occurs.
     * @param {AddEventListenerOptions | boolean} options - Additional options for the event listener.
     */
    function addEventListener(eventName, listener, options) {
      if (!Array.isArray(_classPrivateFieldGet(_eventListeners, this)[eventName])) {
        _classPrivateFieldGet(_eventListeners, this)[eventName] = [];
      }
      _classPrivateFieldGet(_eventListeners, this)[eventName].push({
        listener: listener,
        options: options
      });
      _superPropGet(WistiaPlayer, "addEventListener", this, 3)([eventName, listener, options]);
    }

    /**
     * Attempt to enter fullscreen mode.
     * @returns {Promise<void>}
     */
  }, {
    key: "cancelFullscreen",
    value: (function () {
      var _cancelFullscreen = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _classPrivateFieldGet68,
          _this3 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", (_classPrivateFieldGet68 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet68 === void 0 ? void 0 : _classPrivateFieldGet68.cancelFullscreen().then(function () {
                _this3._fullscreenState.heightBeforeFullscreen = undefined;
                _this3._fullscreenState.widthBeforeFullscreen = undefined;
              }));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function cancelFullscreen() {
        return _cancelFullscreen.apply(this, arguments);
      }
      return cancelFullscreen;
    }()
    /**
     * Creates an overlay with the specified name and options.
     * @param {string} name - The name of the overlay.
     * @param {OverlayOptions} options - The options for the overlay.
     * @returns A promise that resolves when the overlay is created successfully, or rejects with an error if the overlay cannot be defined at this time.
     */
    )
  }, {
    key: "createOverlay",
    value: (function () {
      var _createOverlay = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name, options) {
        var _classPrivateFieldGet69;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!((_classPrivateFieldGet69 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet69 !== void 0 && _classPrivateFieldGet69.defineOverlay)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", _classPrivateFieldGet(_impl, this).defineOverlay(name, options));
            case 2:
              return _context2.abrupt("return", Promise.reject(new Error("overlay ".concat(name, " cannot be defined at this time"))));
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function createOverlay(_x, _x2) {
        return _createOverlay.apply(this, arguments);
      }
      return createOverlay;
    }()
    /**
     * Defines a plugin on the player.
     * @param {T extends keyof PluginConfigs} name name of the plugin to define
     * @param {PluginConfigs[T]} options object of plugin options related to the specific plugin
     * @returns {Promise<PluginInstances<T>>} returns a Promise that resolves with the defined plugin
     */
    )
  }, {
    key: "definePlugin",
    value: (function () {
      var _definePlugin = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name, options) {
        var _this4 = this;
        var addPlugin;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              addPlugin = /*#__PURE__*/function () {
                var _ref13 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  var _classPrivateFieldGet70, _classPrivateFieldGet71;
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        return _context3.abrupt("return", (_classPrivateFieldGet70 = (_classPrivateFieldGet71 = _classPrivateFieldGet(_api, _this4)) === null || _classPrivateFieldGet71 === void 0 ? void 0 : _classPrivateFieldGet71.addPlugin(name, options)) !== null && _classPrivateFieldGet70 !== void 0 ? _classPrivateFieldGet70 : Promise.reject(new Error("plugin ".concat(name, " cannot be defined"))));
                      case 1:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }));
                return function addPlugin() {
                  return _ref13.apply(this, arguments);
                };
              }();
              if (!_classPrivateFieldGet(_api, this)) {
                _context4.next = 3;
                break;
              }
              return _context4.abrupt("return", addPlugin());
            case 3:
              return _context4.abrupt("return", new Promise(function (resolve, reject) {
                _this4.whenApiReady().then(function () {
                  addPlugin().then(function (plugin) {
                    return resolve(plugin);
                  }).catch(function (err) {
                    if (err instanceof Error) {
                      reject(err);
                    } else {
                      reject(new Error('Promise rejected with non-Error value'));
                    }
                  });
                })
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                .catch(function (_error) {});
              }));
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function definePlugin(_x3, _x4) {
        return _definePlugin.apply(this, arguments);
      }
      return definePlugin;
    }()
    /**
     * Deletes an overlay with the specified name.
     * @param {string} name - The name of the overlay to delete.
     * @returns A promise that resolves when the overlay is successfully deleted, or rejects with an error if the overlay cannot be deleted at this time.
     */
    )
  }, {
    key: "deleteOverlay",
    value: (function () {
      var _deleteOverlay = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(name) {
        var _classPrivateFieldGet72;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!((_classPrivateFieldGet72 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet72 !== void 0 && _classPrivateFieldGet72.undefineOverlay)) {
                _context5.next = 2;
                break;
              }
              return _context5.abrupt("return", _classPrivateFieldGet(_impl, this).undefineOverlay(name));
            case 2:
              return _context5.abrupt("return", Promise.reject(new Error("overlay ".concat(name, " cannot be deleted at this time"))));
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function deleteOverlay(_x5) {
        return _deleteOverlay.apply(this, arguments);
      }
      return deleteOverlay;
    }()
    /**
     *
     * @param {string} name the handle name of the control to be disabled
     * @returns {Promise<void>} Promise that resolves when operation is complete
     */
    )
  }, {
    key: "disableControl",
    value: (function () {
      var _disableControl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(name) {
        var _classPrivateFieldGet73;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!((_classPrivateFieldGet73 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet73 !== void 0 && _classPrivateFieldGet73.setControlEnabled)) {
                _context6.next = 2;
                break;
              }
              return _context6.abrupt("return", _classPrivateFieldGet(_impl, this).setControlEnabled(name, false));
            case 2:
              return _context6.abrupt("return", Promise.reject(new Error("control \"".concat(name, "\" cannot be disabled at this time"))));
            case 3:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function disableControl(_x6) {
        return _disableControl.apply(this, arguments);
      }
      return disableControl;
    }()
    /**
     *
     * @param {string} name the handle name of the control to be enabled
     * @returns {Promise<void>} Promise that resolves when operation is complete
     */
    )
  }, {
    key: "enableControl",
    value: (function () {
      var _enableControl = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(name) {
        var _classPrivateFieldGet74;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!((_classPrivateFieldGet74 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet74 !== void 0 && _classPrivateFieldGet74.setControlEnabled)) {
                _context7.next = 2;
                break;
              }
              return _context7.abrupt("return", _classPrivateFieldGet(_impl, this).setControlEnabled(name, true));
            case 2:
              return _context7.abrupt("return", Promise.reject(new Error("control \"".concat(name, "\" cannot be enabled at this time"))));
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function enableControl(_x7) {
        return _enableControl.apply(this, arguments);
      }
      return enableControl;
    }())
  }, {
    key: "enterInputContext",
    value: function () {
      var _enterInputContext = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(context) {
        var _classPrivateFieldGet75,
          _this5 = this;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              if (!((_classPrivateFieldGet75 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet75 !== void 0 && _classPrivateFieldGet75.enterInputContext)) {
                _context8.next = 2;
                break;
              }
              return _context8.abrupt("return", new Promise(function (resolve) {
                var _classPrivateFieldGet76;
                var _handler = function handler(event) {
                  var detail = event.detail;
                  if (detail.context === context) {
                    resolve();
                  }
                  _this5.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .INPUT_CONTEXT_CHANGE_EVENT */ .ve, _handler);
                };
                _this5.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .INPUT_CONTEXT_CHANGE_EVENT */ .ve, _handler);
                (_classPrivateFieldGet76 = _classPrivateFieldGet(_impl, _this5)) === null || _classPrivateFieldGet76 === void 0 ? void 0 : _classPrivateFieldGet76.enterInputContext(context);
              }));
            case 2:
              return _context8.abrupt("return", Promise.reject(new Error("input context of name \"".concat(context, "\" cannot be enabled at this time"))));
            case 3:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function enterInputContext(_x8) {
        return _enterInputContext.apply(this, arguments);
      }
      return enterInputContext;
    }()
  }, {
    key: "exitInputContext",
    value: function () {
      var _exitInputContext = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(context) {
        var _classPrivateFieldGet77;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (!((_classPrivateFieldGet77 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet77 !== void 0 && _classPrivateFieldGet77.exitInputContext)) {
                _context9.next = 2;
                break;
              }
              return _context9.abrupt("return", Promise.resolve(_classPrivateFieldGet(_impl, this).exitInputContext(context)));
            case 2:
              return _context9.abrupt("return", Promise.reject(new Error("control \"".concat(context, "\" cannot be enabled at this time"))));
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function exitInputContext(_x9) {
        return _exitInputContext.apply(this, arguments);
      }
      return exitInputContext;
    }()
    /**
     * Gets initial media data for the video. This method exists purely to make
     * mocking easier in tests and mirrors the import from getInitialMediaData.ts.
     * @param {string} mediaId - The hashed ID of the media
     * @param {GetInitialMediaDataOptions} options - Options for fetching media data
     * @returns {Promise<MediaData | MediaDataServerErrorResponse>} The media data or error response
     */
  }, {
    key: "getInitialMediaData",
    value: (function () {
      var _getInitialMediaData2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(mediaId, options) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", (0,_utilities_getInitialMediaData_ts__WEBPACK_IMPORTED_MODULE_24__/* .getInitialMediaData */ .n)(mediaId, options));
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function getInitialMediaData(_x10, _x11) {
        return _getInitialMediaData2.apply(this, arguments);
      }
      return getInitialMediaData;
    }()
    /**
     * Gets a plugin from the player.
     * @param {T extends keyof PluginInstances} name name of the plugin to retrieve
     * @returns {Promise<PluginInstances[T]>} returns a Promise that resolves with the request plugin
     */
    )
  }, {
    key: "getPlugin",
    value: (function () {
      var _getPlugin = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(name) {
        var _this6 = this;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", new Promise(function (resolve, reject) {
                var _classPrivateFieldGet78;
                if ((_classPrivateFieldGet78 = _classPrivateFieldGet(_api, _this6)) !== null && _classPrivateFieldGet78 !== void 0 && _classPrivateFieldGet78.plugin(name)) {
                  resolve(_classPrivateFieldGet(_api, _this6).plugin(name));
                }
                reject(new Error("plugin ".concat(name, " is not defined")));
              }));
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function getPlugin(_x12) {
        return _getPlugin.apply(this, arguments);
      }
      return getPlugin;
    }()
    /**
     * Returns a function that remaps the time of the video from one language to another.
     * @returns {Function} A function that remaps the time of the video from one
     * language to another with signature
     * (fromLanguage: string, toLanguage: string, fromTime: number) => number
     */
    )
  }, {
    key: "getRemapTime",
    value: (function () {
      var _getRemapTime = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var _classPrivateFieldGet79,
          _this7 = this;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              if (!(_classPrivateFieldGet(_cachedRemapTime, this) != null)) {
                _context12.next = 2;
                break;
              }
              return _context12.abrupt("return", _classPrivateFieldGet(_cachedRemapTime, this));
            case 2:
              if (!(this.languages.length <= 1)) {
                _context12.next = 5;
                break;
              }
              _classPrivateFieldSet(_cachedRemapTime, this, function (_fromLanguage, _toLanguage, fromTime) {
                return fromTime;
              });
              return _context12.abrupt("return", _classPrivateFieldGet(_cachedRemapTime, this));
            case 5:
              if (!((_classPrivateFieldGet79 = _classPrivateFieldGet(_cachedRemapTime, this)) !== null && _classPrivateFieldGet79 !== void 0)) {
                _context12.next = 9;
                break;
              }
              _classPrivateFieldGet79;
              _context12.next = 16;
              break;
            case 9:
              _context12.t0 = _classPrivateFieldSet;
              _context12.t1 = _cachedRemapTime;
              _context12.t2 = this;
              _context12.next = 14;
              return (0,_utilities_dynamicImport_ts__WEBPACK_IMPORTED_MODULE_8__/* .dynamicImport */ .$)('assets/external/timeMapping.js').then(function (_ref14) {
                var remapTime = _ref14.remapTime;
                return function (fromLanguage, toLanguage, fromTime) {
                  var fromTimeInMilliseconds = fromTime * 1000;
                  var fromLocalization = _assertClassBrand(_WistiaPlayer_brand, _this7, _findLocalizationByLanguage).call(_this7, fromLanguage);
                  var sourceLocalization = _this7.sourceLanguage;
                  var toLocalization = _assertClassBrand(_WistiaPlayer_brand, _this7, _findLocalizationByLanguage).call(_this7, toLanguage);
                  if (fromLocalization == null || toLocalization == null || sourceLocalization == null) {
                    return fromTime;
                  }
                  return remapTime(sourceLocalization, fromLocalization, toLocalization, fromTimeInMilliseconds) / 1000;
                };
              });
            case 14:
              _context12.t3 = _context12.sent;
              (0, _context12.t0)(_context12.t1, _context12.t2, _context12.t3);
            case 16:
              return _context12.abrupt("return", _classPrivateFieldGet(_cachedRemapTime, this));
            case 17:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function getRemapTime() {
        return _getRemapTime.apply(this, arguments);
      }
      return getRemapTime;
    }()
    /**
     * Hides the specified overlay.
     * @param {string} name - The name of the overlay to hide.
     * @returns A promise that resolves when the overlay is hidden, or rejects with an error if the overlay cannot be cancelled at this time.
     */
    )
  }, {
    key: "hideOverlay",
    value: (function () {
      var _hideOverlay = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(name) {
        var _classPrivateFieldGet80;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              if (!((_classPrivateFieldGet80 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet80 !== void 0 && _classPrivateFieldGet80.cancelOverlay)) {
                _context13.next = 2;
                break;
              }
              return _context13.abrupt("return", _classPrivateFieldGet(_impl, this).cancelOverlay(name));
            case 2:
              return _context13.abrupt("return", Promise.reject(new Error("overlay ".concat(name, " cannot be cancelled at this time"))));
            case 3:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function hideOverlay(_x13) {
        return _hideOverlay.apply(this, arguments);
      }
      return hideOverlay;
    }()
    /**
     * Hides the popover if this is a popover embed.
     * @returns {Promise<void>}
     */
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    )
  }, {
    key: "hidePopover",
    value: (function () {
      var _hidePopover = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var _this8 = this;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.abrupt("return", new Promise(function (resolve, reject) {
                var _classPrivateFieldGet81;
                if ((_classPrivateFieldGet81 = _classPrivateFieldGet(_api, _this8)) !== null && _classPrivateFieldGet81 !== void 0 && _classPrivateFieldGet81.popover) {
                  _classPrivateFieldGet(_api, _this8).popover.hide();
                  resolve();
                }
                reject(new Error("Popover cannot be accessed"));
              }));
            case 1:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));
      function hidePopover() {
        return _hidePopover.apply(this, arguments);
      }
      return hidePopover;
    }()
    /**
     * Pauses the video.
     * If this is called and the video's state is "playing,"
     * it's expected that it will change to "paused."
     * @returns {Promise<void>}
     */
    )
  }, {
    key: "pause",
    value: (function () {
      var _pause = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var _classPrivateFieldGet82;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              return _context15.abrupt("return", (_classPrivateFieldGet82 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet82 === void 0 ? void 0 : _classPrivateFieldGet82.pause());
            case 1:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function pause() {
        return _pause.apply(this, arguments);
      }
      return pause;
    }()
    /**
     * Plays the video.
     * If this is called, it is expected that the state will change to "playing."
     * @returns {Promise<void>}
     */
    )
  }, {
    key: "play",
    value: (function () {
      var _play = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var _classPrivateFieldGet83;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              return _context16.abrupt("return", (_classPrivateFieldGet83 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet83 === void 0 ? void 0 : _classPrivateFieldGet83.play());
            case 1:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function play() {
        return _play.apply(this, arguments);
      }
      return play;
    }()
    /**
     * @param {string} name name of the controls
     * @returns {Promise<void?>}
     */
    )
  }, {
    key: "releaseControls",
    value: (function () {
      var _releaseControls = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(name) {
        var _classPrivateFieldGet84;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              return _context17.abrupt("return", (_classPrivateFieldGet84 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet84 === void 0 ? void 0 : _classPrivateFieldGet84.releaseControls(name));
            case 1:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function releaseControls(_x14) {
        return _releaseControls.apply(this, arguments);
      }
      return releaseControls;
    }()
    /**
     * Removes all event listeners from the player
     * @returns {void}
     */
    )
  }, {
    key: "removeAllEventListeners",
    value: function removeAllEventListeners() {
      var _this9 = this;
      Object.entries(_classPrivateFieldGet(_eventListeners, this)).forEach(function (_ref15) {
        var _ref16 = _slicedToArray(_ref15, 2),
          type = _ref16[0],
          listeners = _ref16[1];
        listeners.forEach(function (_ref17) {
          var listener = _ref17.listener,
            options = _ref17.options;
          _this9.removeEventListener(type, listener, options);
        });
      });
    }

    /**
     * Removes an event listener from the player.
     * @param {string} type - The type of event to remove.
     * @param {EventListenerOrEventListenerObject} listener - The function to remove.
     * @param {EventListenerOptions | boolean} options
     * @returns {void}
     */
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener, options) {
      var listeners = _classPrivateFieldGet(_eventListeners, this)[type];
      if (!Array.isArray(listeners)) return;

      // Find index of the matching listener+options
      var index = listeners.findIndex(function (entry) {
        return entry.listener === listener && JSON.stringify(entry.options) === JSON.stringify(options);
      });
      if (index !== -1) {
        // Remove event listener from DOM
        _superPropGet(WistiaPlayer, "removeEventListener", this, 3)([type, listener, options]);

        // Remove it from the tracked list
        listeners.splice(index, 1);

        // If no listeners remain for this type, clean up the key
        if (listeners.length === 0) {
          _classPrivateFieldGet(_eventListeners, this)[type] = [];
        }
      }
    }

    /**
     * Replaces the media and then resolves when the new media is ready to play
     * @param {string} mediaId
     * @param {EmbedOptions} options
     * @returns {Promise<void>}
     */
  }, {
    key: "replaceWithMedia",
    value: (function () {
      var _replaceWithMedia = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(mediaId) {
        var _this10 = this;
        var options,
          _args18 = arguments;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              options = _args18.length > 1 && _args18[1] !== undefined ? _args18[1] : {};
              return _context18.abrupt("return", new Promise(function (resolve, reject) {
                var _classPrivateFieldGet85;
                if (!_classPrivateFieldGet(_api, _this10)) {
                  reject(new Error('api not ready to replace'));
                }
                (0,_utilities_injectJsonLd_js__WEBPACK_IMPORTED_MODULE_23__/* .removeInjectedJsonLd */ .Z)(_classPrivateFieldGet(_jsonLdId, _this10));
                var _handleAfterReplace2 = function handleAfterReplace() {
                  _this10.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .AFTER_REPLACE_EVENT */ .$1, _handleAfterReplace2);
                  resolve();
                };
                _this10.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .AFTER_REPLACE_EVENT */ .$1, _handleAfterReplace2);
                (_classPrivateFieldGet85 = _classPrivateFieldGet(_api, _this10)) === null || _classPrivateFieldGet85 === void 0 ? void 0 : _classPrivateFieldGet85.replaceWith(mediaId, options);
              }));
            case 2:
            case "end":
              return _context18.stop();
          }
        }, _callee18);
      }));
      function replaceWithMedia(_x15) {
        return _replaceWithMedia.apply(this, arguments);
      }
      return replaceWithMedia;
    }()
    /**
     * @param {string} name name of the controls
     * @returns {Promise<void?>}
     */
    )
  }, {
    key: "requestControls",
    value: (function () {
      var _requestControls = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(name) {
        var _classPrivateFieldGet86;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              return _context19.abrupt("return", (_classPrivateFieldGet86 = _classPrivateFieldGet(_impl, this)) === null || _classPrivateFieldGet86 === void 0 ? void 0 : _classPrivateFieldGet86.requestControls(name));
            case 1:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function requestControls(_x16) {
        return _requestControls.apply(this, arguments);
      }
      return requestControls;
    }()
    /**
     * Attempt to enter fullscreen mode.
     * @returns {Promise<void>}
     */
    )
  }, {
    key: "requestFullscreen",
    value: (function () {
      var _requestFullscreen = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        var _classPrivateFieldGet87;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              if (!((_classPrivateFieldGet87 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet87 !== void 0 && _classPrivateFieldGet87.requestFullscreen)) {
                _context20.next = 2;
                break;
              }
              return _context20.abrupt("return", _classPrivateFieldGet(_impl, this).requestFullscreen());
            case 2:
              return _context20.abrupt("return", Promise.reject(new Error('Fullscreen cannot be accessed')));
            case 3:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function requestFullscreen() {
        return _requestFullscreen.apply(this, arguments);
      }
      return requestFullscreen;
    }()
    /**
     * Shows an overlay with the specified name.
     * @param {string} name - The name of the overlay to show.
     * @returns A promise that resolves when the overlay is shown, or rejects with an error if the overlay cannot be requested at this time.
     */
    )
  }, {
    key: "showOverlay",
    value: (function () {
      var _showOverlay = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(name) {
        var _classPrivateFieldGet88;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              if (!((_classPrivateFieldGet88 = _classPrivateFieldGet(_impl, this)) !== null && _classPrivateFieldGet88 !== void 0 && _classPrivateFieldGet88.requestOverlay)) {
                _context21.next = 2;
                break;
              }
              return _context21.abrupt("return", _classPrivateFieldGet(_impl, this).requestOverlay(name));
            case 2:
              return _context21.abrupt("return", Promise.reject(new Error("overlay ".concat(name, " cannot be requested at this time"))));
            case 3:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function showOverlay(_x17) {
        return _showOverlay.apply(this, arguments);
      }
      return showOverlay;
    }()
    /**
     * Shows the popover if this is a popover embed.
     * @returns {Promise<void>}
     */
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    )
  }, {
    key: "showPopover",
    value: (function () {
      var _showPopover = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        var _this11 = this;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              return _context22.abrupt("return", new Promise(function (resolve, reject) {
                var _classPrivateFieldGet89;
                if ((_classPrivateFieldGet89 = _classPrivateFieldGet(_api, _this11)) !== null && _classPrivateFieldGet89 !== void 0 && _classPrivateFieldGet89.popover) {
                  _classPrivateFieldGet(_api, _this11).popover.show();
                  resolve();
                }
                reject(new Error("Popover cannot be accessed"));
              }));
            case 1:
            case "end":
              return _context22.stop();
          }
        }, _callee22);
      }));
      function showPopover() {
        return _showPopover.apply(this, arguments);
      }
      return showPopover;
    }())
  }, {
    key: "whenApiReady",
    value: function () {
      var _whenApiReady = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        var _this12 = this;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              return _context23.abrupt("return", new Promise(function (resolve) {
                if (_classPrivateFieldGet(_api, _this12)) {
                  _classPrivateFieldGet(_api, _this12).ready(function () {
                    resolve();
                  });
                }
                var _handler2 = function handler() {
                  _this12.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .API_READY_EVENT */ .c5, _handler2);
                  resolve();
                };
                _this12.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .API_READY_EVENT */ .c5, _handler2);
              }));
            case 1:
            case "end":
              return _context23.stop();
          }
        }, _callee23);
      }));
      function whenApiReady() {
        return _whenApiReady.apply(this, arguments);
      }
      return whenApiReady;
    }()
  }, {
    key: "whenControlMounted",
    value: function () {
      var _whenControlMounted = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24(handle) {
        var _classPrivateFieldGet90;
        var control;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return this.whenApiReady();
            case 2:
              _context24.next = 4;
              return (_classPrivateFieldGet90 = _classPrivateFieldGet(_api, this)) === null || _classPrivateFieldGet90 === void 0 ? void 0 : _classPrivateFieldGet90.whenControlMounted(handle);
            case 4:
              control = _context24.sent;
              if (control) {
                _context24.next = 7;
                break;
              }
              throw new Error('Control not found');
            case 7:
              return _context24.abrupt("return", control);
            case 8:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function whenControlMounted(_x18) {
        return _whenControlMounted.apply(this, arguments);
      }
      return whenControlMounted;
    }() // --------------------------------------------------
    // Custom element lifecycle methods
    // --------------------------------------------------
    /**
     * Called when an observed attribute has been added, removed, updated, or replaced.
     * Also called for initial values when an element is created by the parser, or upgraded.
     * Note: only attributes listed in the observedAttributes property will receive this callback.
     * @param {string} name - The name of the attribute that changed.
     * @param {string} oldValue - The previous value of the attribute, or null if it was added for the first time.
     * @param {string} newValue - The new value of the attribute, or null if it was removed.
     * @returns {void}
     */
  }, {
    key: "attributeChangedCallback",
    value: function attributeChangedCallback(name, oldValue, newValue) {
      // We need this to make sure we don't needlessly call api methods during initial component setup
      if (!_classPrivateFieldGet(_hasElementConnectedToDOM, this)) {
        return;
      }
      if (oldValue === newValue) {
        return;
      }

      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (oldValue === null && newValue === '') {
        return;
      }

      // If the attribute string is equal to 'true' or 'false', go ahead and assume we'd
      // like the boolean value instead of the string
      var finalValue = newValue;
      switch (newValue) {
        case 'true':
          finalValue = true;
          break;
        case 'false':
          finalValue = false;
          break;
        default:
          break;
      }

      // Attribute names must match their corresponding property names (kebab-case -> camelCase)
      // So the player-color attribute maps to the playerColor property
      this[(0,_utilities_camelCaseToKebabCase_ts__WEBPACK_IMPORTED_MODULE_30__/* .kebabCaseToCamelCase */ .b)(name)] = finalValue;
    }
  }, {
    key: "connectedCallback",
    value: function connectedCallback() {
      var _window$wistiaOptions,
        _this13 = this,
        _this$embedHost;
      if (_classPrivateFieldGet(_hasElementConnectedToDOM, this)) {
        return;
      }
      _classPrivateFieldSet(_hasElementConnectedToDOM, this, true);
      var mediaId = this.getAttribute('media-id');
      if (mediaId == null) {
        (0,_utilities_simpleMetrics_js__WEBPACK_IMPORTED_MODULE_16__/* .countMetric */ .WO)('player/failure/init-failed');
        throw new Error('media-id attribute is required');
      }

      // Allows for all bulk setting of embed options and mediaData
      window.wistiaOptions = (_window$wistiaOptions = window.wistiaOptions) !== null && _window$wistiaOptions !== void 0 ? _window$wistiaOptions : {};
      var opts = (0,_utilities_wistiaOptions_ts__WEBPACK_IMPORTED_MODULE_20__/* .getWistiaOptions */ .C)(this.mediaId);
      _classPrivateFieldGet(_playerData, this).setWistiaWindowEmbedOptionSource(opts);

      // Add the media id to the logger now that we have it
      _classPrivateFieldSet(_logger, this, _utilities_wlog_js__WEBPACK_IMPORTED_MODULE_22__/* .wlog */ .ct.getPrefixedFunctions("WistiaPlayer ".concat(mediaId)));
      _classPrivateFieldSet(_judyContext, this, (0,_utilities_judy_js__WEBPACK_IMPORTED_MODULE_13__/* .buildContext */ .gC)());

      // If the player was created from our React wrapper component, send a tracking event
      if (this.getAttribute('react') === 'true') {
        (0,_utilities_simpleMetrics_js__WEBPACK_IMPORTED_MODULE_16__/* .countMetric */ .WO)('player/initembed.react');
      }
      _assertClassBrand(_WistiaPlayer_brand, this, _setupEventListeners).call(this);
      _classPrivateFieldGet(_logger, this).info('initialize embed');
      if (!this.useWebComponent) {
        (0,_utilities_wistiaQueue_ts__WEBPACK_IMPORTED_MODULE_21__/* .maybeStartWistiaQueue */ .z)();
      }

      // Generate a unique id for this embed in case there are
      // multiple embeds with the same hashed id on the page
      this.uniqueId = _assertClassBrand(_WistiaPlayer_brand, this, _generateUniqueId).call(this, mediaId);
      _assertClassBrand(_WistiaPlayer_brand, this, _maybeSetupEmbedOptionsFromIframe).call(this);

      // Sometimes if an attribute is set on the player, we want to do something immediately
      _assertClassBrand(_WistiaPlayer_brand, this, _runMethodsFromAttributes).call(this);

      // Gather any attributes set on the element and save them so the public api can use them
      _assertClassBrand(_WistiaPlayer_brand, this, _saveInitialAttributesFromDomOptions).call(this);
      var resizeCallback = function resizeCallback() {
        _assertClassBrand(_WistiaPlayer_brand, _this13, _renderPreloadThumbnail).call(_this13);
      };
      _classPrivateFieldSet(_resizeObserver, this, new ResizeObserver(resizeCallback));
      _classPrivateFieldGet(_resizeObserver, this).observe(this);
      var optsForFetch = {
        deferFetchingToCarousel: _assertClassBrand(_WistiaPlayer_brand, this, _deferMediaDataFetchingToCarouselEmbed).call(this),
        embedHost: (_this$embedHost = this.embedHost) !== null && _this$embedHost !== void 0 ? _this$embedHost : '',
        overrideMediaLanguage: this.embedOptions.language
      };
      this.getInitialMediaData(mediaId, optsForFetch).then(function (mediaDataOrError) {
        var _mediaData$hashedId;
        if ((0,_utilities_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_31__/* .isMediaDataError */ .V)(mediaDataOrError)) {
          return;
        }
        var mediaData = mediaDataOrError;
        _this13.mediaId = (_mediaData$hashedId = mediaData.hashedId) !== null && _mediaData$hashedId !== void 0 ? _mediaData$hashedId : '';
        _classPrivateFieldGet(_playerData, _this13).setMediaDataSource(mediaData);
        _this13.dispatchEvent(new CustomEvent(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .LOADED_MEDIA_DATA_EVENT */ .rO, {
          detail: {
            mediaData: _classPrivateFieldGet(_playerData, _this13).mediaData
          }
        }));
        _assertClassBrand(_WistiaPlayer_brand, _this13, _initPlayerEmbed).call(_this13, {
          container: _this13.uniqueId,
          mediaData: _classPrivateFieldGet(_playerData, _this13).mediaData
        });
      }).catch(function (error) {
        (0,_utilities_simpleMetrics_js__WEBPACK_IMPORTED_MODULE_16__/* .countMetric */ .WO)('player/failure/init-failed');
        throw new Error(error.message);
      });

      // Add our responsive embed template to the shadow DOM
      if (this.shadowRoot) {
        // Create slot for user content, to allow styling of children of
        // <wistia-player> via css that's external to the shadow dom.
        // This is mainly for popover embeds.
        if (this.wistiaPopover && this.popoverContent === 'link') {
          var slot = document.createElement('slot');
          slot.name = "".concat(this.uniqueId, "-popover-link");
          this.shadowRoot.appendChild(slot);
        }

        // Render the embed template as soon as we can
        _classPrivateFieldSet(_preactRoot, this, document.createElement('div'));
        _assertClassBrand(_WistiaPlayer_brand, this, _renderEmbedTemplate).call(this);
        this.shadowRoot.insertBefore(_classPrivateFieldGet(_preactRoot, this), this.shadowRoot.firstChild);
      }
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      var _classPrivateFieldGet91, _classPrivateFieldGet92, _this$shadowRoot;
      _classPrivateFieldGet(_removeEventListeners, this).forEach(function (removeListener) {
        return removeListener();
      });
      this.removeAllEventListeners();
      _classPrivateFieldSet(_eventListeners, this, {});
      (0,_utilities_injectJsonLd_js__WEBPACK_IMPORTED_MODULE_23__/* .removeInjectedJsonLd */ .Z)(_classPrivateFieldGet(_jsonLdId, this));
      (0,_utilities_remote_data_cache_ts__WEBPACK_IMPORTED_MODULE_25__/* .uncacheMediaData */ .s3)(this.mediaId);
      (_classPrivateFieldGet91 = _classPrivateFieldGet(_resizeObserver, this)) === null || _classPrivateFieldGet91 === void 0 ? void 0 : _classPrivateFieldGet91.disconnect();
      _classPrivateFieldSet(_resizeObserver, this, null);
      (0,_utilities_embedOptionStore_ts__WEBPACK_IMPORTED_MODULE_9__/* .removeEmbedOptionStore */ .iU)("__".concat(this.uniqueId, "_dom_options__"));
      (_classPrivateFieldGet92 = _classPrivateFieldGet(_api, this)) === null || _classPrivateFieldGet92 === void 0 ? void 0 : _classPrivateFieldGet92.remove();
      _classPrivateFieldSet(_api, this, null);
      (_this$shadowRoot = this.shadowRoot) === null || _this$shadowRoot === void 0 ? void 0 : _this$shadowRoot.replaceChildren();
      _classPrivateFieldSet(_preactRoot, this, null);
      _classPrivateFieldSet(_preloadThumbnailRoot, this, null);
      _classPrivateFieldSet(_hasElementConnectedToDOM, this, false);
    }

    // --------------------------------------------------
    // Private methods
    // --------------------------------------------------
  }], [{
    key: "observedAttributes",
    get: function get() {
      return [].concat(requiredAttributes, optionalPublicAttributes, optionalPrivateAttributes);
    }
  }]);
}(/*#__PURE__*/_wrapNativeSuper(HTMLElement));

/**
 * Takes an image url (swatch) and returns the image metadata
 * @param {string} url
 * @returns {Promise<HTMLImageElement>}
 */
_WistiaPlayer = WistiaPlayer;
function _get_pageUrl(_this) {
  var _this$getAttribute3;
  return (_this$getAttribute3 = _this.getAttribute('page-url')) !== null && _this$getAttribute3 !== void 0 ? _this$getAttribute3 : (0,_utilities_inferPageUrl_ts__WEBPACK_IMPORTED_MODULE_32__/* .inferPageUrl */ .H)();
}
function _defaultLocalization() {
  return {
    alpha3Bibliographic: 'eng',
    alpha3Terminologic: 'eng',
    duration: 0,
    hashedId: this.mediaId,
    ietfLanguageTag: 'eng',
    iso6392LanguageCode: 'eng',
    name: 'English',
    nativeName: 'English',
    sourceLanguage: true,
    timeMappings: []
  };
}
/**
 * Should the player defer fetching media data to a carousel embed?
 * Look for a connected carousel embed that is not inside a playlist embed.
 * If one is found, return true.
 * @returns {boolean}
 */
function _deferMediaDataFetchingToCarouselEmbed() {
  return !!document.querySelector("wistia-carousel[player-dom-id=\"".concat(this.id, "\"]:not([is-inside-playlist-embed=\"true\"][channel-id])"));
}
function _findLocalizationByLanguage(language) {
  var _classPrivateFieldGet93;
  if (language == null) {
    return undefined;
  }
  return (_classPrivateFieldGet93 = _classPrivateFieldGet(_playerData, this).mediaData.localizations) === null || _classPrivateFieldGet93 === void 0 ? void 0 : _classPrivateFieldGet93.find(function (localization) {
    return localization.ietfLanguageTag === language || localization.iso6392LanguageCode === language;
  });
}
/**
 * Generates a unique id for the embed
 * @param {number | string} mediaId - The media id
 * @returns {string}
 */
function _generateUniqueId(mediaId) {
  var prefix = "wistia-".concat(mediaId, "-");
  return (0,_utilities_seqid_js__WEBPACK_IMPORTED_MODULE_15__/* .seqId */ .h)(prefix);
}
/**
 * Returns either the value of an embed option from the public api
 * or the value of an embed option saved on this element.
 *
 * For now, the public api is the source of truth for embed options.
 * However, this will change in the future. We also need a non-public
 * api source for embed options so we can use them before the public
 * api is ready.
 * @param {string} key - Name of the embed option
 * @returns {boolean | number | string | null}
 */
function _getSyncedEmbedOption(key) {
  var _ref20, _ref21;
  // If the public api is ready, use it as the source of truth
  if (_classPrivateFieldGet(_impl, this) && key in _classPrivateFieldGet(_impl, this)._attrs) {
    return _classPrivateFieldGet(_impl, this)._attrs[key];
  }

  // Otherwise check this element's embed config for a value and fallback
  // to the default embed options as a last resort
  return (_ref20 = (_ref21 = this.embedOptions[key]) !== null && _ref21 !== void 0 ? _ref21 : _assertClassBrand(_WistiaPlayer_brand, this, _getValueFromAttribute).call(this, (0,_utilities_camelCaseToKebabCase_ts__WEBPACK_IMPORTED_MODULE_30__/* .camelCaseToKebabCase */ .$)(key))) !== null && _ref20 !== void 0 ? _ref20 : defaultEmbedOptions[key];
}
/**
 * Gets the value of an attribute if it exists, returns null if not
 * @param {string} name - Name of the attribute
 * @returns {boolean | string | null}
 */
function _getValueFromAttribute(name) {
  // If no attribute is present, return null instead of an explicit false
  // so our media data config doesn't get overridden
  if (!this.hasAttribute(name)) {
    return null;
  }
  switch (this.getAttribute(name)) {
    case 'true':
      return true;
    case 'false':
      return false;
    case '':
      // Boolean attributes are set to '' when they are present
      // so we need to convert them to true
      return true;
    case null:
    default:
      return this.getAttribute(name);
  }
}
/**
 * Handles initialization of the player for fresh Aurora embeds
 * @returns {void}
 */
function _initPlayerEmbed(_ref22) {
  var container = _ref22.container,
    mediaData = _ref22.mediaData;
  if (!_classPrivateFieldGet(_hasElementConnectedToDOM, this)) {
    return;
  }
  _classPrivateFieldGet(_playerData, this).updateEmbedOptionOverrides({
    videoFoam: true
  });
  if (mediaData && !(0,_utilities_mediaDataError_ts__WEBPACK_IMPORTED_MODULE_31__/* .isMediaDataError */ .V)(mediaData)) {
    _classPrivateFieldSet(_playerType, this, (0,_utilities_judy_js__WEBPACK_IMPORTED_MODULE_13__/* .choosePlayer */ .$F)(_classPrivateFieldGet(_judyContext, this), _classPrivateFieldGet(_playerData, this).mediaData, _classPrivateFieldGet(_playerData, this).embedOptions));
    _assertClassBrand(_WistiaPlayer_brand, this, _renderPreloadThumbnail).call(this);
    _assertClassBrand(_WistiaPlayer_brand, this, _maybeInjectJsonLd).call(this);
  }
  if ('attachInternals' in HTMLElement.prototype && 'states' in ElementInternals.prototype) {
    var _classPrivateFieldGet94;
    (_classPrivateFieldGet94 = _classPrivateFieldGet(_internals, this)) === null || _classPrivateFieldGet94 === void 0 ? void 0 : _classPrivateFieldGet94.states.delete('--initializing');
  }

  // Create and save the public api instance
  void _assertClassBrand(_WistiaPlayer_brand, this, _initPublicApi).call(this, this.mediaId, {
    container: container,
    mediaData: mediaData
  });
}
/**
 * Initializes the public api instance and sends a ready event
 * @param {number | string} mediaId - The media id
 * @param {EmbedOptions | PublicApiOptions | undefined} options - The public api options
 * @returns {Promise<void>}
 */
function _initPublicApi(_x22, _x23) {
  return _initPublicApi2.apply(this, arguments);
}
function _initPublicApi2() {
  _initPublicApi2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27(mediaId, options) {
    var _this19 = this;
    var embeddedCallback;
    return _regeneratorRuntime().wrap(function _callee27$(_context27) {
      while (1) switch (_context27.prev = _context27.next) {
        case 0:
          _context27.next = 2;
          return _classPrivateFieldGet(_publicApiScript, this);
        case 2:
          if (_wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.PublicApi) {
            _context27.next = 5;
            break;
          }
          (0,_utilities_simpleMetrics_js__WEBPACK_IMPORTED_MODULE_16__/* .countMetric */ .WO)('player/failure/init-failed');
          throw new Error('Wistia.PublicApi is not defined');
        case 5:
          embeddedCallback = function embeddedCallback() {
            var _classPrivateFieldGet101;
            void _assertClassBrand(_WistiaPlayer_brand, _this19, _maybeInitializeMux).call(_this19);
            _assertClassBrand(_WistiaPlayer_brand, _this19, _renderEmbedTemplate).call(_this19);
            (_classPrivateFieldGet101 = _classPrivateFieldGet(_resizeObserver, _this19)) === null || _classPrivateFieldGet101 === void 0 ? void 0 : _classPrivateFieldGet101.disconnect();
            _classPrivateFieldSet(_resizeObserver, _this19, null);
            if (_classPrivateFieldGet(_playPending, _this19)) {
              void _this19.play();
            }
          };
          this.addEventListener('embedded', embeddedCallback);
          _classPrivateFieldGet(_removeEventListeners, this).push(function () {
            _this19.removeEventListener('embedded', embeddedCallback);
          });

          // Initialize!
          _classPrivateFieldSet(_api, this, new _wistia_namespace_ts__WEBPACK_IMPORTED_MODULE_2__/* .Wistia */ .s.PublicApi(mediaId, options));
          this.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .BEFORE_REPLACE_EVENT */ .kY, _classPrivateFieldGet(_handleBeforeReplace, this));
          this.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .AFTER_REPLACE_EVENT */ .$1, _classPrivateFieldGet(_handleAfterReplace, this));
          _classPrivateFieldGet(_removeEventListeners, this).push(function () {
            _this19.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .BEFORE_REPLACE_EVENT */ .kY, _classPrivateFieldGet(_handleBeforeReplace, _this19));
            _this19.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .AFTER_REPLACE_EVENT */ .$1, _classPrivateFieldGet(_handleAfterReplace, _this19));
          });
          _classPrivateFieldGet(_api, this).ready(function () {
            var _classPrivateFieldGet102;
            (_classPrivateFieldGet102 = _classPrivateFieldGet(_preloadThumbnailRoot, _this19)) === null || _classPrivateFieldGet102 === void 0 ? void 0 : _classPrivateFieldGet102.remove();
            _this19.removeEventListener('click', _classPrivateFieldGet(_handlePreloadThumbnailClick, _this19));
            // event for public consumption, exposed on our event types
            _this19.dispatchEvent(new CustomEvent(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .API_READY_EVENT */ .c5, {
              detail: {
                mediaId: mediaId
              }
            }));

            // event for internal consumption, not exposed on our event types
            _this19.dispatchEvent(new CustomEvent(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .INTERNAL_API_ON_FIND_EVENT */ .iP, {
              detail: {
                mediaId: mediaId,
                api: _classPrivateFieldGet(_api, _this19)
              }
            }));

            // Sync embed options from the public api back to the embed config
            if (_classPrivateFieldGet(_impl, _this19)) {
              Object.entries(_classPrivateFieldGet(_impl, _this19)._attrs).forEach(function (_ref28) {
                var _ref29 = _slicedToArray(_ref28, 2),
                  key = _ref29[0],
                  value = _ref29[1];
                _classPrivateFieldGet(_playerData, _this19).updateEmbedOptionOverrides(_defineProperty({}, key, value));
              });
            }

            // Updates our PlayerDataProvider and re-renders the thumbnail with the new embed options
            _assertClassBrand(_WistiaPlayer_brand, _this19, _renderPreloadThumbnail).call(_this19);
          });
        case 13:
        case "end":
          return _context27.stop();
      }
    }, _callee27, this);
  }));
  return _initPublicApi2.apply(this, arguments);
}
/**
 * Returns if this player is a popover embed with a thumbnail.
 * @returns {boolean}
 */
function _isPopoverWithThumbnail() {
  return this.wistiaPopover && (this.popoverContent === undefined || this.popoverContent === '' || this.popoverContent === 'thumbnail');
}
/**
 * Do a coin flip to determine if Mux should be enabled
 * And enable Mux for the player if the coin flip is a win
 * @returns {Promise<void>}
 */
function _maybeInitializeMux() {
  return _maybeInitializeMux2.apply(this, arguments);
}
function _maybeInitializeMux2() {
  _maybeInitializeMux2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
    var _this20 = this;
    var shouldRandomEnableMux, shouldEnableMuxForPlayer, embedType, mux;
    return _regeneratorRuntime().wrap(function _callee28$(_context28) {
      while (1) switch (_context28.prev = _context28.next) {
        case 0:
          if (_classPrivateFieldGet(_api, this)) {
            _context28.next = 2;
            break;
          }
          return _context28.abrupt("return");
        case 2:
          shouldRandomEnableMux = (0,_utilities_coinFlip_ts__WEBPACK_IMPORTED_MODULE_33__/* .didWinCoinFlip */ .k)(_utilities_shouldEnableMux_ts__WEBPACK_IMPORTED_MODULE_34__/* .MUX_PERCENTAGE_TO_ENABLE */ ._);
          shouldEnableMuxForPlayer = (0,_utilities_shouldEnableMux_ts__WEBPACK_IMPORTED_MODULE_34__/* .shouldEnableMux */ .J)(_classPrivateFieldGet(_api, this), shouldRandomEnableMux) && (0,_utilities_trackingConsentApi_js__WEBPACK_IMPORTED_MODULE_17__/* .isVisitorTrackingEnabled */ .D5)();
          embedType = this.useWebComponent ? 'translated-web-component' : 'web-component';
          if (!shouldEnableMuxForPlayer) {
            _context28.next = 11;
            break;
          }
          _context28.next = 8;
          return (0,_utilities_dynamicImport_ts__WEBPACK_IMPORTED_MODULE_8__/* .dynamicImport */ .$)('assets/external/wistia-mux.js');
        case 8:
          mux = _context28.sent;
          mux.init(_classPrivateFieldGet(_api, this), {
            embedType: embedType
          });
          this.addEventListener('visitor-tracking-change', function (event) {
            var isTrackingEnabled = event.detail.isTrackingEnabled;
            if (!isTrackingEnabled) {
              var _classPrivateFieldGet104, _classPrivateFieldGet105;
              (_classPrivateFieldGet104 = _classPrivateFieldGet(_api, _this20)) === null || _classPrivateFieldGet104 === void 0 ? void 0 : (_classPrivateFieldGet105 = _classPrivateFieldGet104.mux) === null || _classPrivateFieldGet105 === void 0 ? void 0 : _classPrivateFieldGet105.destroy();
            }
          });
        case 11:
        case "end":
          return _context28.stop();
      }
    }, _callee28, this);
  }));
  return _maybeInitializeMux2.apply(this, arguments);
}
function _maybeInjectJsonLd() {
  if (this.seo && _classPrivateFieldGet(_playerType, this) !== 'notplayable' && _classPrivateFieldGet(_playerType, this) !== 'passwordprotected' && _classPrivateFieldGet(_playerType, this) !== 'carouselHardWall') {
    _classPrivateFieldSet(_jsonLdId, this, "w-json-ld-".concat(this.uniqueId));
    (0,_utilities_injectJsonLd_js__WEBPACK_IMPORTED_MODULE_23__/* .removeInjectedJsonLd */ .Z)(_classPrivateFieldGet(_jsonLdId, this));
    (0,_utilities_injectJsonLd_js__WEBPACK_IMPORTED_MODULE_23__/* .injectJsonLd */ .g)(_classPrivateFieldGet(_jsonLdId, this), _classPrivateFieldGet(_playerData, this).mediaData, {
      embedOptions: _classPrivateFieldGet(_playerData, this).embedOptions,
      videoHeight: this.offsetHeight,
      videoWidth: this.offsetWidth
    });
  }
}
function _maybeSetupEmbedOptionsFromIframe() {
  if (!window._inWistiaIframe) {
    return;
  }
  // If we're in an iframe, grab the embed options from the iframe URL now
  // instead of waiting for insideIframe.coffee to do it - otherwise we won't
  // have these embed options until after the api has been initialized.
  var searchParams = new URLSearchParams(window.location.search);
  var iframeEmbedOptions = Object.fromEntries(searchParams.entries());
  iframeEmbedOptions.pageTitle = document.title;
  iframeEmbedOptions._inIframe = true;
  _classPrivateFieldGet(_playerData, this).setIframeEmbedOptionSource(iframeEmbedOptions);
}
/**
 * Renders a template for the embed code
 * @returns {HTMLTemplateElement}
 */
function _renderEmbedTemplate() {
  var _this$embedHost2,
    _this14 = this;
  if (!_classPrivateFieldGet(_preactRoot, this)) {
    return;
  }
  var mediaType = _classPrivateFieldGet(_playerData, this).mediaData.mediaType;
  var swatchUrl = getSwatchUrl(this.mediaId, (_this$embedHost2 = this.embedHost) !== null && _this$embedHost2 !== void 0 ? _this$embedHost2 : '');
  var swatchHeight = '100%';
  if (parseFloat(_classPrivateFieldGet(_paddingTop, this)) !== 0 && _classPrivateFieldGet(_paddingTop, this) !== '') {
    swatchHeight = "".concat(parseFloat(_classPrivateFieldGet(_paddingTop, this)), "px");
  }
  var playerBorderRadius = (0,_utilities_roundedPlayerDefaults_ts__WEBPACK_IMPORTED_MODULE_35__/* .getDefaultPlayerBorderRadius */ .JA)({
    playerBorderRadius: this.playerBorderRadius,
    roundedPlayer: this.roundedPlayer
  });
  (0,preact__WEBPACK_IMPORTED_MODULE_0__/* .render */ .XX)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(preact__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */ .FK, null, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("style", null, ":host {\n              display: flex;\n              position: relative;\n              width: 100%;\n              ".concat(mediaType === 'Audio' ? "min-height: 45px;" : '', "\n            }")), _assertClassBrand(_WistiaPlayer_brand, this, _shouldDisplaySwatch).call(this) && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    style: {
      height: swatchHeight,
      left: 0,
      position: 'absolute',
      top: 0,
      width: '100%'
    },
    class: "wistia_swatch"
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    style: {
      height: '100%',
      position: 'relative',
      width: '100%'
    }
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    style: {
      height: '100%',
      left: 0,
      overflow: 'hidden',
      position: 'absolute',
      top: 0,
      width: '100%',
      borderRadius: "".concat(playerBorderRadius, "px")
    }
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("img", {
    src: swatchUrl,
    style: {
      filter: 'blur(5px)',
      height: '100%',
      objectFit: 'contain',
      width: '100%'
    },
    alt: "",
    "aria-hidden": "true"
  })))), (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
    ref: function ref(_ref23) {
      _classPrivateFieldSet(_preloadThumbnailRoot, _this14, _ref23);
    }
  })), _classPrivateFieldGet(_preactRoot, this));
}
/**
 * Renders a progressive thumbnail and a big play button as soon as possible,
 * while the rest of the player is loading.
 * @returns {void}
 */
function _renderPreloadThumbnail() {
  var _this$playerForce;
  if (!_classPrivateFieldGet(_preloadThumbnailRoot, this)) {
    return;
  }
  var _classPrivateFieldGet95 = _classPrivateFieldGet(_playerData, this).mediaData,
    assets = _classPrivateFieldGet95.assets,
    mediaType = _classPrivateFieldGet95.mediaType,
    carouselHardWall = _classPrivateFieldGet95.carouselHardWall;
  var _classPrivateFieldGet96 = _classPrivateFieldGet(_playerData, this).embedOptions,
    autoPlay = _classPrivateFieldGet96.autoPlay,
    plugin = _classPrivateFieldGet96.plugin;

  // Don't render the preload thumbnail if we're going to show a carousel hard wall player.
  if (carouselHardWall) {
    return;
  }
  var thumbnailAssets = (0,_utilities_assets_js__WEBPACK_IMPORTED_MODULE_6__/* .thumbnailAssets */ .Q0)(assets, {});
  var willAutoplay = this.autoplay || autoPlay;
  var hasVideoThumbnail = (plugin === null || plugin === void 0 ? void 0 : plugin.videoThumbnail) !== undefined;
  var shouldRenderThumbnail = (!this.wistiaPopover || _assertClassBrand(_WistiaPlayer_brand, this, _isPopoverWithThumbnail).call(this)) && mediaType !== 'Audio' && thumbnailAssets.length > 0 && !willAutoplay && !hasVideoThumbnail;
  if (!shouldRenderThumbnail) {
    return;
  }
  (0,preact__WEBPACK_IMPORTED_MODULE_0__/* .render */ .XX)((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_hooks_usePlayerData_tsx__WEBPACK_IMPORTED_MODULE_4__/* .PlayerDataProvider */ .z, {
    embedOptions: _classPrivateFieldGet(_playerData, this).embedOptions,
    mediaData: _classPrivateFieldGet(_playerData, this).mediaData
  }, (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_components_PreloadThumbnail_tsx__WEBPACK_IMPORTED_MODULE_3__/* .PreloadThumbnail */ .u, {
    mediaId: this.mediaId,
    playerType: (_this$playerForce = this.playerForce) !== null && _this$playerForce !== void 0 ? _this$playerForce : _classPrivateFieldGet(_playerType, this),
    playerWidth: this.offsetWidth,
    isPlayPending: _classPrivateFieldGet(_playPending, this)
  })), _classPrivateFieldGet(_preloadThumbnailRoot, this));
}
/**
 * Runs any methods associated with set attributes when the element is connected to the DOM
 * @returns {void}
 * @private
 */
function _runMethodsFromAttributes() {
  var _this15 = this;
  // We have to wait until the api is ready to set the current time
  if (_assertClassBrand(_WistiaPlayer_brand, this, _getValueFromAttribute).call(this, 'current-time') !== null) {
    this.whenApiReady().then(function () {
      var _ref24, _classPrivateFieldGet97, _classPrivateFieldGet98;
      var newTime = Number(_assertClassBrand(_WistiaPlayer_brand, _this15, _getValueFromAttribute).call(_this15, 'current-time'));
      var isClosedPopover = (_ref24 = ((_classPrivateFieldGet97 = _classPrivateFieldGet(_api, _this15)) === null || _classPrivateFieldGet97 === void 0 ? void 0 : _classPrivateFieldGet97.popover) && !_classPrivateFieldGet(_api, _this15).popover.isVisible()) !== null && _ref24 !== void 0 ? _ref24 : false;
      var isMobile = (0,_utilities_detect_js__WEBPACK_IMPORTED_MODULE_7__/* .detectIsMobile */ .GS)();
      var shouldDelayUntilPlay = _this15.state !== 'playing' && (isMobile || isClosedPopover);
      void ((_classPrivateFieldGet98 = _classPrivateFieldGet(_impl, _this15)) === null || _classPrivateFieldGet98 === void 0 ? void 0 : _classPrivateFieldGet98.time(newTime, {
        lazy: shouldDelayUntilPlay
      }));
      _assertClassBrand(_WistiaPlayer_brand, _this15, _setSyncedEmbedOption).call(_this15, 'currentTime', newTime);
    })
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    .catch(function (_error) {});
  }
  if (_assertClassBrand(_WistiaPlayer_brand, this, _getValueFromAttribute).call(this, 'email') !== null) {
    _assertClassBrand(_WistiaPlayer_brand, this, _updateEmail).call(this, _assertClassBrand(_WistiaPlayer_brand, this, _getValueFromAttribute).call(this, 'email'));
  }
  if (_assertClassBrand(_WistiaPlayer_brand, this, _getValueFromAttribute).call(this, 'video-quality') !== null) {
    this.whenApiReady().then(function () {
      var _classPrivateFieldGet99;
      var newQuality = _assertClassBrand(_WistiaPlayer_brand, _this15, _getValueFromAttribute).call(_this15, 'video-quality');
      (_classPrivateFieldGet99 = _classPrivateFieldGet(_impl, _this15)) === null || _classPrivateFieldGet99 === void 0 ? void 0 : _classPrivateFieldGet99.setVideoQuality(newQuality);
      _assertClassBrand(_WistiaPlayer_brand, _this15, _setSyncedEmbedOption).call(_this15, 'videoQuality', newQuality);
    })
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    .catch(function (_error) {});
  }
}
/**
 * Saves the initial attributes from the DOM to a store so the public api can use them
 * @returns {void}
 * @private
 */
function _saveInitialAttributesFromDomOptions() {
  var _this16 = this;
  var domOptions = Object.fromEntries(Object.entries(this.attributes).map(function (_ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
      value = _ref26[1];
    return [(0,_utilities_camelCaseToKebabCase_ts__WEBPACK_IMPORTED_MODULE_30__/* .kebabCaseToCamelCase */ .b)(value.name), _assertClassBrand(_WistiaPlayer_brand, _this16, _getValueFromAttribute).call(_this16, value.name)];
  }));
  _classPrivateFieldGet(_playerData, this).setDomEmbedOptionSource(domOptions);

  // The public api uses this store when it gathers options from our many different sources
  (0,_utilities_embedOptionStore_ts__WEBPACK_IMPORTED_MODULE_9__/* .setEmbedOptionStore */ .gY)("__".concat(this.uniqueId, "_dom_options__"), _classPrivateFieldGet(_playerData, this).embedOptions);
}
/**
 * Sets both the value of an embed option from the public api
 * and the value of an embed option saved on this element.
 *
 * For now, the public api is the source of truth for embed options.
 * However, this will change in the future. We also need a non-public
 * api source for embed options so we can use them before the public
 * api is ready.
 * @param {string} key - Name of the embed option
 * @param {boolean | number | string} value - Value of the embed option
 * @returns {void}
 */
function _setSyncedEmbedOption(key, value) {
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  _classPrivateFieldGet(_logger, this).info("set ".concat(key), value.toString());
  if (_classPrivateFieldGet(_impl, this)) {
    _classPrivateFieldGet(_impl, this)._attrs[key] = value;
  }
  _classPrivateFieldGet(_playerData, this).updateEmbedOptionOverrides(_defineProperty({}, key, value));

  // Updates our PlayerDataProvider and re-renders the thumbnail with the new embed option
  _assertClassBrand(_WistiaPlayer_brand, this, _renderPreloadThumbnail).call(this);
}
function _setupEventListeners() {
  var _this17 = this;
  var loadedMediaDataCallback = function loadedMediaDataCallback(event) {
    var _ref27 = event.detail,
      mediaData = _ref27.mediaData;
    _assertClassBrand(_WistiaPlayer_brand, _this17, _updateMediaData).call(_this17, mediaData);
  };
  var implCreatedCallback = function implCreatedCallback(event) {
    _classPrivateFieldSet(_impl, _this17, event.detail.impl);
  };
  this.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .LOADED_MEDIA_DATA_EVENT */ .rO, loadedMediaDataCallback);
  this.addEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .IMPL_CREATED_EVENT */ .dp, implCreatedCallback);
  _classPrivateFieldGet(_removeEventListeners, this).push(function () {
    _this17.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .LOADED_MEDIA_DATA_EVENT */ .rO, loadedMediaDataCallback);
  }, function () {
    _this17.removeEventListener(_utilities_eventConstants_ts__WEBPACK_IMPORTED_MODULE_29__/* .IMPL_CREATED_EVENT */ .dp, implCreatedCallback);
  });
  this.addEventListener('click', _classPrivateFieldGet(_handlePreloadThumbnailClick, this), {
    once: true
  });
}
/**
 * Determines if a swatch should be displayed based on the embed options
 * @returns {boolean}
 */
function _shouldDisplaySwatch() {
  // If this is a popover and it renders a thumbnail in its container, we'll want to show a swatch
  return this.swatch !== false && (!this.wistiaPopover || _assertClassBrand(_WistiaPlayer_brand, this, _isPopoverWithThumbnail).call(this));
}
/**
 * Saves new email within localstorage and dispatches an emailchange event
 * @param {string} email - The new email
 * @returns {void}
 * @emits {EmailChangeEventData}
 * @private
 */
function _updateEmail(email) {
  var _this18 = this;
  (0,_utilities_wistiaLocalStorage_js__WEBPACK_IMPORTED_MODULE_19__/* .updateWistiaLocalStorage */ .$B)(function (localStorage) {
    // eslint-disable-next-line no-param-reassign
    localStorage[_classPrivateGetter(_WistiaPlayer_brand, _this18, _get_pageUrl)] = _objectSpread(_objectSpread({}, localStorage[_classPrivateGetter(_WistiaPlayer_brand, _this18, _get_pageUrl)]), {}, {
      trackEmail: email
    });
  });
  this.dispatchEvent(new CustomEvent('emailchange', {
    detail: {
      email: email
    }
  }));
}
/**
 * Called when we have new mediadata for the player
 * @param {MediaData} mediaData
 * @returns {void}
 * @private
 */
function _updateMediaData(mediaData) {
  _classPrivateFieldGet(_playerData, this).setMediaDataSource(mediaData);
  _classPrivateFieldSet(_playerType, this, (0,_utilities_judy_js__WEBPACK_IMPORTED_MODULE_13__/* .choosePlayer */ .$F)(_classPrivateFieldGet(_judyContext, this), _classPrivateFieldGet(_playerData, this).mediaData, _classPrivateFieldGet(_playerData, this).embedOptions));
  _assertClassBrand(_WistiaPlayer_brand, this, _renderPreloadThumbnail).call(this);
}
var getSwatchMetaData = /*#__PURE__*/function () {
  var _ref18 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25(url) {
    var swatch;
    return _regeneratorRuntime().wrap(function _callee25$(_context25) {
      while (1) switch (_context25.prev = _context25.next) {
        case 0:
          swatch = new Image();
          swatch.src = url;
          _context25.next = 4;
          return swatch.decode();
        case 4:
          return _context25.abrupt("return", swatch);
        case 5:
        case "end":
          return _context25.stop();
      }
    }, _callee25);
  }));
  return function getSwatchMetaData(_x19) {
    return _ref18.apply(this, arguments);
  };
}();

/**
 * Takes a media id and returns a swatch style element once we
 * have the swatch image metadata to calculate the aspect ratio
 * @param {string} mediaId
 * @returns {Promise<HTMLStyleElement>}
 */
var wistiaSwatchElement = /*#__PURE__*/function () {
  var _ref19 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26(mediaId, embedHost) {
    var swatchUrl, swatchImg, naturalHeight, naturalWidth, ratio, style;
    return _regeneratorRuntime().wrap(function _callee26$(_context26) {
      while (1) switch (_context26.prev = _context26.next) {
        case 0:
          swatchUrl = getSwatchUrl(mediaId, embedHost);
          _context26.next = 3;
          return getSwatchMetaData(swatchUrl);
        case 3:
          swatchImg = _context26.sent;
          naturalHeight = swatchImg.naturalHeight, naturalWidth = swatchImg.naturalWidth;
          ratio = naturalHeight / naturalWidth * 100;
          style = document.createElement('style');
          style.innerHTML = "\n    wistia-player[media-id='".concat(mediaId, "']:not(:defined) {\n      padding: ").concat(ratio, "% 0 0 0;\n      background: url(").concat(swatchUrl, ");\n      background-size: contain;\n      filter: blur(5px);\n      display: block;\n    }\n  ");
          return _context26.abrupt("return", style);
        case 9:
        case "end":
          return _context26.stop();
      }
    }, _callee26);
  }));
  return function wistiaSwatchElement(_x20, _x21) {
    return _ref19.apply(this, arguments);
  };
}();
if (customElements.get('wistia-player') === undefined) {
  customElements.define('wistia-player', WistiaPlayer);
}
var __webpack_exports__WistiaPlayer = __webpack_exports__.$
var __webpack_exports__wistiaSwatchElement = __webpack_exports__.A
export { __webpack_exports__WistiaPlayer as WistiaPlayer, __webpack_exports__wistiaSwatchElement as wistiaSwatchElement };

//# sourceMappingURL=wistia-player.js.map